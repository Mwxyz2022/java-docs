---
layout: default
title: "Шаблони проєктування (Design Patterns)"
parent: "Patterns and Recursion"
grand_parent: "Java Core"
nav_order: 1
---

# Шаблони проєктування (Design Patterns)

* короткий опис: Шаблони проєктування — це стандартизовані, повторювані рішення загальних проблем проєктування програмного забезпечення, які виникають під час розробки. Вони діють як перевірені "рецепти" для вирішення типових архітектурних проблем.

* поняття: `Шаблони проєктування` (Design Patterns), `GoF` (Gang of Four), `Породжувальні` (Creational), `Структурні` (Structural), `Поведінкові` (Behavioral), `Переінженеринг` (Over-engineering).

* приклади: `Singleton`, `Factory`, `Builder`, `Abstract Factory`, `Prototype` (Породжувальні); `Adapter`, `Composite`, `Decorator`, `Proxy` (Структурні); `Strategy`, `Observer`, `Template Method`, `Command` (Поведінкові).

* ключові моменти: Шаблони дають спільну мову розробникам; це не конкретний код, а ідея організації рішення; їх слід використовувати лише за потребою, уникаючи переінженерінгу.

* що важливо знати на співбесіді: Визначення шаблонів, класифікація `GoF`, їх мета (покращення архітектури, читабельності, повторне використання), відмінність `шаблону` від `архітектурного підходу` та `фреймворку`.

### **✅ Офіційне визначення:**

**Шаблони проєктування (Design Patterns)** — це стандартизовані, повторювані рішення загальних проблем проєктування програмного забезпечення, які виникають під час розробки.

Вперше формально описані у книзі *"Design Patterns: Elements of Reusable Object-Oriented Software"* (GoF, 1994).

### **🧠 Простими словами:**

**Шаблони** — це перевірені способи вирішення типових проблем у коді. Це як **«рецепти»** або **«шпаргалки»**, що підказують: “у такій ситуації краще зроби ось так, бо це вже не раз працювало добре”.

---

## **📊 Класифікація за GoF (Gang of Four):**

| Категорія | Назва патернів | Приклади |
| ----- | ----- | ----- |
| **🔨 Породжувальні** | Як створювати об'єкти | Singleton, Factory, Builder, Abstract Factory, Prototype |
| 🏗 **Структурні** | Як компонувати об'єкти між собою | Adapter, Composite, Decorator, Proxy, Bridge, Flyweight, Facade |
| 🔁 **Поведінкові** | Як організувати взаємодію | Strategy, Observer, Template Method, Command, State, Chain of Responsibility |

---

## **Пояснення на пальцях (💡)**

### **Навіщо шаблони?**  

  Вони дають спільну мову розробникам. Наприклад, сказавши “це Strategy”, ти одразу пояснив, як працює логіка заміни алгоритмів.

### **У чому особливість?**  

  Це не конкретний код, а ідея — як краще організувати рішення певної проблеми.

### **Типові граблі?**  

  📉 **Переінженеринг** — коли використовують патерни без потреби. Не пхай патерн просто “**щоб було**”.

### **Коли застосовувати?**  

  Коли бачиш повторювану архітектурну проблему — замість вигадувати велосипед, краще використати готовий шаблон.

---

## **Корисні приклади (🧪)**

* Хочеш, щоб був тільки один об’єкт конфігурації у всій програмі — ➤ використай **Singleton**.
* Є купа способів створити об’єкт залежно від умов — ➤ **Factory Method**.
* Потрібно замінювати частину алгоритму в залежності від параметрів — ➤ **Strategy**.
* Маєш UI-компоненти, які можуть бути або одним елементом, або групою — ➤ **Composite**.

---

## **Порівняння (⚖️)**

| Категорія | Коли використовувати | Основна вигода |
| ----- | ----- | ----- |
| **Породжувальні** | Створення об’єктів, приховування логіки | Контроль над створенням |
| **Структурні** | Побудова складних структур з об’єктів | Зменшення залежностей |
| **Поведінкові** | Взаємодія об’єктів, алгоритми, керування | Гнучкість і замінність |

---

## **🧠 Мнемоніка для запам’ятовування:**

**PPP** \= Породжувальні, Поведінкові, **П**труктурні (жартома для легшого запам'ятовування).

**Singleton — Один**, **Factory — Вибір**, **Strategy — Заміна логіки**, **Observer — Слухач**, **Composite — Дерево**

---

## **🟩 Підсумок:**

**Шаблони проєктування** — це готові рішення для типових проблем у розробці. Вони не прив’язані до мови, але в Java реалізуються через класи, інтерфейси й наслідування. Головне — розуміти, коли і чому їх застосовувати, а не просто "впихувати для галочки". Це основа для побудови розширюваного, підтримуваного й зрозумілого коду.

---

### **🔗 Додаткові джерела:**

* [**Oracle Java Design Patterns Guide**](https://docs.oracle.com/javase/tutorial/uiswing/design/index.html)

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке шаблон проєктування (Design Pattern)?

> #### **💬 Відповідь:**
>
> **Шаблон проєктування** — це перевірене, стандартизоване та повторюване вирішення поширеної проблеми, що виникає при проєктуванні програмного забезпечення.
>
> Це **не** конкретний фрагмент коду, готова бібліотека або алгоритм. Це **концептуальний шаблон або "рецепт"**, який описує, як взаємодіють об'єкти та класи для вирішення певної задачі, і може бути реалізований на різних мовах програмування.
>
> **Основна мета шаблонів:**
>
> * Надати готові, перевірені часом рішення.
> * Створити спільний словник для розробників, що спрощує комунікацію.
> * Підвищити гнучкість, розширюваність та підтримуваність коду.

#### **📝 Аналогія:**

Це як будівельні норми та прийоми. Коли архітектор проєктує арку, він не винаходить її з нуля. Він використовує перевірений часом шаблон аркової конструкції. Він знає, які елементи потрібні і як вони мають бути з'єднані для міцності.

#### **📌 Що перевіряють:**

*Розуміння того, що шаблон — це концепція, а не конкретна реалізація. Кандидат не повинен плутати шаблони з бібліотеками, фреймворками або алгоритмами.*

* * *

### **2 ❓ Питання:**

Назвіть три основні категорії шаблонів проєктування за класифікацією "Банди чотирьох" (GoF) і коротко опишіть їх.

> #### **💬 Відповідь:**
>
> Класична класифікація з книги "Design Patterns: Elements of Reusable Object-Oriented Software" ділить шаблони на три категорії:
>
> 1. **Породжувальні (Creational Patterns):**
>     * **Призначення:** Відповідають за процес створення об'єктів, роблячи його більш гнучким та керованим. Вони дозволяють приховати логіку створення і відокремити клієнтський код від конкретних класів, що створюються.
>     * **Приклади:** `Singleton`, `Factory Method`, `Abstract Factory`, `Builder`, `Prototype`.
>
> 2. **Структурні (Structural Patterns):**
>     * **Призначення:** Відповідають за композицію класів та об'єктів для формування більших і складніших структур. Вони показують, як успадкування та композиція можуть бути використані для створення нових функціональностей.
>     * **Приклади:** `Adapter`, `Decorator`, `Proxy`, `Facade`, `Composite`, `Bridge`.
>
> 3. **Поведінкові (Behavioral Patterns):**
>     * **Призначення:** Відповідають за ефективну взаємодію та розподіл відповідальності між об'єктами. Вони визначають шаблони комунікації між об'єктами.
>     * **Приклади:** `Strategy`, `Observer`, `Template Method`, `Command`, `State`, `Chain of Responsibility`.

#### **📝 Мнемоніка:**

* **Породжувальні** — як **C**творити об'єкт? (`C`reational)
* **Структурні** — як **S**класти об'єкти? (`S`tructural)
* **Поведінкові** — як об'єкти **B**алакають між собою? (`B`ehavioral)

#### **📌 Що перевіряють:**

*Знання базової класифікації GoF, що є основою для будь-якої розмови про шаблони.*

* * *

### **3 ❓ Питання:**

У чому різниця між шаблоном, фреймворком та бібліотекою?

> #### **💬 Відповідь:**
>
> Це три різні рівні абстракції, які часто плутають.
>
> * **Шаблон (Pattern):**
>   * **Що це:** Ідея, концепція, "рецепт" вирішення проблеми.
>   * **Результат:** Ви реалізуєте його самі у своєму коді.
>
> * **Бібліотека (Library):**
>   * **Що це:** Набір готових класів та функцій, які ви можете використовувати.
>   * **Контроль:** **Ви контролюєте** потік виконання програми і викликаєте код бібліотеки, коли вам це потрібно. (Наприклад, `java.util.ArrayList`, Apache Commons).
>
> * **Фреймворк (Framework):**
>   * **Що це:** Каркас або "скелет" застосунку, який диктує його архітектуру та життєвий цикл.
>   * **Контроль:** **Фреймворк контролює** потік виконання і викликає ваш код у потрібні моменти (принцип інверсії керування, Inversion of Control). (Наприклад, `Spring`, `JavaServer Faces`).
>
> **Коротко:** Ви викликаєте **бібліотеку**. **Фреймворк** викликає вас. А **шаблон** — це те, що ви використовуєте для написання коду і для фреймворка, і з бібліотекою.

#### **📌 Що перевіряють:**

*Розуміння рівнів абстракції та різниці між "інструментами" (бібліотека), "правилами гри" (фреймворк) та "стратегіями гри" (шаблони).*

* * *

### **4 ❓ Питання:**

Коли варто, а коли не варто використовувати шаблони проєктування? Що таке "оверинжиніринг"?

> #### **💬 Відповідь:**
>
> **Коли варто використовувати шаблони:**
>
> * Коли ви стикаєтеся з **поширеною, повторюваною проблемою**, для якої вже існує перевірене рішення.
> * Коли вам потрібно **покращити гнучкість, розширюваність або підтримуваність** коду. Наприклад, якщо вам потрібно додати можливість легко замінювати алгоритми, краще використати `Strategy`.
> * Коли потрібно спростити складну систему для клієнтського коду ( `Facade`).
>
> **Коли не варто використовувати шаблони:**
>
> * **"Просто тому, що я знаю цей шаблон".** Сліпе застосування шаблонів без реальної потреби є головною помилкою.
> * Коли **простішого рішення достатньо**. Не варто ускладнювати простий код громіздкими шаблонами.
>
> **Оверинжиніринг (Over-engineering)** — це процес створення надмірно складного, громіздкого або "пере-абстрагованого" рішення для відносно простої проблеми. Застосування складних шаблонів там, де вони не потрібні, є класичним прикладом оверинжинірингу. Це робить код складнішим для розуміння та підтримки.

#### **📝 Приказка:**</h4>

"Коли у вас в руках молоток, все навколо схоже на цвях". Це ідеально описує проблему надмірного використання шаблонів.

#### **📌 Що перевіряють:**

*Зрілість кандидата як інженера. Здатність оцінювати доцільність застосування інструментів, а не просто знати про їх існування.*

* * *

### **5 ❓ Питання:**

Які породжувальні шаблони ви знаєте? Наведіть приклад для одного з них. ⭐️

> #### **💬 Відповідь:**
>
> До породжувальних шаблонів належать ті, що займаються створенням об'єктів. Основні з них:
>
> * `Singleton` (Одинак)
> * `Factory Method` (Фабричний метод)
> * `Abstract Factory` (Абстрактна фабрика)
> * `Builder` (Будівельник)
> * `Prototype` (Прототип)
>
> **Приклад: `Singleton`**
>
> **Проблема:** Вам потрібно гарантувати, що в усій програмі існуватиме лише один екземпляр певного класу (наприклад, клас для конфігурації, логера або пулу з'єднань).
>
> **Рішення:**
>
> 1. Зробити конструктор приватним, щоб заборонити створення об'єктів через `new`.
> 2. Створити статичне поле, яке буде зберігати єдиний екземпляр.
> 3. Надати публічний статичний метод (зазвичай `getInstance()`), який повертає цей єдиний екземпляр.
>
> **Приклад коду (потокобезпечний через `enum`):**
>
> ```java
> public enum ConfigurationManager {
>     INSTANCE; // Єдиний екземпляр
>
>     private String databaseUrl;
>
>     // Конструктор enum є неявним та приватним
>
>     public String getDatabaseUrl() {
>         // Тут може бути логіка завантаження з файлу
>         return databaseUrl;
>     }
>     //... інші методи
> }
>
> // Використання:
> // ConfigurationManager config = ConfigurationManager.INSTANCE;
> ```
>
> Використання `enum` — це найпростіший і найнадійніший спосіб реалізувати Singleton в сучасній Java.

#### **📌 Що перевіряють:**

*Знання конкретних шаблонів та здатність не тільки описати їх, але й навести короткий, коректний приклад реалізації.*

* * *

### **6 ❓ Питання:**

Які структурні шаблони ви знаєте? Поясніть один із них. ⭐️

> #### **💬 Відповідь:**
>
> До структурних шаблонів належать ті, що допомагають компонувати об'єкти в більші структури. Основні:
>
> * `Adapter` (Адаптер)
> * `Decorator` (Декоратор)
> * `Proxy` (Замісник)
> * `Facade` (Фасад)
> * `Composite` (Компонувальник)
> * `Bridge` (Міст)
> * `Flyweight` (Легковаговик)
>
> **Приклад: `Decorator`**
>
> **Проблема:** Вам потрібно додати нову функціональність до існуючого об'єкта динамічно, під час виконання, не змінюючи його клас.
>
> **Рішення:** Створити клас-декоратор, який "обгортає" оригінальний об'єкт. Декоратор реалізує той самий інтерфейс, що й оригінальний об'єкт. Він делегує виклики методів "обгорнутому" об'єкту, додаючи до або після них свою власну логіку.
>
> **Приклад з `java.io`:**
> `java.io` є класичним прикладом використання `Decorator`.
>
> ```java
> // 1. Базовий об'єкт, що записує байти у файл
> OutputStream os = new FileOutputStream("file.txt");
>
> // 2. "Декоруємо" його для буферизації (додаємо продуктивність)
> OutputStream bufferedOs = new BufferedOutputStream(os);
>
> // 3. "Декоруємо" ще раз для можливості запису об'єктів (додаємо нову функціональність)
> ObjectOutputStream oos = new ObjectOutputStream(bufferedOs);
>
> oos.writeObject(new MyObject()); // Виклик проходить через весь ланцюжок декораторів
> oos.close();
> ```
>
> `BufferedOutputStream` і `ObjectOutputStream` — це декоратори, що динамічно розширюють можливості `FileOutputStream`.

#### **📌 Що перевіряють:**

*Знання конкретних структурних шаблонів та здатність впізнати їхнє використання у стандартній бібліотеці Java.*

* * *

### **7 ❓ Питання:**

Які поведінкові шаблони ви знаєте? Наведіть приклад для одного. ⭐️

> #### **💬 Відповідь:**
>
> До поведінкових шаблонів належать ті, що визначають взаємодію між об'єктами. Основні:
>
> * `Strategy` (Стратегія)
> * `Observer` (Спостерігач)
> * `Template Method` (Шаблонний метод)
> * `Command` (Команда)
> * `State` (Стан)
> * `Chain of Responsibility` (Ланцюжок обов'язків)
> * `Iterator` (Ітератор)
> * `Mediator` (Посередник)
>
> **Приклад: `Strategy`**
>
> **Проблема:** У вас є алгоритм, але різні його частини (кроки) можуть змінюватися. Ви хочете мати можливість легко замінювати ці частини під час виконання, не змінюючи основний клас.
>
> **Рішення:** Винести різні варіанти алгоритму (стратегії) в окремі класи, що реалізують спільний інтерфейс. Основний клас (контекст) буде зберігати посилання на об'єкт-стратегію і делегувати йому виконання відповідної частини роботи.
>
> **Приклад:** Система сортування.
>
> ```java
> // 1. Інтерфейс стратегії
> interface SortStrategy {
>     void sort(int[] array);
> }
>
> // 2. Конкретні реалізації стратегій
> class BubbleSortStrategy implements SortStrategy { /* ... */ }
> class QuickSortStrategy implements SortStrategy { /* ... */ }
>
> // 3. Клас-контекст
> class Sorter {
>     private SortStrategy strategy;
>
>     public Sorter(SortStrategy strategy) {
>         this.strategy = strategy;
>     }
>
>     public void setStrategy(SortStrategy strategy) {
>         this.strategy = strategy;
>     }
>
>     public void performSort(int[] array) {
>         strategy.sort(array); // Делегування роботи стратегії
>     }
> }
>
> // Використання:
> Sorter sorter = new Sorter(new BubbleSortStrategy());
> sorter.performSort(data);
> sorter.setStrategy(new QuickSortStrategy()); // Змінюємо стратегію "на льоту"
> sorter.performSort(data);
> ```
>
> `Arrays.sort()` в Java використовує цей підхід, приймаючи `Comparator` як стратегію для порівняння.

#### **📌 Що перевіряють:**

*Знання конкретних поведінкових шаблонів та вміння змоделювати ситуацію, де такий шаблон буде доречним.*

* * *

### **8 ❓ Питання:**

У чому різниця між шаблонами `Factory Method` та `Abstract Factory`? ⭐️

> #### **💬 Відповідь:**
>
> Обидва є породжувальними шаблонами, але вони вирішують проблеми різного масштабу.
>
> * **`Factory Method` (Фабричний метод):**
>   * **Проблема:** Делегувати створення **одного** об'єкта підкласам.
>   * **Структура:** Визначає **один метод** в суперкласі (часто абстрактний), який повертає об'єкт. Кожен підклас може перевизначити цей метод, щоб повертати свій власний тип об'єкта.
>   * **Аналогія:** Це як один верстат на заводі, який може бути налаштований для виробництва різних типів одного продукту.
>
> * **`Abstract Factory` (Абстрактна фабрика):**
>   * **Проблема:** Створити **сімейство пов'язаних або взаємозалежних об'єктів**, не прив'язуючись до їхніх конкретних класів.
>   * **Структура:** Визначає **інтерфейс (абстрактну фабрику)** з набором методів для створення продуктів (`createButton()`, `createCheckbox()` тощо). Конкретні фабрики реалізують цей інтерфейс для створення продуктів певного стилю (наприклад, `WindowsFactory` і `MacOSFactory`).
>   * **Аналогія:** Це цілий завод, який виробляє повний набір сумісних продуктів (наприклад, всі запчастини для `iPhone` або всі запчастини для `Samsung`).
>
> **Коротко:** `Factory Method` — про один метод для одного об'єкта, `Abstract Factory` — про інтерфейс з багатьма методами для сімейства об'єктів.

#### **📌 Що перевіряють:**

*Здатність розрізняти схожі шаблони та розуміти, на вирішення проблем якого масштабу вони націлені.*

* * *

### **9 ❓ Питання:**

У чому різниця між шаблонами `Decorator` та `Proxy`? Вони обидва є "обгортками". ⭐️

> #### **💬 Відповідь:**
>
> Хоча і `Decorator`, і `Proxy` є "обгортками" (реалізують той самий інтерфейс, що й оригінальний об'єкт), їхнє **призначення** є абсолютно різним.
>
> * **`Decorator` (Декоратор):**
>   * **Мета:** **Додати нову функціональність** до об'єкта динамічно. Декоратор не змінює основної поведінки об'єкта, а лише "прикрашає" його, розширюючи можливості. Клієнт зазвичай знає, що працює з декоратором.
>   * **Приклад:** Додати буферизацію (`BufferedInputStream`) або стиснення (`GzipOutputStream`) до потоку даних.
>
> * **`Proxy` (Замісник):**
>   * **Мета:** **Контролювати доступ** до оригінального об'єкта. Проксі "прикидається" оригінальним об'єктом і вирішує, коли і як передати йому виклик. Клієнт може навіть не знати, що працює з проксі, а не з реальним об'єктом.
>   * **Приклад:** Ледача ініціалізація ("важкого" об'єкта), кешування результатів, контроль доступу (перевірка прав перед викликом методу), логування викликів. `RMI` в Java використовує проксі.
>
> **Коротко:** `Decorator` **розширює**, `Proxy` **контролює**.

#### **📌 Що перевіряють:**

*Здатність розрізняти шаблони за їхнім наміром (intent), а не лише за структурою.*

* * *

### **10 ❓ Питання:**

Чому шаблон Singleton іноді вважається антипатерном? ⭐️

> #### **💬 Відповідь:**
>
> `Singleton` часто критикують, особливо в контексті сучасних фреймворків та принципів SOLID, через такі недоліки:
>
> 1. **Порушення принципу єдиної відповідальності (SRP):** Клас `Singleton` відповідає не тільки за свою бізнес-логіку, але й за контроль над своїм життєвим циклом (створення, надання доступу).
>
> 2. **Глобальний стан:** `Singleton` по суті є замаскованою глобальною змінною. Це ускладнює відстеження залежностей, робить код менш передбачуваним і може призводити до неявних зв'язків між різними частинами системи.
>
> 3. **Ускладнення тестування:** Модульне тестування стає складнішим, оскільки ви не можете легко замінити (`mock`) екземпляр `Singleton` в тестах. Стан одного тесту може вплинути на результат іншого через спільний екземпляр.
>
> 4. **Проблеми в багатопотоковому середовищі:** Потокобезпечна реалізація `Singleton` з "лінивою ініціалізацією" вимагає обережного використання синхронізації (наприклад, `double-checked locking`, який сам по собі є складним).
>
> **Альтернатива:** У сучасних фреймворках (як `Spring`) перевага надається **інверсії керування (IoC) та впровадженню залежностей (Dependency Injection)**. Фреймворк сам керує створенням одного екземпляра (біна зі скоупом `singleton`) і впроваджує його туди, де він потрібен. Це робить залежності явними і спрощує тестування.

#### **📌 Що перевіряють:**

*Критичний погляд на поширені шаблони. Знання про їхні недоліки та сучасні альтернативи, такі як DI.*

* * *

### **11 ❓ Питання:**

Як `java.util.Arrays.asList()` і `java.util.Collections.unmodifiableList()` пов'язані з шаблонами проєктування? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Ці методи є прикладами використання кількох шаблонів:
>
> * **`Arrays.asList()` — приклад шаблону `Adapter`**.
>   * Він **адаптує** масив до інтерфейсу `List`. Ви отримуєте об'єкт, який "виглядає" і поводиться як `List`, але насправді "під капотом" продовжує працювати з оригінальним масивом.
>   * Через це він має обмеження: ви не можете змінювати його розмір (`add`, `remove`), бо масив має фіксований розмір.
>
> * **`Collections.unmodifiableList()` — приклад шаблону `Decorator`**.
>   * Він "обгортає" існуючий `List` і повертає новий об'єкт `List`, який виглядає так само, але **блокує** всі методи, що змінюють його стан (`add`, `set`, `remove`, кидаючи `UnsupportedOperationException`).
>   * Він **додає** нову поведінку (незмінність), не змінюючи оригінальний список.
>
> Обидва методи також є прикладами патерну **`Статичний фабричний метод`**, оскільки вони є статичними методами, що створюють і повертають об'єкти.

#### **📌 Що перевіряють:**

*Здатність "впізнавати" шаблони у коді стандартної бібліотеки, що демонструє глибоке розуміння їх практичного застосування.*

* * *

### **12 ❓ Питання:**

У чому основна ідея шаблону `Command`? Наведіть простий приклад. ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Основна ідея `Command`** — інкапсулювати запит (виконання дії) як об'єкт. Це дозволяє:
>
> * Параметризувати клієнтів різними запитами.
> * Ставити запити в чергу або логувати їх.
> * Підтримувати операції, що скасовуються (undo).
>
> Шаблон відокремлює об'єкт, який ініціює операцію ("викликаючий"), від об'єкта, який знає, як її виконати ("приймач").
>
> **Структура:**
>
> 1. `Command` (інтерфейс): Має один метод, зазвичай `execute()`.
> 2. `ConcreteCommand` (конкретна команда): Реалізує `Command`, зберігає посилання на "приймача" і реалізує `execute`, викликаючи метод приймача.
> 3. `Invoker` (викликаючий): Зберігає об'єкт `Command` і викликає його `execute()`, не знаючи нічого про конкретну реалізацію.
> 4. `Receiver` (приймач): Виконує реальну роботу.
>
> **Простий приклад:** Пульт для телевізора.
>
> ```java
> interface Command { void execute(); } // Команда
>
> class Light { // Приймач
>     public void on() { System.out.println("Світло увімкнене"); }
>     public void off() { System.out.println("Світло вимкнене"); }
> }
>
> class LightOnCommand implements Command { // Конкретна команда
>     private Light light;
>     public LightOnCommand(Light light) { this.light = light; }
>     public void execute() { light.on(); }
> }
>
> class RemoteControl { // Викликаючий
>     private Command command;
>     public void setCommand(Command command) { this.command = command; }
>     public void pressButton() { command.execute(); }
> }
>
> // Використання:
> RemoteControl remote = new RemoteControl();
> Light light = new Light();
> remote.setCommand(new LightOnCommand(light));
> remote.pressButton(); // Виведе "Світло увімкнене"
> ```

#### **📌 Що перевіряють:**

*Розуміння ідеї інкапсуляції запиту як об'єкта та вміння реалізувати базову структуру шаблону `Command`.*

* * *

### **13 ❓ Питання:**

Чи можете ви описати, як працює шаблон `Chain of Responsibility` (Ланцюжок обов'язків)? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Основна ідея:** Уникнути прив'язки відправника запиту до його отримувача, даючи можливість кільком об'єктам обробити запит. Об'єкти-обробники вишиковуються в ланцюжок. Запит передається по ланцюжку, доки один з об'єктів його не обробить.
>
> **Як працює:**
>
> 1. Створюється інтерфейс обробника (`Handler`), який має метод для обробки запиту (наприклад, `handleRequest(Request r)`) і посилання на наступний обробник у ланцюжку.
>
> 2. Конкретні обробники реалізують цей інтерфейс. У своєму методі обробки кожен обробник вирішує:
>     * Чи може він обробити цей запит?
>     * Якщо так, він його обробляє і, можливо, зупиняє подальшу передачу.
>     * Якщо ні, він **передає запит наступному обробнику** в ланцюжку, викликаючи `nextHandler.handleRequest(r)`.
>
> **Класичний приклад:** Обробка HTTP-запитів у веб-фреймворках (middleware/фільтри).
>
> `Запит -> [Фільтр аутентифікації] -> [Фільтр логування] -> [Фільтр валідації] -> Основний обробник`
>
> Кожен фільтр може або обробити запит і повернути відповідь (наприклад, фільтр аутентифікації поверне `401 Unauthorized`), або передати його далі по ланцюжку.

#### **📌 Що перевіряють:**

*Знання менш поширених, але важливих шаблонів та розуміння їхньої динаміки (передача запиту по ланцюжку).*

* * *

### **14 ❓ Питання:**

У чому різниця між `Strategy` та `State`? Їхні UML-діаграми дуже схожі. ⭐️⭐️

> #### **💬 Відповідь:**
>
> Хоча структурно вони дійсно схожі (обидва делегують поведінку іншим об'єктам), вони вирішують **абсолютно різні проблеми** і мають різний намір.
>
> * **`Strategy` (Стратегія):**
>   * **Намір:** Надати можливість **клієнту** вибирати або замінювати **алгоритм** під час виконання.
>   * **Хто керує?:** Клієнтський код зазвичай явно передає або змінює стратегію в об'єкті-контексті.
>   * **Приклад:** Вибір способу сортування (швидке, бульбашкове), вибір способу оплати (картка, PayPal). Стратегія зазвичай не знає про контекст.
>
> * **`State` (Стан):**
>   * **Намір:** Дозволити об'єкту **змінювати свою поведінку, коли змінюється його внутрішній стан**.
>   * **Хто керує?:** Сам **об'єкт-контекст** або **об'єкти-стани** керують переходом від одного стану до іншого. Клієнт не втручається в цей процес.
>   * **Приклад:** Торговий автомат (стани "Немає грошей", "Є гроші", "Товар продано"), документ у системі документообігу (стани "Чернетка", "На узгодженні", "Затверджено").
>
> **Ключова відмінність:** `Strategy` — це про те, *як* об'єкт щось робить (алгоритм), і це вирішує клієнт. `State` — це про те, *чим є* об'єкт в даний момент, і це змінюється всередині самого об'єкта.

#### **📌 Що перевіряють:**

*Здатність розрізняти шаблони за їхнім наміром та динамікою, а не лише за статичною структурою. Це питання перевіряє глибину розуміння.*

* * *

### **15 ❓ Питання:**

Що таке антипатерн, і чи можете ви навести кілька прикладів, крім `Singleton`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Антипатерн** — це поширене, але **неефективне або контрпродуктивне** рішення типової проблеми проєктування. Це "погана практика", яка спочатку може здатися хорошим рішенням, але в довгостроковій перспективі призводить до проблем.
>
> Це "пастка", в яку часто потрапляють розробники.
>
> **Приклади антипатернів:**
>
> 1. **`God Object` (Божественний об'єкт):**
>     * **Проблема:** Клас, який "знає занадто багато" і "робить занадто багато". Він концентрує в собі величезну кількість логіки, яка мала б бути розподілена між іншими класами.
>     * **Наслідки:** Порушує SRP, його складно тестувати, підтримувати та розуміти.
>
> 2. **`Spaghetti Code` (Код-спагеті):**
>     * **Проблема:** Код з дуже заплутаною структурою керування, з великою кількістю `goto`, довгими методами та відсутністю чіткої архітектури.
>     * **Наслідки:** Практично неможливо підтримувати, розширювати та розуміти.
>
> 3. **`Magic Numbers` / `Magic Strings` (Магічні числа/рядки):**
>     * **Проблема:** Використання неіменованих констант (чисел, рядків) прямо в коді.
>     * **Наслідки:** Код стає незрозумілим ("що означає це число 27?"), і для зміни значення його потрібно шукати по всьому проекту. Рішення — виносити їх в іменовані константи.
>
> 4. **`Premature Optimization` (Передчасна оптимізація):**
>     * **Проблема:** Оптимізація коду до того, як стало відомо, де насправді знаходяться "вузькі місця".
>     * **Наслідки:** Код стає складнішим і менш читабельним заради виграшу в продуктивності, який може бути незначним або взагалі відсутнім. "Передчасна оптимізація — корінь усіх бід", — Дональд Кнут.

#### **📌 Що перевіряють:**

*Широкий інженерний кругозір. Розуміння не тільки "як треба робити", але й "як не треба", і чому.*
