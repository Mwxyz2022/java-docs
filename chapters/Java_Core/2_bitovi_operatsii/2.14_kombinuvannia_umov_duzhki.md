---
layout: default
title: "Комбінування умов, дужки ()"
parent: "Бітові операції"
grand_parent: "Java Core"
nav_order: 14
---

# Комбінування умов, дужки ()

* короткий опис: Використання дужок `()` для контролю порядку виконання логічних операцій у складних виразах, що дозволяє перевизначити стандартний пріоритет операторів.

* поняття: Пріоритет операторів, дужки, групування виразів.

* приклади: `(a || b) && c` vs `a || b && c` (дужки змінюють результат завдяки зміні порядку).

* ключові моменти: Дужки мають найвищий пріоритет. Використання дужок покращує читабельність коду та уникнення логічних помилок.

* що важливо знати на співбесіді: Як пріоритет впливає на результат, важливість дужок для читабельності.

### **✅ Офіційне визначення:**

У Java комбінування умов дозволяє будувати складні логічні вирази за допомогою операторів **`&&, ||, !`** з використанням дужок **`()`** для контролю порядку виконання.

### **🧠 Простими словами:**

Як у математиці — поєднуємо умови:

* **`&&`** — "і"
* **`||`** — "або"
* **`()`** — як дужки в математиці, керують черговістю дій.

---

## **Основне**

| Оператор | Пріоритет | Назва |
| :---: | :---: | :---: |
| **`!`** | 1 (найвищий) | логічне **`NOT`** |
| **`&&`** | 2 | логічне **`AND`** |
| **||** | 3 | Логічне **`OR`** |

📌 **Дужки** мають найвищий пріоритет і змінюють порядок виконання

---

## **Пояснення на пальцях (💡)**

* Без дужок: виконується спочатку **`!`**, потім **`&&`**, потім **`||`**.
* З дужками: виконується те, що в дужках — як ти скажеш.

---

## **Корисні приклади (🧪)**

```java
boolean a = true;
boolean b = false;
boolean c = true;
boolean d = true;

boolean result1 = a && b || c && d;
// = (a && b) || (c && d)
// = (true && false) || (true && true)
// = false || true -> true

boolean result2 = a && (b || c) && d;
// = a && ((b || c) && d)
// = true && ((false || true) && true)
// = true && (true && true) -> true

boolean result3 = (a || b) && (!c || d);
// = (true || false) && (!true || true)
// = true && (false || true) -> true
```

---

## **Типові граблі (🟥)**

❌ Без дужок можна зловити **`NullPointerException`** або помилки через неправильний порядок:

```java
if (x != 0 || y / x > 1)  // якщо x == 0 -- впаде!
```

✅ Правильний спосіб:

```java
if (x != 0 && y / x > 1)  // перевіряємо x першим -- безпечно!
```

---

## **🧠 Мнемоніка для запам’ятовування:**

**`() > ! > && > ||`**

---

## **🟩 Підсумок:**

Комбінування умов з дужками — це твій інструмент контролю логіки. Дужки завжди перемагають пріоритети операторів, і допомагають уникнути багів та непорозумінь у коді.

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Яку роль відіграють дужки `()` у складних логічних виразах?

> #### **💬 Відповідь:**
>
> Дужки `()` у логічних виразах виконують ту ж саму роль, що і в математиці: вони **встановлюють порядок виконання операцій**, маючи найвищий пріоритет.
>
> Основні функції дужок:
>
> 1. **Зміна стандартного пріоритету операторів:** Вони змушують JVM спочатку обчислити вираз усередині дужок, ігноруючи стандартний пріоритет (`!`, `&&`, `||`).
>
> 2. **Покращення читабельності:** Навіть якщо стандартний пріоритет операторів збігається з бажаним, використання дужок робить код **більш зрозумілим та однозначним** для розробника, усуваючи необхідність пам'ятати правила пріоритету. Це зменшує ризик логічних помилок.
>
> **Приклад зміни пріоритету:**
>
> * `true || true && false` → спочатку `&&`, потім `||` → `true || false` → `true`.
> * `(true || true) && false` → спочатку `||`, потім `&&` → `true && false` → `false`.
>
> Як бачимо, дужки кардинально змінюють результат.

#### **📝 Коментар:**

**Золоте правило:** якщо у вас є сумніви щодо порядку виконання або вираз містить більше одного типу логічного оператора (`&&` та `||`), **завжди використовуйте дужки**. Це нічого не коштує, але робить код набагато надійнішим.

#### **📌 Що перевіряють:**

*Базове розуміння того, що дужки є інструментом для керування порядком обчислень, як у звичайній арифметиці.*

* * *

### **2 ❓ Питання:**

Який стандартний пріоритет у логічних операторів `!`, `&&` та `||`?

> #### **💬 Відповідь:**
>
> У Java існує чітко визначений пріоритет для логічних операторів, за яким компілятор групує вирази, якщо немає дужок.
>
> **Порядок пріоритету (від найвищого до найнижчого):**
>
> 1. **`!` (Логічне НЕ / NOT)** — унарний оператор, має найвищий пріоритет.
> 2. **`&&` (Логічне І / AND)** — має вищий пріоритет, ніж `||`.
> 3. **`||` (Логічне АБО / OR)** — має найнижчий пріоритет серед цих трьох.
>
> **Приклад:**
> Вираз `!a || b && c` буде інтерпретовано компілятором так:
> `(!a) || (b && c)`
>
> Спочатку буде обчислено `!a`, потім `b && c`, і лише після цього їхні результати будуть об'єднані оператором `||`.

#### **📝 Мнемоніка:**

Легко запам'ятати аналогію з математикою: `NOT` — як унарний мінус, `AND` — як множення, `OR` — як додавання.
`(-a) + (b * c)` → `(!a) || (b && c)`.

#### **📌 Що перевіряють:**

*Знання стандартних правил мови, що є фундаментальним для правильного читання коду без дужок.*

* * *

### **3 ❓ Питання:**

Що виведе цей код і чому? Поясніть порядок виконання.
`boolean result = true && false || true && !false;`

> #### **💬 Відповідь:**
>
> Цей код виведе **`true`**.
>
> Розберемо вираз, дотримуючись пріоритету операторів: **1. `!`**, **2. `&&`**, **3. `||`**.
>
> `true && false || true && !false`
>
> **Крок 1: Обчислення `!` (NOT):**
>
> * `!false` стає `true`.
> * Вираз перетворюється на: `true && false || true && true`
>
> **Крок 2: Обчислення `&&` (AND) зліва направо:**
>
> * Перший `&&`: `true && false` → `false`.
> * Вираз стає: `false || true && true`
> * Другий `&&`: `true && true` → `true`.
> * Вираз стає: `false || true`
>
> **Крок 3: Обчислення `||` (OR):**
>
> * `false || true` → `true`.
>
> Отже, фінальний результат, який буде присвоєно змінній `result`, — це `true`.

#### **📌 Що перевіряють:**

*Здатність застосувати правила пріоритету до складного ланцюжка операцій та покроково обчислити результат.*

* * *

### **4 ❓ Питання:**

Чому цей код може призвести до `NullPointerException`? Як його виправити за допомогою дужок?
`if (user == null || user.getName().isEmpty() && !user.isActive())`
Припустимо, `user` може бути `null`.

> #### **💬 Відповідь:**
>
> Цей код **може призвести до `NullPointerException`**, якщо `user` буде `null`.
>
> **Причина:**
>
> Проблема знову ж таки у **пріоритеті операторів**. `&&` має вищий пріоритет, ніж `||`.
> Тому вираз буде згруповано так:
> `(user == null) || (user.getName().isEmpty() && !user.isActive())`
>
> **Потік виконання, якщо `user` є `null`:**
>
> 1. Обчислюється ліва частина `||`: `user == null` → `true`.
> 2. Завдяки **короткому замиканню** оператора `||`, оскільки перша частина вже `true`, друга частина (`user.getName()...`) **не обчислюється**.
> 3. NPE не виникне.
>
> *Виправлення*: Я помилився. Код безпечний. Давайте змінимо умову, щоб продемонструвати проблему.
> `if (user.isActive() || user != null && user.hasRights())` - теж безпечно.

* * *

#### **Змінена відповідь на питання №4:**

> #### **💬 Відповідь:**
>
> Розглянемо інший, більш небезпечний вираз:
> `if (isReportPublic || user != null && user.hasAccessToReport())`
> Припустимо, `isReportPublic` є `false`, а `user` є `null`.
>
> **Потік виконання:**
>
> 1. Через пріоритет `&&` вираз групується як:
>     `(isReportPublic) || (user != null && user.hasAccessToReport())`
> 2. Обчислюється перша частина `||`: `isReportPublic` → `false`.
> 3. Оскільки перша частина `false`, `||` змушений обчислити другу частину.
> 4. Починається обчислення `(user != null && user.hasAccessToReport())`:
>     * `user != null` → `false`.
>     * Через коротке замикання `&&`, друга частина (`user.hasAccessToReport()`) не обчислюється.
> 5. Результат другої частини `false`.
> 6. `false || false` → `false`. `NPE` не виникло.
>
> Здається, в стандартних випадках складно створити `NPE` через пріоритет. **Однак, проблема не в NPE, а в логіці.**
>
> Розглянемо вираз: **"Доступ дозволено, якщо юзер — адмін, або якщо він — звичайний юзер і запит прийшов з локальної мережі".**
> `boolean hasAccess = isAdmin || isRegularUser && isLocalRequest;`
>
> Тут `&&` зв'яже `isRegularUser` з `isLocalRequest`, що логічно правильно. Проблеми виникають, коли **намір розробника розходиться** з пріоритетом.
>
> **Виправлення за допомогою дужок:**
> У складних виразах дужки потрібні для **явності**, навіть якщо стандартний пріоритет дає правильний результат.
> `if ( (user != null && user.isLoggedIn()) || isGuestAccessAllowed )`
>
> Цей запис явно показує, що спочатку перевіряється "блок" залогіненого користувача, і лише потім — гостьовий доступ.

#### **📌 Що перевіряють:**

*Здатність читати складні вирази та бачити, як групування впливає на логіку. Розуміння, що дужки — це в першу чергу інструмент для читабельності та уникнення логічних помилок.*

* * *

### **5 ❓ Питання:**

Як написати умову для перевірки, чи знаходиться число `x` в діапазоні від 10 до 20 (включно)?

> #### **💬 Відповідь:**
>
> Це завдання вимагає комбінування двох умов за допомогою оператора **`&&` (Логічне І)**.
>
> Число `x` знаходиться в діапазоні, якщо воно **одночасно** більше або дорівнює 10 **І** менше або дорівнює 20.
>
> **Код:**
>
> ```java
> int x = 15;
> if (x >= 10 && x <= 20) {
>     System.out.println("Число знаходиться в діапазоні.");
> }
> ```
>
> **Чому не можна написати `10 <= x <= 20`?**
>
> Такий синтаксис, хоч і поширений в математиці, є **невалідним у Java**. Оператори порівняння (`<=`, `>=`) не можна об'єднувати в ланцюжки. Компілятор розіб'є це як `(10 <= x) <= 20`, де `(10 <= x)` поверне `boolean`, а потім спробує порівняти `boolean` з `20`, що призведе до помилки компіляції.
>
> Тому правильний спосіб — це завжди комбінувати дві окремі перевірки через `&&`.

#### **📌 Що перевіряють:**

*Знання правильного синтаксису для перевірки діапазонів та розуміння обмежень мови.*

* * *

### **6 ❓ Питання:**

Перепишіть цей код, використовуючи один `if` та логічні оператори:

```java
if (x > 0) {
    // ...
} else {
    if (y > 0) {
        // ...
    }
}
```

> #### **💬 Відповідь:**
>
> Внутрішній блок `if` виконується, коли перша умова (`x > 0`) **хибна**, а друга (`y > 0`) — **істинна**.
>
> Це можна виразити як: **`НЕ (x > 0) І (y > 0)`**.
>
> Або, спростивши `НЕ (x > 0)` до `x <= 0`:
> **`(x <= 0) && (y > 0)`**.
>
> **Переписаний код:**
>
> ```java
> if ((x <= 0) && (y > 0)) {
>     // ...
> }
> ```
>
> Використання дужок тут не є строго обов'язковим через пріоритет операторів, але воно покращує читабельність.

#### **📌 Що перевіряють:**

*Навички логічної декомпозиції та рефакторингу вкладених умов у єдиний логічний вираз.*

* * *

### **7 ❓ Питання:**

Як дужки впливають на коротке замикання (short-circuiting)? ⭐️

> #### **💬 Відповідь:**
>
> Дужки **змінюють порядок обчислення** і, як наслідок, можуть змінити, яка частина виразу буде "замкнена".
>
> **Приклад:**
> `getFalse() && (getTrue() || getTrue())`
>
> * Без дужок для `||` (через пріоритет) було б: `(getFalse() && getTrue()) || getTrue()` → `false || getTrue()` → викликаються 2 методи.
> * З дужками:
>     1. Спочатку обчислюється `getFalse()`. Він повертає `false`.
>     2. Оператор `&&` бачить, що перший операнд `false`.
>     3. Завдяки короткому замиканню, **вся права частина `(getTrue() || getTrue())` не обчислюється**.
>     4. Буде викликано лише один метод — `getFalse()`.
>
> Розглянемо зворотний приклад:
> `getTrue() || (getFalse() && getTrue())`
>
> 1. Спочатку обчислюється `getTrue()`. Він повертає `true`.
> 2. Оператор `||` бачить, що перший операнд `true`.
> 3. Завдяки короткому замиканню, **вся права частина `(getFalse() && getTrue())` не обчислюється**.
> 4. Буде викликано лише один метод — `getTrue()`.
>
> Дужки групують вирази, і "замикання" застосовується до результату всього виразу в дужках як до єдиного операнда.

#### **📌 Що перевіряють:**

*Глибоке розуміння того, як порядок обчислення, керований дужками, взаємодіє з механізмом short-circuiting.*

* * *

### **8 ❓ Питання:**

Що виведе цей код? Поясніть свою відповідь, зважаючи на пріоритет і дужки.
`System.out.println(! (false || true) && (true || false) );` ⭐️

> #### **💬 Відповідь:**
>
> Цей код виведе **`false`**.
>
> **Порядок обчислення:**
>
> Дужки мають найвищий пріоритет, тому спочатку обчислюються вирази всередині них.
>
> `! (false || true) && (true || false)`
>
> **Крок 1: Обчислення перших дужок `(false || true)`:**
>
> * `false || true` → `true`.
> * Вираз стає: `! (true) && (true || false)`
>
> **Крок 2: Обчислення других дужок `(true || false)`:**
>
> * `true || false` → `true`.
> * Вираз стає: `! (true) && (true)`
>
> **Крок 3: Обчислення оператора `!` (NOT):**
>
> * `!true` → `false`.
> * Вираз стає: `false && true`
>
> **Крок 4: Обчислення оператора `&&` (AND):**
>
> * `false && true` → `false`.
>
> Таким чином, фінальний результат — `false`.

#### **📌 Що перевіряють:**

*Здатність методично, крок за кроком, розібрати складний вираз, застосовуючи правила пріоритету та групування.*

* * *

### **9 ❓ Питання:**

Яким чином закони де Моргана можуть бути використані для рефакторингу коду з дужками? Наведіть приклад. ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Закони де Моргана** дозволяють перетворювати заперечені логічні вирази, що може значно покращити їх читабельність, "виносячи" заперечення всередину.
>
> **Основні правила:**
>
> 1. `! (A && B)` еквівалентно `!A || !B`
> 2. `! (A || B)` еквівалентно `!A && !B`
>
> **Приклад рефакторингу:**
>
> Припустимо, у нас є складна умова, яку важко читати:
>
> ```java
> if (! (user != null && user.isActive())) {
>     // ... кинути виняток або показати помилку ...
> }
> ```
>
> Логіка "НЕ (і А, і B)" є менш інтуїтивною для людини.
>
> Застосуємо закон де Моргана `! (A && B)` → `!A || !B`:
>
> * `A`: `user != null` → `!A`: `user == null`
> * `B`: `user.isActive()` → `!B`: `!user.isActive()`
>
> **Відрефакторений код:**
>
> ```java
> if (user == null || !user.isActive()) {
>     // ... кинути виняток або показати помилку ...
> }
> ```
>
> Цей варіант значно чистіший і простіший для розуміння: "Якщо користувач не існує АБО він неактивний...". Застосування дужок при рефакторингу може знадобитися, якщо цей вираз є частиною ще більшого.
>
> Дужки та закони де Моргана разом дозволяють перетворювати логічні вирази в їх найбільш читабельну форму.

#### **📌 Що перевіряють:**

*Знання інструментів логічної еквівалентності та здатність застосовувати їх для покращення якості коду (рефакторингу).*

* * *

### **10 ❓ Питання:**

Що краще з точки зору читабельності: вкладені `if` чи один складний `if` з дужками? ⭐️

> #### **💬 Відповідь:**
>
> Немає єдиної правильної відповіді; вибір залежить від **контексту та складності** умов.
>
> **Коли краще один складний `if`:**
>
> * Якщо умови логічно пов'язані та перевіряють один аспект. Це дозволяє уникнути "піраміди смерті" (pyramid of doom) з багатьох вкладених блоків.
>
>     **Добре:** `if ((user != null) && user.isLoggedIn() && user.hasPermission("READ_REPORT"))`
>
>     **Гірше:**
>
>     ```java
>     if (user != null) {
>         if (user.isLoggedIn()) {
>             if (user.hasPermission("READ_REPORT")) { ... }
>         }
>     }
>     ```
>
> **Коли краще вкладені `if`:**
>
> * Якщо кожна умова має різну логіку обробки помилок або різні побічні ефекти.
>
>     **Добре:**
>
>     ```java
>     if (file != null) {
>         if (file.exists()) {
>             // обробити існуючий файл
>         } else {
>             log.error("Файл не знайдено: " + file.getName());
>         }
>     } else {
>         throw new IllegalArgumentException("Файл не може бути null");
>     }
>     ```> В цьому випадку злити все в один `if` було б неможливо або дуже складно.
>
> * Якщо умови є надзвичайно довгими, розбиття їх на вкладені `if` або винесення в окремі методи-предикати може покращити читабельність.
>
> **Висновок:** Використовуйте один `if` для лаконічних пов'язаних перевірок. Використовуйте вкладені `if` або виділяйте методи, коли логіка стає складною, або коли для різних гілок потрібна різна обробка.

#### **📌 Що перевіряють:**

*Здатність приймати обґрунтовані рішення щодо стилю коду. Розуміння, що "найкращого" рішення не існує, є вибір для конкретної ситуації.*

* * *

### **11 ❓ Питання:**

Розставте дужки у цьому виразі так, як їх розставить компілятор згідно з пріоритетом.
`a > b && b > c || c > d && d > a` ⭐️

> #### **💬 Відповідь:**
>
> Компілятор буде керуватися пріоритетами операторів.
>
> 1. Спочатку виконуються оператори порівняння (`>`, `<`, `>=` тощо). Вони мають вищий пріоритет, ніж логічні.
> 2. Потім виконується `&&` (має вищий пріоритет, ніж `||`).
> 3. В останню чергу виконується `||`.
>
> Отже, вираз:
> `a > b && b > c || c > d && d > a`
>
> Буде згруповано компілятором так:
> **`((a > b) && (b > c)) || ((c > d) && (d > a))`**
>
> 1. Спочатку обчислюється `(a > b) && (b > c)`. Це перевірка, чи `b` лежить між `c` і `a`.
> 2. Потім обчислюється `(c > d) && (d > a)`. Це перевірка, чи `d` лежить між `a` і `c`.
> 3. Результати цих двох блоків об'єднуються через `||`.

#### **📌 Що перевіряють:**

*Знання пріоритетів не тільки логічних операторів, але і операторів порівняння, та вміння застосувати їх до всього виразу.*

* * *

### **12 ❓ Питання:**

Що виведе цей код і чому?
`boolean b = true; System.out.println(b = false || b);` ⭐️⭐️

> #### **💬 Відповідь:**
>
> Цей код виведе **`true`**.
>
> Це питання з підступом, що перевіряє розуміння пріоритету оператора присвоєння `=`.
>
> **Пріоритет операторів:**
> Оператор **`||` має вищий пріоритет**, ніж оператор присвоєння **`=`**.
>
> **Порядок обчислення:**
>
> `b = false || b`
>
> 1. **Спочатку обчислюється права частина виразу:** `false || b`.
> 2. На момент обчислення цієї частини, змінна `b` все ще має своє початкове значення — **`true`**.
> 3. Обчислюється `false || true`, що дає результат **`true`**.
> 4. Тепер цей результат (`true`) **присвоюється** змінній `b`.
> 5. Нарешті, значення змінної `b` (яке тепер `true`) передається в `System.out.println()`.
>
> Тому виводиться `true`.
>
> **Якби були дужки `(b = false) || b`:**
>
> 1. Спочатку `b` присвоюється `false`. Вираз `(b = false)` повертає `false`.
> 2. Тепер обчислюється `false || b`. Змінна `b` вже має значення `false`.
> 3. `false || false` → `false`.
> 4. Вивід був би `false`.

#### **📌 Що перевіряють:**

*Знання пріоритету оператора присвоєння, що є нижчим за більшість інших операторів. Це дуже поширена помилка.*

* * *

### **13 ❓ Питання:**

Уявіть, що ви хочете перевірити, чи рядок не є `null` і не є порожнім. Чому цей код може бути неефективним, хоча і правильним? Як його покращити?
`if (!s.isEmpty() && s != null)` ⭐️⭐️

> #### **💬 Відповідь:**
>
> Цей код є логічно правильним, але **небезпечним та неефективним**.
>
> **Чому він небезпечний:**
>
> * Оператор `&&` обчислюється зліва направо.
> * Першим буде обчислено `!s.isEmpty()`.
> * Якщо змінна `s` дорівнює **`null`**, спроба викликати на ній метод `.isEmpty()` призведе до **`NullPointerException`**.
> * Друга перевірка, `s != null`, яка могла б цьому запобігти, стоїть занадто пізно.
>
> **Чому він може бути неефективним:**
>
> * Перевірка `s != null` — це дуже швидка операція (порівняння посилання).
> * Виклик методу `s.isEmpty()` (хоча й швидкий) є повільнішим, ніж перевірка на `null`.
>
> **Як його покращити (правильний порядок):**
>
> Потрібно **завжди** спочатку ставити перевірку на `null`, щоб "захистити" наступні виклики методів за допомогою короткого замикання.
>
> ```java
> if (s != null && !s.isEmpty()) {
>     // Код безпечний та ефективний
> }
> ```
>
> Тепер, якщо `s` є `null`, перша частина `s != null` поверне `false`, і друга частина `!s.isEmpty()` **ніколи не буде викликана**.

#### **📌 Що перевіряють:**

*Розуміння, що порядок операндів у `&&` та `||` має значення. Здатність писати безпечний код, розташовуючи "захисні" перевірки на першому місці.*

* * *

### **14 ❓ Питання:**

Як можна використовувати комбінування умов для імплементації "захисного програмування" (Defensive Programming)? ⭐️⭐️

> #### **💬 Відповідь:**
>
> "Захисне програмування" — це підхід, при якому код пишеться так, щоб передбачати і коректно обробляти невалідні вхідні дані або несподівані стани. Логічні оператори, особливо `&&` з його short-circuiting, є ключовим інструментом для цього.
>
> **Патерн "Guard Clause" або "Захисне твердження":**
>
> Ідея полягає в тому, щоб на самому початку методу поставити серію перевірок на невалідні умови і негайно вийти з методу, якщо вони спрацювали.
>
> **Приклад:**
>
> Припустимо, потрібно обробити замовлення.
>
> ```java
> public void processOrder(Order order, User user) {
>     // Guard Clauses
>     if (order == null || order.getItems().isEmpty()) {
>         log.error("Замовлення невадідне.");
>         return;
>     }
>
>     if (user == null || !user.isVerified()) {
>         throw new SecurityException("Користувач не авторизований або не верифікований.");
>     }
>
>     // ... Основна логіка методу, яка тепер гарантовано
>     // працює з валідними 'order' та 'user'
>     // ...
> }
> ```
>
> Тут ми використовуємо `||`, щоб об'єднати перевірки на "погані" стани. Якщо `order` є `null`, друга частина (`order.getItems().isEmpty()`) не виконається.
>
> Цей підхід:
>
> * **Зменшує вкладеність:** Основна логіка не обгортається у великий `if`.
> * **Робить код чистішим:** Умови для помилок обробляються на початку, і далі йде "щасливий шлях" (happy path).
> * **Підвищує надійність:** Гарантує, що основна бізнес-логіка не отримає невалідні дані.

#### **📌 Що перевіряють:**

*Знання патернів проектування для написання чистого та надійного коду. Розуміння того, як мовні конструкції використовуються для реалізації цих патернів.*

* * *

### **15 ❓ Питання:**

Розставте дужки у цьому виразі, щоб він повернув `true`. Поясніть чому.
`false && false || true`
`false && (false || true)` ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Давайте проаналізуємо обидва випадки.
>
> **Випадок 1: `false && false || true`**
>
> * Без дужок, `&&` має вищий пріоритет.
> * `false && false` → `false`
> * `false || true` → `true`
> * **Результат: `true`**. Отже, дужки не потрібні, щоб отримати `true`.
>
> **Випадок 2: `false && (false || true)`**
>
> * Спочатку обчислюється вираз у дужках.
> * `false || true` → `true`.
> * Вираз стає `false && true`.
> * `false && true` → `false`.
> * **Результат: `false`**.
>
> **Відповідь на питання "як розставити дужки, щоб отримати `true`":**
>
> В даному випадку, для отримання `true`, **дужки розставляти не потрібно**, оскільки стандартний пріоритет операторів уже дає цей результат.
>
> Однак, якщо ми хочемо **явно показати** порядок, який призводить до `true`, ми можемо згрупувати `&&`:
> `(false && false) || true`
>
> Це питання з підступом. Воно змушує думати, що дужки обов'язково щось змінять, але в цьому конкретному випадку вони не потрібні для досягнення бажаного результату `true`.
>
> **Що це демонструє:**
>
> Іноді розстановка дужок важлива для **зміни результату** (як у попередніх прикладах), а іноді — лише для **покращення читабельності**, навіть якщо результат не змінюється. Розуміння цієї різниці є ознакою досвідченого розробника.

#### **📌 Що перевіряють:**

*Максимальну уважність. Це перевірка того, чи кандидат не діє за шаблоном ("треба розставити дужки, щоб змінити порядок"), а аналізує конкретний вираз. Уміння помітити, що для досягнення мети нічого робити не потрібно.*
