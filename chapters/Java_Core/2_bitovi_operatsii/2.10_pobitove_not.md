---
layout: default
title: "Побітове NOT (~)"
parent: "Бітові операції"
grand_parent: "Java Core"
nav_order: 10
---

# Побітове NOT (~)

* короткий опис: Унарна побітова операція, яка інвертує всі біти операнда (0 стає 1, а 1 стає 0).

* поняття: `~` (NOT), інверсія бітів.

* приклади: `~5 = -6`, `~0 = -1`, `~(-1) = 0`.

* ключові моменти: Завдяки two's complement, `~n = -(n+1)`. Працює з усіма цілочисельними типами.

* що важливо знати на співбесіді: Як працює `~` з додатніми/від'ємними числами.

### **✅ Офіційне визначення:**

Побітовий оператор NOT (**`~`**) — це унарна операція, яка інвертує **всі** біти операнда: 0 -> 1, 1 -> 0\.

У Java працює з цілими типами (**`byte`**, **`short`**, **`int`**, **`long`**), повертає число того ж типу, але з усіма бітами інверсованими.

### **🧠 Простими словами:**

**`~`** — це як магічне дзеркало для бітів: нулі перетворюються в одиниці, одиниці — в нулі. Результат — зовсім інше число, що виглядає "перевернутим" у двійковому вигляді

---

## **Інверсія бітів (📊)**

| Число | Двійковий код (byte) | \~число | Двійковий код \~числа |
| :---: | :---: | :---: | :---: |
| **5** | 00000101 | \-6 | 11111010 |
| **0** | 00000000 | \-1 | 11111111 |
| **\-1** | 11111111 | 0 | 00000000 |

---

## **Пояснення на пальцях (💡)**

**`~`** — просто перемикає всі біти з 0 на 1 і навпаки.

Але завдяки **two’s complement** результат — це не просто **`-n`**, а  
**формула:**

**`n=−(n+1)`**

---

## **Корисні приклади (🧪)**

```java
int a = 5;           // 00000000 00000000 00000000 00000101
int b = ~a;          // 11111111 11111111 11111111 11111010  (-6)

System.out.println(~5);    // -6
System.out.println(~0);    // -1
System.out.println(~(-1)); // 0
```

🧠 Пояснення:

```java
~5 = -(5 + 1) = -6
~0 = -(0 + 1) = -1
```

---

## **Порівняння (⚖️)**

| Операція | Символ | Аргументи | Що робить |
| :---: | :---: | :---: | :---: |
| **AND** | & | 2 | Обидва біти \= 1 -> 1 |
| **OR** | | | 2 | Хоч один біт \= 1 |
| **XOR** | ^ | 2 | Біти різні -> 1 |
| **NOT** | \~ | 1 | Інвертує всі біти |

---

## **🧠 Мнемоніка для запам’ятовування:**

**\~n \= \-(n \+ 1\)**

NOT — це "переверни і мінусуй 1"

---

## **🟩 Підсумок:**

**`~`** — у Java оператор, що **інвертує всі біти числа**.  
Завдяки особливостям двійкового кодування з доповненням до двох (two’s complement), результат для числа **`n`** — це `–(n + 1)`.

* **`~5 = -6`**
* **`~0 = -1`**
* **`~(-1) = 0`**

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке побітовий оператор NOT (`~`) і що він робить?

> #### **💬 Відповідь:**
>
> Побітовий оператор `NOT` (`~`), також відомий як побітове заперечення або побітова інверсія, — це **унарний** оператор, який працює з цілочисельними типами (`byte`, `short`, `int`, `long`).
>
> **Що він робить:**
> Оператор `~` "проходиться" по **двійковому представленню** числа і **інвертує кожен його біт**:
>
> * Кожен `0` стає `1`.
> * Кожен `1` стає `0`.
>
> **Приклад для 8-бітного числа:**
>
> Якщо у нас є `byte` зі значенням 5:
>
> * Двійкове представлення `5`: `00000101`
> * Результат `~5`: `11111010`
>
> Цей новий бітовий патерн `11111010` у доповняльному коді представляє десяткове число **-6**.

#### **📝 Коментар:**

Важливо розуміти, що `~n` — це не те саме, що `-n`. Це абсолютно різні операції.

#### **📌 Що перевіряють:**

*Базове розуміння операції інвертування бітів та її відмінності від арифметичного заперечення.*

* * *

### **2 ❓ Питання:**

Поясніть, чому `~n` дорівнює `-(n + 1)`. Наведіть приклад.

> #### **💬 Відповідь:**
>
> Ця формула є прямим наслідком того, як від'ємні числа представлені у **двійковому доповняльному коді (two's complement)**.
>
> Згідно з визначенням доповняльного коду, від'ємне число `-X` отримується як `~X + 1`.
> Давайте перетворимо цю формулу:
> `-X = ~X + 1`
>
> Віднімемо 1 з обох частин:
> `-X - 1 = ~X`
>
> Винесемо мінус за дужки:
> `-(X + 1) = ~X`
>
> Якщо замінити `X` на `n`, ми отримаємо нашу формулу: **`~n = -(n + 1)`**.
>
> **Приклад для `n = 5`:**
>
> * Застосовуємо формулу: `~5 = -(5 + 1) = -6`.
>
> **Приклад для `n = -6`:**
>
> * Застосовуємо формулу: `~(-6) = -(-6 + 1) = -(-5) = 5`.
>
> Ця формула є зручним правилом для швидкого обчислення результату операції `~` без необхідності виконувати бітові маніпуляції вручну.

#### **📌 Що перевіряють:**

*Математичне розуміння зв'язку між операцією `NOT` та доповняльним кодом. Кандидат повинен вміти пояснити, звідки береться ця формула.*

* * *

### **3 ❓ Питання:**

Що виведе цей код і чому?

```java
System.out.println(~0);
System.out.println(~(-1));
```

> #### **💬 Відповідь:**
>
> **Вивід буде таким:**
>
> ```
> -1
> 0
> ```
>
> **Пояснення:**
>
> **1. `~0` → `-1`**
>
> * **За формулою:** `~0 = -(0 + 1) = -1`.
> * **На рівні бітів (32-бітний `int`):**
>   * `0` → `00000000 ... 00000000`
>   * `~0` → `11111111 ... 11111111`
>   * У доповняльному коді патерн з усіх одиниць завжди представляє число `-1`.
>
> **2. `~(-1)` → `0`**
>
> * **За формулою:** `~(-1) = -(-1 + 1) = -(0) = 0`.
> * **На рівні бітів:**
>   * `-1` → `11111111 ... 11111111`
>   * `~(-1)` → `00000000 ... 00000000`
>   * Цей бітовий патерн представляє число `0`.
>
> Ці два приклади є гарною ілюстрацією того, як `NOT` "переводить" між нулем і мінус одиницею.

#### **📌 Що перевіряють:**

*Розуміння роботи оператора `NOT` з граничними та особливими значеннями.*

* * *

### **4 ❓ Питання:**

Яким буде результат `~` для типу `byte`? Якого типу буде результат?
`byte b = 10; byte result = ~b;`

> #### **💬 Відповідь:**
>
> Рядок `byte result = ~b;` **не скомпілюється**. Компілятор видасть помилку `incompatible types: possible lossy conversion from int to byte`.
>
> **Пояснення:**
>
> Це пов'язано з правилом **розширення типів при побітових операціях (Bitwise Numeric Promotion)** у Java.
>
> 1. Коли побітова операція (включно з `~`) застосовується до операнда типу `byte`, `short` або `char`, цей операнд **автоматично розширюється (promotes) до типу `int`** перед виконанням операції.
> 2. Отже, спочатку `byte b` (значення `10`) перетворюється на `int` (`10`).
> 3. Потім операція `~` застосовується вже до цього `int`-значення. `~10` дає `int` `-11`.
> 4. Результат операції `~b` має тип **`int`**.
> 5. Спроба присвоїти `int`-результат змінній типу `byte` є звужуючим перетворенням, яке компілятор забороняє без явного приведення.
>
> **Правильний запис:**
>
> ```java
> byte b = 10;
> byte result = (byte) ~b; // result буде -11
> ```

#### **📌 Що перевіряють:**

*Знання правил Numeric Promotion, які стосуються не тільки арифметичних, але й побітових операцій. Це неочевидний, але важливий аспект мови.*

* * *

### **5 ❓ Питання:**

Як за допомогою оператора `NOT` можна скинути (зробити нульовим) конкретний біт у числі? Наведіть приклад.

> #### **💬 Відповідь:**
>
> Щоб скинути `i`-й біт числа `n`, потрібно виконати операцію **`AND` (`&`)** з **інвертованою маскою**. Оператор `NOT` (`~`) ідеально підходить для створення такої маски.
>
> **Алгоритм:**
>
> 1. Створіть маску, де встановлено лише `i`-й біт. Це робиться за допомогою зсуву: `1 << i`.
> 2. **Інвертуйте** цю маску за допомогою оператора `~`. Тепер ви отримаєте маску, де `i`-й біт дорівнює `0`, а всі інші — `1`.
> 3. Застосуйте операцію `AND` між початковим числом та інвертованою маскою.
>
> **Приклад: скинути 3-й біт у числі 13 (`1101`):**
>
> * **Початкове число:** `n = 13` (`...1101`)
>
> 1. **Маска для 3-го біта:** `int mask = 1 << 3;` (тобто `8`, двійкове `...1000`)
> 2. **Інвертована маска:** `~mask` → `~...1000` → `...0111`
>
> 3. **Операція `AND`:**
>
>     ```
>       ...1101  (13)
>     & ...0111  (~8)
>     ----------
>       ...0101  (5)
>     ```>
>
> **Код:**
> `int result = 13 & ~(1 << 3); // result буде 5`
>
> Операція `AND` з `0` на `i`-й позиції гарантовано "обнуляє" цей біт, а `AND` з `1` на всіх інших позиціях залишає їх недоторканими.

#### **📌 Що перевіряють:**

*Практичне застосування `NOT` у поєднанні з іншими побітовими операторами для реалізації стандартних завдань маскування.*

* * *

### **6 ❓ Питання:**

Що робить цей вираз і для чого він може використовуватися?
`if (~list.indexOf(element)) { ... }` (припускаючи, що `list` — це `ArrayList`) ⭐️

> #### **💬 Відповідь:**
>
> Цей код є **поганою практикою і, скоріше за все, є помилкою**. Це трюк, запозичений з C/C++, який **не працює в Java** так, як можна було б очікувати.
>
> **Що хотів сказати автор (ймовірно):**
>
> * Метод `list.indexOf(element)` повертає **-1**, якщо елемент не знайдено, і індекс >= 0, якщо знайдено.
> * У мовах типу C, де `0` інтерпретується як `false`, а будь-яке інше число як `true`, цей трюк працює. `~(-1)` дає `0` (`false`), а `~` для будь-якого додатного числа дає від'ємне число (`true`). Таким чином, `if (~list.indexOf(element))` перевіряло б, чи знайдено елемент.
>
> **Чому це не працює в Java:**
>
> 1. Умова в `if` в Java **очікує значення типу `boolean`**, а не `int`.
> 2. Операція `~list.indexOf(element)` повертає **`int`**.
> 3. Спроба використати `int` в `if` призведе до **помилки компіляції**: `incompatible types: int cannot be converted to boolean`.
>
> **Правильний спосіб перевірки в Java:**
>
> ```java
> if (list.indexOf(element) != -1) {
>     // Елемент знайдено
> }
> // або
> if (list.contains(element)) {
>     // Ще краще і читабельніше
> }
> ```
>
> Використання `~` у цьому контексті є антипатерном, який свідчить про нерозуміння відмінностей між мовами.

#### **📌 Що перевіряють:**

*Знання правил мови Java, зокрема вимоги до типів в умовних операторах. Здатність розпізнати поширені помилки, запозичені з інших мов.*

* * *

### **7 ❓ Питання:**

Як `NOT` взаємодіє з `XOR`? Яка є відома ідентичність? ⭐️

> #### **💬 Відповідь:**
>
> Існує важлива ідентичність, яка пов'язує ці два оператори:
>
> **`A ^ B` є еквівалентом `(A & ~B) | (~A & B)`**
>
> Давайте перевіримо:
> `XOR` повертає `1` тільки коли біти різні (`1` і `0` або `0` і `1`).
>
> Розглянемо праву частину:
>
> * `A & ~B`: буде `1`, тільки якщо `A=1` і `B=0` (бо `~B=1`).
> * `~A & B`: буде `1`, тільки якщо `A=0` і `B=1` (бо `~A=1`).
> * Операція `|` об'єднує ці дві умови. Результат буде `1`, якщо виконується або перша, або друга умова, що точно відповідає визначенню `XOR`.
>
> Інша корисна ідентичність:
>
> **`A ^ -1` є еквівалентом `~A`**
>
> Оскільки `-1` у доповняльному коді — це патерн з усіх одиниць, `XOR` з усіма одиницями інвертує кожен біт числа, що є визначенням операції `NOT`.

#### **📌 Що перевіряють:**

*Глибокі знання властивостей побітових операцій та їхніх взаємозв'язків. Це свідчить про хорошу математичну підготовку.*

* * *

### **8 ❓ Питання:**

Чому `Integer.toBinaryString(~5)` не виводить 32 біти? Яким буде результат і чому? ⭐️

> #### **💬 Відповідь:**
>
> Результатом буде `11111111111111111111111111111010`.
>
> **Чому результат саме такий:**
>
> 1. Спочатку обчислюється `~5`. `5` у двійковому `int` — це `...00000101`.
> 2. `~5` інвертує всі біти, і ми отримуємо `111...11111010`. Це бітове представлення числа **-6**.
>
> 3. Потім цей результат (`-6`) передається в метод **`Integer.toBinaryString(int i)`**.
>
> **Поведінка `Integer.toBinaryString()`:**
>
> * Для **додатних** чисел метод **не виводить ведучі нулі**. `toBinaryString(5)` поверне `"101"`, а не `"00...0101"`.
> * Для **від'ємних** чисел метод повертає їхнє **32-бітне представлення** у доповняльному коді. Він не "скорочує" його.
>
> Отже, оскільки `~5` дає від'ємне число `-6`, метод `toBinaryString` повертає його повне 32-бітне представлення.
>
> **Якби ми робили `toBinaryString(5)`:**
> Результат був би просто `"101"`.
>
> **Якби ми робили `toBinaryString(~(-6))`:**
> Результат був би `"101"`, оскільки `~(-6)` дає `5`.

#### **📌 Що перевіряють:**

*Знання роботи стандартних бібліотечних методів, зокрема їхньої поведінки для від'ємних чисел.*

* * *

### **9 ❓ Питання:**

Що таке маска підмережі (subnet mask) у мережевому програмуванні, і як операція `AND` використовується для визначення адреси мережі? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Маска підмережі** — це 32-бітне число, яке використовується в TCP/IP мережах для розділення IP-адреси на дві частини: **адресу мережі** та **адресу вузла (хоста)**.
>
> Маска складається з послідовності одиниць, за якими йде послідовність нулів. Одиниці вказують на частину IP-адреси, що відповідає за мережу, а нулі — на частину, що відповідає за хост.
>
> **Приклад:**
>
> * IP-адреса: `192.168.1.10`
> * Маска підмережі: `255.255.255.0`
>
> **Як використовується `AND`:**
>
> Щоб визначити адресу мережі, до якої належить IP-адреса, потрібно виконати **побітову операцію `AND`** між IP-адресою та маскою підмережі.
>
> 1. Переведемо їх у двійкову форму:
>     `192.168.1.10` → `11000000.10101000.00000001.00001010`
>     `255.255.255.0` → `11111111.11111111.11111111.00000000`
>
> 2. Застосовуємо `AND`:
>
>     ```
>       11000000.10101000.00000001.00001010
>     & 11111111.11111111.11111111.00000000
>     ---------------------------------------
>       11000000.10101000.00000001.00000000
>     ```>
> 3. Результат у десятковому вигляді: `192.168.1.0`. Це і є **адреса мережі**.
>
> Операція `AND` з маскою ефективно "обнуляє" частину IP-адреси, що відповідає за хост, залишаючи лише мережеву частину. Оператор `NOT` може бути використаний для отримання "wildcard mask" з маски підмережі.

#### **📌 Що перевіряють:**

*Практичне застосування побітових операцій у реальних технологіях, таких як мережеві протоколи.*

* * *

### **10 ❓ Питання:**

Поясніть, що станеться, якщо застосувати `~` до `long` числа. ⭐️

> #### **💬 Відповідь:**
>
> Оператор `~` працює для `long` абсолютно аналогічно до `int`, але на **64 бітах** замість 32.
>
> 1. Всі 64 біти `long` числа будуть інвертовані.
> 2. Формула `~n = -(n + 1)` залишається справедливою.
>
> **Приклад:**
>
> ```java
> long l = 100L;
> // Його 64-бітне представлення: 0...01100100
>
> long not_l = ~l;
> // Представлення not_l: 1...10011011
>
> System.out.println(not_l); // Виведе -101
> ```> **Важливий нюанс при розширенні типів:**
>
> Якщо ви застосовуєте `~` до `int` і присвоюєте результат `long`, спочатку виконається інверсія 32 біт, а потім результат розшириться до `long` зі збереженням знака.
>
> ```java
> int i = 5;      // ~i = -6 (у 32 бітах)
> long l = ~i; // l буде -6 (у 64 бітах)
>
> // Цей код дасть інший результат:
> long l2 = ~ (long)i; // l2 буде також -6,
> // але інверсія буде застосована до 64-бітного представлення 5.
> ```> У цьому простому випадку результати збігаються. Але для граничних значень поведінка може відрізнятися, якщо не бути уважним до того, коли відбувається розширення — до чи після операції.

#### **📌 Що перевіряють:**

*Розуміння того, що побітові операції універсальні для всіх цілочисельних типів, та уважність до правил numeric promotion.*

* * *

### **11 ❓ Питання:**

Як за допомогою оператора `NOT` та `XOR` можна інвертувати лише певні біти, а інші залишити без змін? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Для цього ідеально підходить оператор **`XOR` (`^`)**, використовуючи маску. Оператор `NOT` (`~`) інвертує *всі* біти, а `XOR` дозволяє інвертувати *вибірково*.
>
> **Властивість `XOR`, що використовується:**
>
> * `A ^ 0 = A` (XOR з 0 не змінює біт)
> * `A ^ 1 = ~A` (XOR з 1 інвертує біт)
>
> **Алгоритм:**
>
> 1. Створіть **маску**, в якій біти, що потрібно інвертувати, дорівнюють `1`, а ті, що потрібно залишити без змін, — `0`.
> 2. Застосуйте операцію `XOR` між початковим числом та маскою.
>
> **Приклад: Інвертувати 4 молодших біти у числі `n`, а старші залишити без змін.**
>
> * **Число:** `n = 42` (двійкове `...00101010`)
> * **Маска:** нам потрібні `1` на 4 молодших позиціях → `...00001111` (десяткове 15, або `0xF`).
> * **Операція:** `n ^= 0xF;`
>
>     ```
>       ...00101010 (42)
>     ^ ...00001111 (15)
>     ----------------
>       ...00100101 (37)
>     ```
>
> * Старші 4 біти (`0010`) XOR-ились з `0` і залишились `0010`.
> * Молодші 4 біти (`1010`) XOR-ились з `1` (`1111`) і стали `0101`.
>
> Цей підхід часто використовується, наприклад, в комп'ютерній графіці для маніпуляції кольорами.

#### **📌 Що перевіряють:**

*Глибоке розуміння властивостей `XOR` та здатність застосовувати його для більш складних завдань, ніж проста перевірка на нерівність.*

* * *

### **12 ❓ Питання:**

Яким буде результат `~~n`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Результатом буде **`n`**. Подвійне застосування побітового `NOT` повертає початкове число.
>
> **Пояснення:**
>
> 1. Перший оператор `~` інвертує всі біти числа `n`. Кожен `0` стає `1`, кожен `1` стає `0`.
> 2. Другий оператор `~` застосовується до результату і знову інвертує всі біти, повертаючи їх до початкового стану.
>
> Отже, `~(~n) = n`.
>
> **Математичне обґрунтування за формулою `~x = -(x + 1)`:**
>
> `~~n = ~( -(n + 1) )`
>
> Нехай `m = -(n + 1)`. Тоді `~~n = ~m`.
>
> `~m = -(m + 1)`.
>
> Підставимо `m` назад:
> `~m = -( (-(n+1)) + 1 ) = -( -n - 1 + 1 ) = -( -n ) = n`.
>
> Хоча ця операція не має практичного сенсу, вона є хорошою демонстрацією оборотності операції `NOT`.

#### **📌 Що перевіряють:**

*Кмітливість та здатність мислити логічно або математично для доведення властивостей операторів.*

* * *

### **13 ❓ Питання:**

Що виведе цей код і чому? `System.out.println((byte)~0);` ⭐️⭐️

> #### **💬 Відповідь:**
>
> Цей код виведе **`-1`**.
>
> **Пояснення крок за кроком:**
>
> 1. **Обчислення `~0`:**
>     * Літерал `0` за замовчуванням має тип `int` (32 біти).
>     * Його двійкове представлення: `00000000 00000000 00000000 00000000`.
>     * Операція `~` інвертує всі 32 біти, і ми отримуємо:
>     `11111111 11111111 11111111 11111111`.
>     * Цей патерн у доповняльному коді представляє `int` зі значенням `-1`.
>
> 2. **Приведення до `byte` (`(byte)-1`):**
>     * Тепер `int` `-1` потрібно привести до 8-бітного `byte`.
>     * Це **звужуюче примітивне перетворення**. Java відкидає старші 24 біти і залишає лише молодші 8.
>     * Оскільки всі 32 біти були `1`, молодші 8 біт також будуть `11111111`.
>
> 3. **Інтерпретація результату:**
>     * Бітовий патерн `11111111` в 8-бітному `byte` у доповняльному коді представляє число **`-1`**.
>
> Таким чином, `(byte)~0` дорівнює `(byte)-1`, що просто дорівнює `-1`.

#### **📌 Що перевіряють:**

*Уміння аналізувати складні вирази, що включають numeric promotion, побітові операції та явне приведення типів. Це комбіноване питання.*

* * *

### **14 ❓ Питання:**

Чому цей код скомпілюється і що він робить? `int i = ~-1 >>> 1;` ⭐️⭐️

> #### **💬 Відповідь:**
>
> Цей код скомпілюється і присвоїть змінній `i` значення **`Integer.MAX_VALUE`**, тобто `2147483647`.
>
> **Розберемо вираз:** `~-1 >>> 1`
>
> Оператор `~` має вищий пріоритет, ніж `>>>`.
>
> 1. **Обчислюємо `~-1`:**
>     * `int -1` у доповняльному коді: `111...111` (32 одиниці).
>     * `~(-1)` інвертує всі біти і дає: `000...000`, що є `int 0`.
>
> 2. **Обчислюємо `0 >>> 1`:**
>     * Беремо результат `0` (`000...000`).
>     * Виконуємо логічний (беззнаковий) зсув вправо на 1 біт.
>     * Зсув нуля дає нуль. `0 >>> 1` буде `0`.
>
> *Виправлення:* Я помилився в пріоритеті. `>>>` має вищий пріоритет, ніж `~`. Унарні оператори `+`, `-`, `~`, `!` мають однаковий пріоритет і обчислюються справа наліво. Змінимо аналіз.
>
> * * *
>
#### **Змінена відповідь на питання №14:**
>
> #### **💬 Відповідь:**
>
> Код `int i = ~-1;` присвоїв би `0`.  Але ваш вираз складніший: `~-1` насправді є двома окремими унарними операторами. Потрібно розібратися з пріоритетом. Унарні оператори мають однаковий пріоритет і виконуються справа наліво.

Вибачте, виправлю свою логіку.  Питання `~-1 >>> 1;`. Побітовий зсув `>>>` має вищий пріоритет, ніж унарний `~`. Давайте розглянемо вираз, як `~(-1 >>> 1)`.
>
> **Вираз:** `~(-1 >>> 1)`
>
> 1. **Обчислюємо `-1 >>> 1`:**
>     * `-1` у 32-бітному `int`: `11111111 11111111 11111111 11111111`.
>     * Виконуємо **логічний (беззнаковий)** зсув вправо на 1 біт. Біти зсуваються, а зліва додається **0**.
>     * Результат: `01111111 11111111 11111111 11111111`.
>
> 2. **Що це за число?**
>     * Цей бітовий патерн (0 і за ним 31 одиниця) є точно двійковим представленням **`Integer.MAX_VALUE`**.
>
> 3. **Застосовуємо `~` до результату:**
>     * `~(Integer.MAX_VALUE)` → `~(0111...111)`
>     * Результат інверсії: `1000...000`.
>     * Цей патерн є двійковим представленням **`Integer.MIN_VALUE`**.
>
> Таким чином, фінальне значення, яке буде присвоєно `i`, — це **`Integer.MIN_VALUE` (`-2147483648`)**.

#### **📌 Що перевіряють:**

*Експертне знання пріоритету операторів, уміння працювати з декількома побітовими операціями у одному виразі та розуміння бітових патернів для граничних значень `int`.*

* * *
Вибачте, здається, я заплутався в пріоритетах. Пріоритет `~` (унарний) вищий, ніж у `>>>` (зсув). Отже, вираз `~-1 >>> 1` обчислюється як `(~(-1)) >>> 1`.

#### **Змінена відповідь на питання №14 (остаточна):**
>
> #### **💬 Відповідь:**
>
> Код скомпілюється. Давайте розберемо його, враховуючи правильний пріоритет операторів. Унарний `~` має вищий пріоритет, ніж оператор зсуву `>>>`. Отже, вираз обчислюється як **`(~(-1)) >>> 1`**.
>
> 1. **Обчислюємо `~(-1)`:**
>     * Значення `-1` типу `int` у двійковому доповняльному коді — це патерн з 32 одиниць: `1111...1111`.
>     * Оператор `~` інвертує всі ці біти.
>     * Результат: `0000...0000`, що є числом `0`.
>
> 2. **Обчислюємо `0 >>> 1`:**
>     * Беремо результат попереднього кроку, тобто `0`.
>     * Виконуємо логічний (беззнаковий) зсув вправо на 1 біт.
>     * Зсув нуля на будь-яку кількість позицій завжди дає нуль.
>
> Отже, фінальне значення, яке буде присвоєно змінній `i`, — це **`0`**.

* * *

### **15 ❓ Питання:**

Чому не існує побітового оператора `NOT` з присвоєнням (наприклад, `~=`)? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Це дуже тонке питання, що стосується дизайну мови Java. На відміну від бінарних операторів (`&=`, `|=`, `^=`), для унарного `~` немає відповідного оператора з присвоєнням.
>
> **Головна причина — відсутність потреби та потенційна плутанина.**
>
> Оператори з присвоєнням, як `a += b`, є скороченням для `a = a + b`. Вони зручні, коли один і той самий операнд (`a`) бере участь і як джерело, і як приймач результату.
>
> Розглянемо `~`. Якби існував `a ~=`, що б він означав?
> За аналогією, це було б `a = a ~` ... а що далі? Оператор `~` — **унарний**, він не приймає другого операнда.
>
> Його можна було б визначити як `a = ~a;`. Але це виглядає досить рідкісною операцією, щоб вводити для неї окремий синтаксис.
>
> **До того ж, це може створити синтаксичну неоднозначність.** Наприклад, розглянемо вираз `a ~= b`. Це слід було б читати як `a = ~a = b`? Чи `a = a ~ b`? У Java немає оператора `~` з двома операндами.
>
> Творці мови, ймовірно, вирішили, що користь від такого оператора є мінімальною, а потенційна плутанина та ускладнення граматики мови — значними. Запис `a = ~a;` є достатньо коротким і зрозумілим.

#### **📌 Що перевіряють:**

*Дуже глибоке, майже філософське розуміння дизайну мови програмування. Кандидат повинен вміти міркувати про причини, чому певні конструкції існують, а інші — ні.*
