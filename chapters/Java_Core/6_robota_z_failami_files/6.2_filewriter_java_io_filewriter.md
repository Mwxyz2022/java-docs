---
layout: default
title: "FileWriter (java.io.FileWriter)"
parent: "Робота з файлами (Files)"
grand_parent: "Java Core"
nav_order: 2
---

# FileWriter (java.io.FileWriter)

* короткий опис: `FileWriter` – це клас для запису символів (тексту) у файл. За замовчуванням перезаписує вміст файлу, але може працювати в режимі дозапису (append) за допомогою додаткового параметра `true`.

* поняття: `FileWriter`, запис символів, кодування, `write()`, `close()`, `flush()`, `append`.

* приклади: `new FileWriter("hello.txt");` (перезапис), `new FileWriter("log.txt", true);` (дозапис).

* ключові моменти: Працює з символами, обов'язково викликати `close()` або `flush()` для збереження даних. Не є високоефективним для великих обсягів (потребує `BufferedWriter`).

* що важливо знати на співбесіді: Як записати текст, `append` режим, важливість закриття потоку.

### **✅ Офіційне визначення:**

**`FileWriter`** — це клас із пакету **`java.io`**, який дозволяє записувати **символи** у файл. Він є зручним для простого запису тексту у файл, працює з кодуванням за замовчуванням (зазвичай UTF-8 або системне).

### **🧠 Простими словами:**

Це як ручка 🖊 — ти відкриваєш файл і записуєш у нього текст (рядки, символи). Але якщо не вказати явно, кожен новий запис перезапише старий вміст.

---

## **📊 Основні способи використання**

| Тип операції | Приклад | Пояснення |
| :---: | :---: | :---: |
| **Створити новий файл** | **`new FileWriter("file.txt")`** | Якщо не існує — створюється |
| **Перезапис** | **`new FileWriter("file.txt")`** | Видаляє старий вміст |
| **Дозапис (append)** | **`new FileWriter("file.txt",true)`** | Додає до кінця файлу |
| **Закриття** | **`writer.close()`** | Закриває ресурс (обов’язково\!) |
| **Примусово записати з буфера** | **`writer.flush()`** | Якщо хочеш записати не чекаючи закриття |

---

## **Пояснення на пальцях (💡)**

### **Для чого це?**

* Щоб **зберегти лог**, текстовий звіт, дані користувача, конфіг тощо
* Записати вміст змінної у `.txt` файл
* Створити файл і записати у нього повідомлення

### **У чому особливість?**

* Працює **з символами** (**`char`, `String`**)
* Не ефективний для великих обсягів — краще обгортати в **`BufferedWriter`**
* Не використовує кодування напряму — якщо треба явно UTF-8 -> краще **`OutputStreamWriter`**

### **Типові граблі:**

* Забути **`close()`** -> нічого не запишеться
* Не вказати **`true`** у другому параметрі -> файл буде **перезаписано**
* Працює повільніше за буферизовані альтернативи

---

## **Корисні приклади (🧪)**

### **🔹 Простий запис у файл:**

```java
FileWriter writer = new FileWriter("hello.txt");
writer.write("Привіт, світ!");
writer.close();
```

### **🔹 Дозапис у файл:**

```java
FileWriter writer = new FileWriter("hello.txt", true);
writer.write("\nЩе один рядок");
writer.close();
```

### **🔹 Запис з flush:**

```java
FileWriter writer = new FileWriter("log.txt");
writer.write("Це лог");
writer.flush(); // записує одразу
writer.close();
```

---

## **Порівняння (⚖️)**

| Клас | Тип даних | Буферизація | Коли краще |
| :---: | :---: | :---: | :---: |
| **FileWriter** | Символи (char, String) | ❌ Ні | Малий обсяг, простий текст |
| **BufferedWriter** | Символи \+ буфер | ✅ Так | Великі обсяги, швидкість |
| **PrintWriter** | Форматований вивід | ✅ Так | Якщо треба **`println()`, `printf()`** |

---

## **❓❓ Питання:**

Якщо FileWriter не має буфера, то що тоді означає `flush()`?

### **✅ Відповідь:**

**`FileWriter`** **має внутрішній низькорівневий буфер**, хоча **не такий великий і ефективний, як у `BufferedWriter`**.  

Тобто:

* `FileWriter` все ж **не пише по кожному символу в файл одразу**.
* Він тримає **невеликий буфер** у пам’яті (наприклад, кілька десятків/сотень символів).
* Метод `flush()` **примушує цей буфер записатися у файл** **негайно**, а не чекати, поки він автоматично запишеться або викличеться `close()`.

---

## **💡 Пояснення простими словами:**

Уяви:

* `FileWriter` — це як писар, який **не кожне слово одразу переписує в книгу**, а **накопичує в пам'яті кілька слів**, а потім записує.
* `flush()` — це як команда: **“Запиши все, що тримаєш зараз\!”**
* `BufferedWriter` — це писар, який має **величезний блокнот** (буфер) і пише лише коли блокнот повний.

---

### **🧪 Приклад, коли `flush()` корисний:**

```java
FileWriter fw = new FileWriter("output.txt");
fw.write("Дані...");
fw.flush(); // одразу записали на диск, навіть без close()
```

Це може бути корисно:

* при **тестуванні**
* при **записі логів**
* при **частковому збереженні великих результатів**

---

### **🟥 Часто плутають:**

`FileWriter` ≠ "не буферизований взагалі"  

✔️ Він має **мінімальний буфер**  
❌ Але не має **оптимізованого буфера для великих обсягів**, як `BufferedWriter`

---

## **🔺 Висновок:**

* `flush()` у `FileWriter` — **працює**, бо у нього теж є **невеликий внутрішній буфер**
* Але якщо тобі потрібен **контроль, продуктивність, менше I/O викликів** — використовуй `BufferedWrite`

---

## **🧠 Мнемоніка для запам’ятовування**

```java
FileWriter -> write символи у файл
true -> дозапис (append)
close() -> обов'язково
flush() -> якщо треба одразу записати
```

---

## **🟩 Підсумок:**

**`FileWriter`** — це простий спосіб записати символи у файл. Його легко використовувати для невеликих задач: логування, створення текстових файлів, генерація звітів. Але для **великої кількості даних** краще застосовувати **`BufferedWriter`**. І не забудь — завжди **закривай потік**, щоб уникнути втрати даних\

---

## **9\. Приклад Коду:**

```java
public static void main(String[] args) {


   // How to write data at file ?
   String[] users = new String[]{"Bob","Alice","John"};
   String path = "myFolder" + File.separator + "myFile.txt";
   File file = new File(path);


   for(String user : users){
       try (BufferedWriter bw = new BufferedWriter(new FileWriter(file, true))) {
           try {
               // Щоб доповнювати файл ане перезатирати треба додати true у FileWriter
               bw.write(user);


           } catch (IOException e) {
               throw new RuntimeException("Can`t write data to file!", e);
           }
       } catch (IOException e) {
           throw new RuntimeException(e);
       }
   }
}

```

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке `java.io.FileWriter` і для якої основної задачі він призначений?

> #### **💬 Відповідь:**
>
> **`FileWriter`** — це клас із пакета `java.io`, призначений для **запису символів (тексту)** у файл. Він є одним з найпростіших способів записати `char`, `String` або `char[]` у файл.
>
> **Основна задача:**
> Забезпечити зручний API для запису **текстових даних**, автоматично обробляючи перетворення символів у байти за допомогою **кодування за замовчуванням** для поточної платформи.
>
> **Важливий нюанс:** `FileWriter` — це про **символи**, а не про "сирі" байти. Для запису байтових даних слід використовувати `FileOutputStream`.
>
> **Приклад:**
>
> ```java
> try (FileWriter writer = new FileWriter("output.txt")) {
>     writer.write("Hello, World!");
> } catch (IOException e) {
>     e.printStackTrace();
> }
> ```

#### **📌 Що перевіряють:**

*Базове розуміння призначення `FileWriter` як інструменту для роботи саме з текстовими даними.*

* * *

### **2 ❓ Питання:**

Як за допомогою `FileWriter` можна дозаписати дані в кінець файлу, а не перезаписувати його?

> #### **💬 Відповідь:**
>
> Щоб увімкнути **режим дозапису (append mode)**, потрібно використати **перевантажений конструктор** `FileWriter`, який приймає другий булевий аргумент.
>
> `new FileWriter(String fileName, boolean append)`
> `new FileWriter(File file, boolean append)`
>
> * Якщо другий параметр **`true`**, дані будуть дописуватися в кінець існуючого файлу. Якщо файл не існує, він буде створений.
> * Якщо другий параметр **`false`** (або якщо використовується конструктор з одним аргументом), файл буде **перезаписано** при першому записі.
>
> **Приклад дозапису:**
>
> ```java
> // `true` вказує на режим дозапису
> try (FileWriter writer = new FileWriter("log.txt", true)) {
>     writer.write("Новий запис у лог: " + new Date() + "\n");
> } catch (IOException e) {
>     e.printStackTrace();
> }
> ```

#### **📌 Що перевіряють:**

*Знання конструкторів `FileWriter` та практичні навички для однієї з найпоширеніших операцій — дозапису.*

* * *

### **3 ❓ Питання:**

Чому завжди необхідно викликати метод `close()` для `FileWriter`? Що може статися, якщо цього не зробити?

> #### **💬 Відповідь:**
>
> Виклик `close()` є **критично важливим** з двох причин:
>
> 1. **Скидання буфера (Flushing):** `FileWriter` (і потоки, які він використовує всередині) може використовувати внутрішню буферизацію для оптимізації операцій запису. Це означає, що ваші дані не обов'язково записуються на диск негайно після виклику `write()`. Метод `close()` перед закриттям потоку **гарантовано викликає `flush()`**, "скидаючи" всі буферизовані дані у файл. **Якщо не викликати `close()`, частина (або всі) ваших даних можуть бути втрачені.**
>
> 2. **Звільнення системних ресурсів:** Кожен відкритий файл займає **файловий дескриптор** в операційній системі. Це обмежений ресурс. Якщо ваша програма постійно відкриває файли і не закриває їх, ви можете вичерпати ліміт файлових дескрипторів, що призведе до неможливості відкривати нові файли або мережеві з'єднання. Метод `close()` звільняє цей ресурс.
>
> Найкращим способом гарантувати виклик `close()` є використання конструкції **`try-with-resources`**.

#### **📌 Що перевіряють:**

*Розуміння того, чому закриття ресурсів є обов'язковим. Кандидат повинен знати і про буферизацію, і про системні ресурси.*

* * *

### **4 ❓ Питання:**

У чому різниця між `FileWriter` та `BufferedWriter`? Коли варто використовувати один, а коли інший?

> #### **💬 Відповідь:**
>
> Головна відмінність — це **наявність ефективної буферизації**.
>
> * **`FileWriter`:**
>   * Записує дані майже напряму (хоча й може мати невеликий внутрішній буфер на рівні ОС). Кожен виклик `write()` може призвести до системного виклику, що є повільною операцією.
>   * **Коли використовувати:** Для **невеликих обсягів даних** або коли простота коду важливіша за продуктивність.
>
> * **`BufferedWriter`:**
>   * Це **клас-обгортка**, який додає **великий буфер у пам'яті** (за замовчуванням 8 KB) до іншого `Writer`'а.
>   * Він накопичує дані у своєму буфері і записує їх на диск **великими порціями** лише тоді, коли буфер заповнюється, або коли викликається `flush()` чи `close()`.
>   * **Коли використовувати:** **Завжди** при записі **великих обсягів** текстових даних. Це значно зменшує кількість звернень до диску і **драматично підвищує продуктивність**.
>
> **Найкраща практика:**
> Майже завжди краще використовувати їх разом для оптимальної продуктивності.
>
> ```java
> // Обгортаємо FileWriter у BufferedWriter
> try (BufferedWriter writer = new BufferedWriter(new FileWriter("large-file.txt"))) {
>     for (int i = 0; i < 100_000; i++) {
>         writer.write("Line " + i + "\n");
>     }
> }
> ```

#### **📌 Що перевіряють:**

*Розуміння важливості буферизації для продуктивності операцій вводу/виводу. Знання патерну "Декоратор" у `java.io`.*

* * *

### **5 ❓ Питання:**

Як `FileWriter` працює з кодуванням символів? Чи можна його змінити? ⭐️

> #### **💬 Відповідь:**
>
> `FileWriter` — це клас для зручності, який **приховує** роботу з кодуваннями.
>
> * Він завжди використовує **кодування за замовчуванням для поточної платформи**, на якій запущена JVM. Його можна отримати через `Charset.defaultCharset()`.
> * На Windows це може бути `windows-1251`, на Linux/macOS — зазвичай `UTF-8`.
>
> **Чи можна його змінити?**
>
> * **Ні, напряму в `FileWriter` — не можна.** У нього немає конструктора, що приймає `Charset`.
>
> **Чому це проблема:**
>
> * Це робить ваш код **непереносимим**. Файл, створений на Windows, може некоректно читатися на Linux, якщо в ньому є не-ASCII символи.
>
> **Як правильно працювати з кодуванням:**
>
> Слід використовувати більш низькорівневу, але гнучку комбінацію **`FileOutputStream`** та **`OutputStreamWriter`**. Конструктор `OutputStreamWriter` дозволяє **явно вказати кодування**.
>
> ```java
> try (OutputStreamWriter writer = new OutputStreamWriter(
>          new FileOutputStream("file.txt"), StandardCharsets.UTF_8)) {
>
>     writer.write("Привіт, світ!");
> }
> ```
>
> Це є **найкращою практикою** для надійної роботи з текстом, особливо якщо ваш додаток працює на різних платформах або обробляє інтернаціональні дані.

#### **📌 Що перевіряють:**

*Розуміння проблем, пов'язаних з кодуваннями, та знання правильних інструментів для їх вирішення.*

* * *

### **6 ❓ Питання:**

Чому `FileWriter` кидає `checked` виняток `IOException`?

> #### **💬 Відповідь:**
>
> `FileWriter` кидає `IOException`, тому що операції запису у файл є **взаємодією із зовнішнім світом** і схильні до помилок, які **не залежать від логіки програми** і від яких можна спробувати оговтатися.
>
> `IOException` — це **`checked` виняток**, і це змушує розробника обробляти такі очікувані проблеми:
>
> * **Немає прав на запис:** Операційна система може заборонити запис у певну директорію.
> * **Закінчилося місце на диску:** Під час запису може не вистачити вільного простору.
> * **Диск від'єднано або пошкоджено:** Фізична помилка пристрою.
> * **Файл заблоковано іншим процесом.**
>
> Роблячи `IOException` перевірюваним, Java змушує писати більш надійний код, який передбачає можливі збої при роботі з файловою системою.

#### **📌 Що перевіряють:**

*Розуміння філософії `checked` винятків та їхнього застосування для операцій вводу/виводу.*

* * *

### **7 ❓ Питання:**

Яка різниця між методами `write(String str)` та `append(CharSequence csq)` у `FileWriter`? ⭐️

> #### **💬 Відповідь:**
>
> Хоча їхній результат однаковий — додавання тексту до потоку, — вони мають кілька відмінностей.
>
> * **`void write(String str)`:**
>   * Це основний метод, успадкований від `Writer`.
>   * Просто записує рядок. Нічого не повертає.
>
> * **`Writer append(CharSequence csq)`:**
>   * Цей метод був доданий, щоб `Writer` реалізовував інтерфейс `Appendable`.
>   * **Повертає посилання на себе (`this`)**. Це дозволяє створювати **ланцюжкові виклики (method chaining)**.
>   * Приймає більш загальний тип `CharSequence` (`String`, `StringBuilder`, `StringBuffer` є його реалізаціями).
>
> **Приклад використання `append`:**
>
> ```java
> writer.append("Перший рядок.")
>       .append(" Другий рядок.")
>       .append(" Третій рядок.");
> ```
>
> На практиці для `FileWriter` ця різниця не є дуже суттєвою, але `append()` може бути зручнішим для побудови ланцюжків.

#### **📌 Що перевіряють:**

*Знання API класу `Writer` та патерну `Fluent Interface`.*

* * *

### **8 ❓ Питання:**

Що робить метод `flush()`? Чи потрібен він, якщо ми використовуємо `try-with-resources`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Метод **`flush()`** призначений для **примусового "скидання" (запису) всіх даних**, що знаходяться у внутрішньому буфері потоку, безпосередньо у цільовий ресурс (наприклад, файл на диску).
>
> Він не закриває сам потік, а лише гарантує, що всі дані, відправлені через `write()`, будуть записані негайно.
>
> **Чи потрібен він, якщо є `try-with-resources`?**
>
> * **Зазвичай ні.** Конструкція `try-with-resources` автоматично викликає `close()` в кінці. Метод `close()`, у свою чергу, **неявно викликає `flush()`** перед закриттям. Тому для більшості випадків цього достатньо.
>
> **Коли `flush()` може бути корисним:**
>
> * **При довготривалому записі:** Якщо ви пишете великий лог-файл або передаєте дані по мережі протягом тривалого часу, ви можете періодично викликати `flush()`, щоб гарантувати, що проміжні дані будуть збережені і не будуть втрачені, якщо програма "впаде" до завершення операції.
> * **При взаємодії процесів:** Якщо один процес пише у файл, а інший повинен його читати в реальному часі, `flush()` гарантує, що дані стануть видимими для іншого процесу.

#### **📌 Що перевіряють:**

*Глибоке розуміння буферизації та життєвого циклу потоків.*

* * *

### **9 ❓ Питання:**

Чи можна писати байти у `FileWriter`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, напряму — не можна.**
>
> Клас `FileWriter` (і всі нащадки `Writer`) призначені для роботи з **символами (`char`)**, а не з **байтами (`byte`)**.
>
> * Він має методи `write(int c)` (де `int` трактується як `char`), `write(char[] cbuf)`, `write(String str)`.
> * У нього **немає** методу `write(byte[] b)`.
>
> Спроба записати байти у `FileWriter` вимагатиме спочатку їхнього **перетворення в символи**. Але це потрібно робити дуже обережно, вказуючи правильне кодування, інакше ви можете отримати "поламані" символи.
>
> ```java
> byte[] data = ...;
> // Перетворюємо байти в рядок з правильним кодуванням
> String s = new String(data, StandardCharsets.UTF_8);
> writer.write(s);
> ```
>
> Якщо ж вам потрібно записати у файл **саме байти**, то правильним інструментом для цього є **`FileOutputStream`**.

#### **📌 Що перевіряють:**

*Чітке розмежування між символьними потоками (`Writer`/`Reader`) та байтовими потоками (`OutputStream`/`InputStream`).*

* * *

### **10 ❓ Питання:**

Що краще використовувати для роботи з файлами: `FileWriter` чи `Files.newBufferedWriter()` (з NIO.2)? ⭐️⭐️

> #### **💬 Відповідь:**
>
> У сучасному коді **`Files.newBufferedWriter()`** є **однозначно кращим вибором**.
>
> **Переваги `Files.newBufferedWriter(path, charset, options...)`:**
>
> 1. **Явна робота з кодуванням:** Ви можете ( і повинні) явно вказати `Charset` (наприклад, `StandardCharsets.UTF_8`), що робить ваш код переносимим і надійним. `FileWriter` використовує неявне кодування платформи.
>
> 2. **Гнучке управління опціями:** Ви можете легко вказати опції запису, такі як `StandardOpenOption.APPEND` (дозапис), `CREATE` (створити, якщо не існує) тощо. Це більш виразно, ніж булевий прапорець в `FileWriter`.
>
> 3. **Повертає `BufferedWriter`:** Ви одразу отримуєте ефективний, буферизований потік без необхідності обгортати його вручну.
>
> 4. **Працює з `Path`:** Інтегрується з сучасним NIO.2 API, яке є більш потужним, ніж старий `java.io.File`.
>
> 5. **Краща обробка помилок:** Методи з `Files` кидають більш специфічні `IOException`, надаючи більше інформації про причину помилки.
>
> **Висновок:** `FileWriter` є застарілим класом для зручності. Для будь-якого серйозного коду слід використовувати сучасний підхід з **`Files.newBufferedWriter()`**.

#### **📌 Що перевіряють:**

*Знання сучасного NIO.2 API та розуміння його переваг над старим `java.io`.*

* * *

### **11 ❓ Питання:**

Якщо конструктор `new FileWriter("path")` не кинув `FileNotFoundException`, чи гарантує це, що запис (`write()`) буде успішним? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, не гарантує.**
>
> * Конструктор `new FileWriter("path")` (і метод `file.createNewFile()`) може кинути `IOException` (підтипом якого є `FileNotFoundException`), лише якщо **файл не може бути створено**. Це зазвичай відбувається, якщо **не існує батьківська директорія** або у вас **немає прав на запис** у цю директорію.
> * Якщо шлях валідний і права є, конструктор успішно виконається, створюючи (або відкриваючи) файл.
>
> **Однак, виклик `write()` може зазнати невдачі з інших причин:**
>
> * **Закінчилося місце на диску:** Це найпоширеніша причина. Виняток виникне саме під час спроби записати дані.
> * **Досягнуто квоти користувача:** Операційна система може обмежувати обсяг дискового простору для користувача.
> * **Проблеми з файловою системою:** Наприклад, фізична помилка на диску.
>
> Таким чином, успішна ініціалізація `FileWriter` лише гарантує, що шлях до файлу є валідним для запису на поточний момент, але не гарантує успішності самих операцій запису.

#### **📌 Що перевіряють:**

*Глибоке розуміння того, на якому етапі можуть виникати різні типи помилок вводу/виводу.*

* * *

### **12 ❓ Питання:**

У `FileWriter` є метод `write(int c)`. Чи означає це, що він може писати цілі числа? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, цей метод призначений для запису одного символу (`char`).**
>
> * Хоча метод приймає `int`, він використовує лише **16 молодших біт** цього `int` і інтерпретує їх як значення **`char`**.
> * Старші 16 біт ігноруються.
>
> **Чому він приймає `int`?**
>
> Це історично пов'язано з дизайном потоків вводу/виводу в C та ранній Java. Наприклад, метод `Reader.read()` повертає `int`, а не `char`, щоб мати можливість повернути **-1** для позначення кінця потоку, не плутаючи його з будь-яким валідним символом `char` (діапазон якого 0-65535).
>
> Для симетрії `Writer.write()` також приймає `int`, хоча записує лише один символ.
>
> **Щоб записати ціле число (наприклад, `123`) як текст**, потрібно спочатку перетворити його на рядок:
>
> `writer.write(String.valueOf(123));`
>
> Якщо ви напишете `writer.write(123)`, у файл буде записано символ з Unicode-кодом 123, що є `'{`'.

#### **📌 Що перевіряють:**

*Увагу до деталей API та розуміння історичних причин певних дизайнерських рішень у `java.io`.*

* * *

### **13 ❓ Питання:**

Чому `FileWriter`, що працює з `System.out`, не є гарною ідеєю? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Технічно ви можете обгорнути `System.out` (який є `PrintStream`, нащадком `OutputStream`) у `FileWriter`, але це є **поганим дизайном** і може призвести до проблем з кодуванням.
>
> `new FileWriter(new FileDescriptor.out)`
>
> **Проблеми:**
>
> 1. **Проблема з кодуванням:** `FileWriter` буде використовувати **кодування платформи за замовчуванням** для перетворення символів у байти, які потім будуть передані в `System.out`. Консоль, у свою чергу, має власне кодування. Якщо вони не збігаються, ви отримаєте "кракозябри" замість кириличних чи інших не-ASCII символів.
>
> 2. **Неефективність:** `System.out` сам по собі є `PrintStream`, який має потужні методи для форматованого виводу (`println`, `printf`). Обгортання його в `FileWriter` позбавляє вас цих можливостей і додає зайвий, непотрібний шар абстракції.
>
> **Правильний підхід:**
> Для виводу в консоль слід завжди використовувати безпосередньо **`System.out`**. Якщо вам потрібно явно контролювати кодування виводу в консоль, ви можете створити `PrintWriter` на основі `System.out`:
>
> `PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out, StandardCharsets.UTF_8), true);`
>
> Це набагато більш явний і надійний спосіб.

#### **📌 Що перевіряють:**

*Глибокі знання `java.io` та розуміння того, як різні класи потоків взаємодіють між собою.*

* * *

### **14 ❓ Питання:**

У чому полягає **"атомарність" операцій** `FileWriter`? Чи є запис рядка атомарною операцією? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, операції `FileWriter` не є атомарними.**
>
> * **Атомарна операція** — це операція, яка виконується як єдине, неподільне ціле. Або вона завершується повністю, або не виконується взагалі.
>
> * **Виклик `writer.write(String str)` не є атомарним.** Це означає, що якщо під час запису довгого рядка виникне помилка (наприклад, закінчиться місце на диску), то у файл може бути **записана лише частина рядка**, а потім буде кинуто `IOException`.
>
> **Багатопотоковість:**
>
> * Крім того, `FileWriter` **не є потокобезпечним**. Якщо кілька потоків будуть одночасно писати в один і той самий екземпляр `FileWriter` без зовнішньої синхронізації, їхній вивід **хаотично перемішається**, і файл буде пошкоджено.
>
> Для потокобезпечного запису потрібно або використовувати зовнішні блокування (`synchronized`), або використовувати класи, спеціально розроблені для цього. Наприклад, можна обгорнути `FileWriter` у кастомний синхронізований декоратор.

#### **📌 Що перевіряють:**

*Розуміння того, що операції вводу/виводу за замовчуванням не є атомарними, та знання аспектів потокобезпечності для I/O.*

* * *

### **15 ❓ Питання:**

Як реалізувати власний `Writer`, що шифрує дані "на льоту" перед записом, використовуючи `FileWriter`? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Це класична задача на патерн **Декоратор (Decorator)**. Ми створимо власний клас, що успадковує `java.io.Writer` і "обгортає" інший `Writer` (наприклад, `FileWriter`).
>
> **Ідея:**
>
> 1. Наш `EncryptingWriter` буде приймати в конструкторі інший `Writer` (делегат).
> 2. Він перевизначить методи `write()`.
> 3. Всередині `write()` він спочатку зашифрує дані, а потім **делегує** запис зашифрованих даних оригінальному `Writer`'у.
>
> **Приклад реалізації (простий XOR-шифр):**
>
> ```java
> public class EncryptingWriter extends Writer {
>     private final Writer delegate;
>     private final int encryptionKey;
>
>     public EncryptingWriter(Writer delegate, int key) {
>         this.delegate = delegate;
>         this.encryptionKey = key;
>     }
>
>     @Override
>     public void write(char[] cbuf, int off, int len) throws IOException {
>         // Створюємо новий масив для зашифрованих даних
>         char[] encrypted = new char[len];
>         for (int i = 0; i < len; i++) {
>             // Шифруємо кожен символ за допомогою XOR
>             encrypted[i] = (char) (cbuf[off + i] ^ encryptionKey);
>         }
>         // Делегуємо запис зашифрованих даних
>         delegate.write(encrypted, 0, len);
>     }
>
>     @Override
>     public void flush() throws IOException { delegate.flush(); }
>
>     @Override
>     public void close() throws IOException { delegate.close(); }
> }
> ```
>
> **Як використовувати:**
>
> ```java
> try (Writer writer = new EncryptingWriter(new FileWriter("secret.txt"), 123)) {
>     writer.write("Секретне повідомлення");
> }
> ```
>
> Цей підхід є дуже гнучким, оскільки `EncryptingWriter` може обгортати будь-який `Writer` (`FileWriter`, `StringWriter` тощо), додаючи до нього функціональність шифрування.

#### **📌 Що перевіряють:**

*Знання патерну "Декоратор" та його практичне застосування для розширення функціональності класів `java.io`.*
