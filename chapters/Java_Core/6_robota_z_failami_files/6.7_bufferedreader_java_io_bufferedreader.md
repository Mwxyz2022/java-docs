---
layout: default
title: "BufferedReader (java.io.BufferedReader)"
parent: "Робота з файлами (Files)"
grand_parent: "Java Core"
nav_order: 7
---

# BufferedReader (java.io.BufferedReader)

* короткий опис: `BufferedReader` – це клас, що обгортає інший `Reader` (наприклад, `FileReader`) для ефективного буферизованого зчитування тексту. Особливо зручний для построчного зчитування за допомогою методу `readLine()`.

* поняття: `BufferedReader`, `readLine()`, буфер.

* приклади: `new BufferedReader(new FileReader("file.txt"));`, зчитування рядків у циклі (`String line = br.readLine()`).

* ключові моменти: Використовує внутрішній буфер (зазвичай 8 КБ), що значно прискорює зчитування. `readLine()` повертає `null` наприкінці файлу.

* що важливо знати на співбесіді: Переваги, коли використовувати, `readLine()` повертає `null` в кінці.

### **✅ Офіційне визначення:**  

**`BufferedReader`** — це клас з пакета **`java.io`,** який використовується для **ефективного зчитування тексту з вхідного потоку**, особливо **построчно** через метод **`readLine()`**.

### **🧠 Простими словами:**  

Це як **пилосос з мішком**, який не тягне символи по одному (як **`FileReader`**), а **втягує одразу блок тексту в буфер**. Потім ти вже зручно працюєш з цим буфером, читаючи по **рядках**.

---

## **Основні методи**

📊 Найпопулярніші:

| Метод | Що робить |
| ----- | ----- |
| **`readLine()`** | Зчитує один **рядок тексту** |
| **`read(char[])`** | Зчитує масив символів |
| **`close()`** | Закриває потік |

🧠 Усі методи працюють поверх **внутрішнього буфера** (8192 символи за замовчуванням), що значно прискорює зчитування.

---

## **Пояснення на пальцях (💡)**

### **Для чого?**

* Коли потрібно **читати построчно**

* Обробка **великих текстових файлів**

* Економія на **викликах системи читання** (I/O)

### **У чому особливість?**

* **Працює з іншими рідерами**, наприклад, **`FileReader`**

* **Читає в буфер**, тому швидше

* Дає зручний метод **`readLine()`** -> можна працювати з рядками

#### **Типові помилки:**

* Не закривати потік — краще через try-with-resources

* Забути перевірити, що **`readLine()`** повертає **`null`** (кінець файлу)

---

## **Корисні приклади (🧪)**

### **🔹 Прочитати файл построчно:**

```java
BufferedReader br = new BufferedReader(new FileReader("file.txt"));
String line;
while ((line = br.readLine()) != null) {
    System.out.println(line);
}
br.close();
```

### **🔹 З try-with-resources:**

```java
try (BufferedReader br = new BufferedReader(new FileReader("file.txt"))) {
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
}
```

---

## **Порівняння (⚖️)**

| Клас | Що читає | Рівень доступу | Буфер | Построчно |
| ----- | ----- | ----- | ----- | ----- |
| **`FileReader`** | Символи | Низький | ❌ | ❌ |
| **`BufferedReader`** | Символи/рядки | Високий | ✅ | ✅ |
| **`Scanner`** | Текст/токени | Високий | ✅ | ✅ |

📝 **`Scanner`** краще для розбору (парсингу), **`BufferedReader`** — для **швидкого зчитування** рядків.

---

## **🧠 Мнемоніка для запам’ятовування:**

```java
Buffered -> швидкий (буфер)
Reader   -> читає
readLine() -> рядок
null -> кінець
```

---

## **🟩 Підсумок:**

**`BufferedReader`** — це **оптимальний спосіб читати великі текстові файли рядками**. Він використовує буфер для підвищення продуктивності та надає зручний метод **`readLine()`**. У 95% випадків, коли читаєш текст з файлу — це твій вибір.

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке `java.io.BufferedReader` і яку основну проблему він вирішує?

> #### **💬 Відповідь:**
>
> **`BufferedReader`** — це клас із пакета `java.io`, який реалізує патерн **Декоратор**. Він "обгортає" інший `Reader` (наприклад, `FileReader` або `InputStreamReader`) і додає до нього **ефективну буферизацію**.
>
> **Основна проблема, яку він вирішує:**
>
> * Операції читання з фізичного диска або іншого джерела (`I/O`) є дуже **повільними**. Посимвольне читання за допомогою, наприклад, `FileReader` призводить до великої кількості системних викликів.
>
> **Рішення:**
>
> * `BufferedReader` читає дані з базового потоку **великими порціями (чанками)** і зберігає їх у **внутрішньому буфері** в пам'яті (за замовчуванням розміром 8 KB).
> * Подальші виклики `read()` беруть дані з цього швидкого буфера. Звернення до диска відбувається лише тоді, коли буфер стає порожнім.
>
> Це значно **зменшує кількість дорогих I/O операцій** і **драматично підвищує продуктивність** при читанні великих текстових файлів.

#### **📝Д Аналогія:**

Це як читати книгу.

* **`FileReader`:** Ви читаєте по одній літері, кожного разу підносячи лупу до ока.
* **`BufferedReader`:** Ви читаєте одразу ціобре, я ознайомився з конспектом. На співбесідах на цю тему важливо не тільки знати, що `BufferedReader` читає по рядках, а й розуміти **лий абзац (блок даних у буфер), запам'ятовуєте його, а потім вже аналізуєте по реченнях (`readLine()`) з пам'яті.

#### **📌 Що перевіряють:**

*Розуміння того, що `BufferedReader` — це про оптимізацію продуктивності за рахунок зменшення кількості звермеханізм буферизації**, його **переваги над `FileReader` та `Scanner`**, та як він працює у **ланцюжку з іншими потоками**, зокрема з `InputStreamReader`.

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питаннянень до диска.*

* * *

### **2 ❓ Питання:**

Як правильно створити та використовувати `BufferedReader` для читання файлу?

> #### **💬 Відповідь:**
>
> `BufferedReader` є обгорткою, тому його потрібно створювати, передаючи в конструктор інший `Reader`. Найкращою практикою є використання `try-with-resources`, щоб гарантувати автоматичне закриття потоку.
:**

Що таке `java.io.BufferedReader` і яку головну проблему він вирішує?

> #### **💬 Відповідь:**
>
> **`BufferedReader`** — це клас із пакета `java.io`, який "обгортає" інший `Reader` (наприклад, `FileReader`) для забезпечення **ефективного, буферизованого читання символів>
> **Найпоширеніший спосіб — для читання рядками:**
>
> ```java
> import java.io.BufferedReader;
> import java.io.FileReader;
> import java.io.IOException;
>
> public class ReadExample {
>     public static void main(String[] args) {
>         try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
>             String line;
>             // readLine() повертає null**.
>
> **Головна проблема, яку він вирішує:**
>
> *   **Продуктивність.** Читання з диска є дуже повільною операцією. Класи, як `FileReader`, читають дані невеликими порціями, що призводить до великої кількості дорогих системних викликів.
>
> **Рішення:**
>
> *   `BufferedReader` створює **внутрішній буфер** у пам, коли досягнуто кінця файлу
>             while ((line = reader.readLine()) != null) {
>                 System.out.println(line);
>             }
>         } catch (IOException e) {
>             e.printStackTrace();
>         }
>     }
> }
> ```
>
> **Пояснення ланцюжка:**
>
> 1. `new FileReader("file.txt")` створює символьний потік для читання з файлу (використовуючи кодування платформи за замовчуванням).
> 2. `new BufferedReader(...)` обгортає `FileReader`, додаючи до нього буферизацію та зру'яті (за замовчуванням розміром 8192 символи).
>
> * При першому виклику `read()` він зчитує з диска одразу **великий блок даних** у цей буфер.
> * Всі наступні виклики `read()` беруть дані вже з цього **швидкого буфера в пам'яті**, доки він не спорожніє.
>
> Це значно **зменшує кількість звернень до диска** і драматично підвищує швидкість читання, особливо для великих файлів.чний метод `readLine()`.
> 3.  `try-with-resources` гарантує, що після завершення блоку `reader.close()` буде викликано, що, в свою чергу, закриє і вкладений `FileReader`.

#### **📌 Що перевіряють:**

*Практичні навички написання стандартного коду для читання файлів.*

* * *

### **3 ❓ Питання:**

У чому основні переваги `BufferedReader` над `FileReader`?

> #### **💬 Відповідь:**
>
> `BufferedReader` має дві ключові переваги:
>
> 1. **Продуктивність:**
>     * Це найважливіша перевага. Завдяки буферизації, `BufferedReader` читає дані
> Крім того, він надає дуже зручний метод `readLine()` для построчного читання.

#### **📝 Аналогія:**

Це як читати книгу в бібліотеці.

* **`FileReader`:** Ви бігаєте до полиці за кожним реченням.
* **`BufferedReader`:** Ви берете всю книгу (або велику главу) за один раз до свого столу (це буфер) і вже там спокійно читаєте її рядок за рядком.

#### **📌 Що перевіряють:**

*Розуміння того, що `BufferedReader` — це в першу чергу про оптимізацію продуктивності за рахунок буферизації.*

* * з диска великими блоками, а не посимвольно. Це **радикально зменшує кількість дорогих системних викликів**, що робить його незамінним для читання великих файлів.
>
> 2. **Зручне API для построчного читання:**
>     * `BufferedReader` надає дуже корисний метод **`readLine()`**.
>     * Цей метод читає **цілий рядок** тексту до символу нового рядка, повертає його як `String` і "запам'ятовує" позицію для наступного читання.
>     * `readLine()` автоматично обробляє різні типи кінця рядка (`\n`, `\r`, `\r\n`), що робить код більш переносимим.
>     * *

### **2 ❓ Питання:**

Як правильно прочитати текстовий файл рядок за рядком за допомогою `BufferedReader`?

> #### **💬 Відповідь:**
>
> Найкращим способом є використання `try-with-resources` для автоматичного закриття потоку та методу `readLine()` у циклі `while`.
>
> **Метод `readLine()`:**
>
> * Читає один повний рядок тексту.
> * Повертає `String` з вмістом рядка (без символів нового рядка `\n` або `\r\n`).
> * Коли досягнуто кінця файлу, він повертає **`null`**.
>
> **Приклад коду:**
>
> ```java
> import java.io.BufferedReader;
> import java.io   Це набагато зручніше, ніж посимвольне читання і ручне збирання рядків за допомогою `FileReader`.

#### **📌 Що перевіряють:**

*Здатність порівняти два класи та обґрунтувати переваги одного над іншим з точки зору продуктивності та зручності API.*

* * *

### **4 ❓ Питання:**

Що повертає метод `BufferedReader.readLine()` і як визначити кінець файлу?

> #### **💬 Відповідь:**
>
> Метод `public String readLine() throws IOException` читає один рядок тексту з потоку.
>
> **Що він повертає:**
>
> * Якщо вдалося прочитати рядок, він повертає **`String`.FileReader;
> import java.io.IOException;
>
> public class ReadFileByLine {
> public static void main(String[] args) {
> String filePath = "my_file.txt";
>
>         // try-with-resources автоматично закриє reader
>         try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {
>             String line;
>             // Цикл виконується, доки readLine() не поверне null
>             while ((line = reader.readLine()) != null) {
>                 System.out.println(line);
>             }
>         } catch (IOException e) {
>             System.err.println("Помилка при читанні файлу: " + e.getMessage());
>         }
>     }
> }
>
> ```
> Ідіома `while ((line = reader.readLine()) != null)` є стандартною для построчного читання файлів у Java.

#### **📌 Що перевіряють:**

*Практичні навички роботи з `BufferedReader` та знання стандартної ідіоми для читання файлів.*

* * *

### **3 ❓ Питання:**

У чому різниця між `BufferedReader`**, що містить цей рядок. **Символи кінця рядка (`\n`, `\r\n`) не включаються** у повернутий рядок.
>
> * Якщо досягнуто **кінця потоку** (файлу), і більше немає даних для читання, метод повертає **`null`**.
>
> **Як визначити кінець файлу:**
>
> Саме перевірка на `null` є стандартним ідіоматичним способом визначення кінця файлу при построчному читанні.
>
> **Стандартний цикл читання:**
>
> ```java
> String line;
> while ((line = reader.readLine()) != null) {
>     // обробляємо рядок 'line'
> }
> ```
>
> Конструкція `(line = reader.readLine()) != та`Scanner`? Коли який краще використовувати?

> #### **💬 Відповідь:**
>
> Обидва класи призначені для читання, але вирішують різні завдання.
>
| Характеристика | `BufferedReader` | `Scanner` |
| :---: | :---: | :---: |
| **Основне призначення**| **Швидке, буферизоване читання** "сирих" рядків або символів.| **Парсинг (розбір) вхідних даних** на токени: числа, слова тощо. |
| **Продуктивність** | **Дуже висока.** Просто читає дані null` в одному виразі читає рядок, присвоює його змінній `line` і одразу перевіряє, чи не повернуто `null`.

#### **📌 Що перевіряють:**

*Знання контракту методу `readLine()` та стандартної ідіоми для построчного читання файлів.*

* * *

### **5 ❓ Питання:**

Порівняйте `BufferedReader` та `Scanner`. Коли який інструмент є кращим вибором?

> #### **💬 Відповідь:**
>
> Обидва класи призначені для читання даних, але вирішують різні завдання.
>
> **`BufferedReader`:**
>
> * **Призначення:** **Швидке, буферизоване читання "сирого" тексту** посимвольно або рядок за рядком.
> * **Переваги:** **Дуже висока продуктивність**, оскільки він не виконує ніякого пар у буфер. | **Значно повільніший.** Він виконує складну роботу з пошуку токенів за допомогою регулярних виразів.|
| **API** | Надає лише базові `read()` та `readLine()`. | Надає зручні `nextInt()`, `nextDouble()`, `next()`, `hasNextInt()` і т.д. |
| **Буферизація** | Буфер більший за замовчуванням (8KB). | Буфер менший за замовчуванням (1KB). |
| **Потокобезпечність**| Не є потокобезпечним. | Не є потокобезпечним. |
>
> **Коли який використовувати:**
>
> * **`BufferedReader`:** Коли вам потрібно **максимально швидко прочитати велисингу чи аналізу даних, а просто читає їх.
> * **Недоліки:** Не має вбудованих методів для читання чисел, окремих слів (токенів).
> * **Коли краще:** Коли вам потрібно **максимально швидко** прочитати великий текстовий файл, а парсинг рядків ви будете робити вручну.
>
> **`Scanner`:**
>
> * **Призначення:** **Парсинг (розбір) вхідних даних**. Він може читати не тільки рядки, але й окремі токени (слова), цілі числа (`nextInt()`), числа з плаваючою комою (`nextDouble()`) тощо.
> * **Переваги:** Дуже зручний API для розбору структурованого тексту, введення з консолі.
> * **Недоліки:** **кий текстовий файл** рядок за рядком, без необхідності розбирати його вміст на місці.
> * **`Scanner`:** Коли вам потрібно **парсити структуровані дані** — з консолі (`System.in`), файлу чи рядка. Ідеально підходить для інтерактивного вводу або читання файлів з певним форматом.

#### **📌 Що перевіряють:**

*Здатність обрати правильний інструмент для конкретної задачі, розуміючи компроміс між продуктивністю та зручністю API.*

* * *

### **4 ❓ Питання:**

Як прочитати файл у певному кодуванні (наприклад, UTF-8), використовуючи `BufferedReader`?

> #### **💬 Відповідь:**
>
> Сам по собі `BufferedReader` не працює з кодуваннями — він працює з уже готовим символьним потоком (`Reader`). Відповідальність за коректне декодування байтів у символи лежить на цьому базовому `Reader`.
>
> Щоб явноЗначно повільніший** за `BufferedReader`, оскільки на кожному кроці він використовує регулярні вирази для пошуку токенів та роздільників. Також його буфер за замовчуванням менший (1 KB).
>
> **Висновок:**
>
> * Для **швидкого читання великих логів/файлів** — `BufferedReader`.
> * Для **розбору введення з консолі** або файлу з відомою структурою (наприклад, числа, розділені пробілами) — `Scanner`.

#### **📌 Що перевіряють:**

*Здатність обрати правильний інструмент для конкретної задачі. Розуміння компромісу між продуктивністю та зручністю парсингу.*

* * *

### **6 ❓ Питання:**

Як за допомогою `BufferedReader` прочитати файл з певним кодуванням (наприклад, `windows-1251`)? ⭐️

> #### **💬 Відповідь:**
>
> Сам `BufferedReader` не відповідає за кодування. Він працює з символами. Відповідальність за **прави вказати кодування, потрібно створити ланцюжок `FileInputStream` → `InputStreamReader` → `BufferedReader`.
>
> 1. `FileInputStream` читає "сирі" байти з файлу.
> 2. `InputStreamReader` "обгортає" його і перетворює байти в символи, використовуючи **явно вказане кодування**.
> 3. `BufferedReader` обгортає `InputStreamReader` для ефективної буферизації.
>
> **Правильний код:**
>
> ```java
> Path path = Paths.get("my_file.txt");
>
> // З Java 7 найкраще використовувати Files.newBufferedReader
> try (BufferedReader reader = Files.newBufferedReader(path, StandardCharsets.UTF_8)) {
>     // ...
> } catch (IOException e) {
>     e.printStackTrace();
> }
> ```
>
> **Або вручну (старий підхід):**
>
> ```java
> try (BufferedReader reader = new BufferedReader(
>                                 new InputStreamReader(
>                                     new FileInputStream("my_file.txt"), StandardCharsets.UTF_8
>                                 )
>                             )) {
>     // ...
> }
> ```
>
> Використання `FileReader` тутльне перетворення байтів у символи** лежить на `Reader`-і, який він обгортає.
>
> Клас `FileReader` не дозволяє вказати кодування. Тому для цієї задачі потрібно створити ланцюжок вручну, використовуючи **`InputStreamReader`**.
>
> **Ланцюжок: `FileInputStream` → `InputStreamReader` → `BufferedReader`**
>
> 1. `FileInputStream` читає "сирі" байти з файлу.
> 2. `InputStreamReader` "обгортає" його і перетворює байти в символи з **явно вказаним кодуванням**.
> 3. `BufferedReader` обгортає `InputStreamReader` для додавання буферизації.
>
> **Приклад коду:**
>
> ```java
> import java.nio.charset.Charset;
> import java.io.*;
>
> Path filePath = Paths.get("windows_file.txt");
> Charset windows1251 = Charset.forName("windows-1251");
>
> try (BufferedReader reader = new BufferedReader(
>          new InputStreamReader(
 недоречне, бо він не дозволяє вказати кодування.

#### **📌 Що перевіряють:**

*Розуміння того, як працюють потоки вводу/виводу, та знання правильних класів для роботи з кодуваннями.*

* * *

### **5 ❓ Питання:**

Чому `BufferedReader` значно швидший за `FileReader` при читанні файлу?

> #### **💬 Відповідь:**
>
> **Тому що `BufferedReader` використовує буферизацію.**
>
> * **`FileReader` (без буфера):** Кожен виклик методу `read()` потенційно призводить до **системного виклику**, який звертається до операційної системи, а та — до фізичного диска. Такі операції є **дуже повільними**. При читанні файлу символ за символом ви будете робити тисячі таких дорогих викликів.
>
> * **`BufferedReader` (з буфером):** При першому зверненні `BufferedReader` зчитує з диска **один великий блок>              new FileInputStream(filePath.toFile()), windows1251
>          )
>      )) {
>     String line;
>     while ((line = reader.readLine()) != null) {
>         System.out.println(line);
>     }
> } catch (IOException e) {
>     e.printStackTrace();
> }
>
> ```
> Цей підхід є єдиним надійним способом роботи з файлами, кодування яких відрізняється від дефолтного.

#### **📌 Що перевіряють:**

*Знання ієрархії потоків `java.io` та того, який клас за що відповідає (особливо, роль `InputStreamReader`).*

* * *

### **7 ❓ Питання:**

Як `BufferedReader` пов'язаний з патерном проектування "Декоратор"? ⭐️

> #### **💬 Відповідь:**
>
> `BufferedReader` є класичним прикладом **патерну "Декоратор" (Decorator)** в `java.io` API.
>
> **Суть патерну:**
> Дозволяє **динамічно додавати нову функціональність** до існуючого об'єкта, "обгортаючи" його в інший об'єкт того ж типу (або з тим самим інтерфейсом).
>
> **Як це реалізовано:**
>
> * `BufferedReader` є нащадком `Reader`.
> * Він приймає в конструкторі інший об'єкт типу `Reader` (наприклад, `FileReader`).
> * В даних** (наприклад, 8KB) і зберігає його у себе в **буфері в пам'яті (RAM)**.
>
> Всі наступні виклики `read()` або `readLine()` беруть дані **з цього швидкого буфера**, а не з диска. Новий системний виклик до диска відбудеться лише тоді, коли буфер спорожніє.
>
> **Результат:** Замість тисяч маленьких звернень до повільного диска, ми робимо лише кілька великих, що **драматично підвищує продуктивність**.

#### **📌 Що перевіряють:**

*Глибоке розуміння принципу буферизації та його впливу на продуктивність I/O операцій.*

* * *

### **6 ❓ Питання:**

Чи можна використовувати `BufferedReader` для читання бінарних файлів?

> #### **💬 Відповідь:**
>
> **Ні, категорично не можна.** `BufferedReader` (як і всі класи `Reader`) призначений **виключно для читання текстових даних**.
>
> **Причина:**
>
> * Він працює з **символами (`char`)**, а не з байтами.
> * "Під капотом" він використовує `InputStreamін **не змінює** базову функціональність`FileReader`, а **додає нову** — буферизацію та метод`readLine()`.
> * Він **делегує** основні операції читання (коли буфер порожній) вкладеному `Reader`-у.
>
> Цей підхід є дуже гнучким, оскільки дозволяє комбінувати різні `Writer`-и та `Reader`-и, як конструктор LEGO:
> `new BufferedReader(new InputStreamReader(new FileInputStream(...)))`.

#### **📌 Що перевіряють:**

*Знання патернів проектування та здатність розпізнавати їхню реалізацію в стандартній бібліотеці.*

* * *

### **8 ❓ Питання:**

Чи можна використовувати один екземпляр `BufferedReader` у кількох потоках? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, це не є потокобезпечним.**
>
> Як і більшість класів з `java.io`, `BufferedReader` **не є потокобезпечним** і не призначений для одночасного використання з кількох потоків.
>
> **Проблеми, які виникнуть:**
>
> 1. **Пошкодження даних:** КільReader` (або схожий механізм), який намагається **інтерпретувати** послідовність байтів з файлу як символи відповідно до певного кодування.
>
> * Байти бінарного файлу (наприклад, зображення `.jpg` або архіву `.zip`) не утворюють валідних послідовностей символів.
> * Спроба прочитати їх через `BufferedReader` призведе до **пошкодження даних**.
>
> Для читання бінарних даних слід використовувати **байтові потоки**: **`FileInputStream`**, бажано обгорнутий у **`BufferedInputStream`** для ефективності.

#### **📌 Що перевіряють:**

*Чітке розмежування між символьними та байтовими потоками.*

* * *

### **7 ❓ Питання:**

Що поверне метод `readLine()`, якщо рядок у файлі порожній? А якщо досягнуто кінця файлу? ⭐️

> #### **💬 Відповідь:**
>
> Це два різних сценарії з різними результатами.
>
> 1. **Якщо рядок у файлі порожній** (тобто, містить лише символ нового рядка або знаходиться між двома роздільниками рядків):
>     * `readLine()` поверне **порожній рядок (`""`)**.
>
> 2. **Якщо досяка потоків будуть читати з одного буфера і переміщувати один і той самий внутрішній вказівник. В результаті, кожен потік отримає випадкові, перемішані частини файлу. Логіка `readLine()` також буде "зламана".
> 2. **Некоректний стан:** Внутрішній стан `BufferedReader` (позиція в буфері, кількість символів) стане непослідовним, що призведе до непередбачуваної поведінки або винятків.
>
> **Правильні підходи:**
>
> * **Кожен потік створює свій власний екземпляр `BufferedReader`** для роботи з файлом. Це найпростіший і найпоширеніший спосіб.
> * Використовувати **зовнішню синхронізацію** (`synchronized` блок), якщо доступ до одного екземпляра є абсолютно необхідним. Але це створить "вузьке місце" і знизить продуктивність.

#### **📌 Що перевіряють:**

*Знагнуто кінця файлу** (і більше немає жодних даних для читання):
>     *   `readLine()` поверне **`null`**.
>
> Ця відмінність є критично важливою. Саме перевірка на `null` є стандартним способом визначити, що читання файлу завершено.
>
> `while ((line = reader.readLine()) != null)`
>
> Ця ідіома коректно працює, оскільки вона буде обробляти порожні рядки як валідні дані і зупиниться лише тоді, коли файл буде повністю прочитано.

#### **📌 Що перевіряють:**

*Знання контракту методу `readLine()`, що є основою для правильної ітерації по файлу.*

* * *

### **8 ❓ Питання:**

Чи можна змінити розмір буфера у `BufferedReader`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, можна.**
>
> Клас `BufferedReader` має перевантажений конструктор, який дозволяє вказати розмір буфера вручну.
>
> `public BufferedReader(Reader in, int sz)`
>
> * `in` — вкладений `Reader`.
> * `sz` — розмір буфера уння аспектів багатопотоковості для стандартних класів `java.io`.*

* * *

### **9 ❓ Питання:**

Що буде, якщо викликати `close()` на `BufferedReader`? Чи буде закрито вкладений потік? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, буде.**
>
> Реалізація методу `close()` у `BufferedReader` (і в інших класах-декораторах з `java.io`) слідує правилу: **"закрий себе, а потім закрий того, кого ти обгортаєш"**.
>
> Коли ви викликаєте `reader.close()` на об'єкті `BufferedReader`, він:
>
> 1. Виконує свої власні дії по очищенню (якщо потрібно).
> 2. **Делегує** виклик `close()` вкладеному `Reader`-у (наприклад, `FileReader`), який був переданий у його конструктор.
>
> Тому символах.
>
> **Коли це може бути доцільно:**
>
> * При роботі з **дуже довгими рядками**. Якщо довжина одного рядка перевищує розмір буфера за замовчуванням (8KB), буферу доведеться кілька разів переініціалізуватися, що знизить продуктивність. Збільшення буфера може вирішити цю проблему.
> * При роботі в середовищі з **обмеженою пам'яттю**, де може знадобитися зменшити розмір буфера.
>
> В більшості випадків розмір за замовчуванням є оптимальним, але можливість його налаштування існує для специфічних потреб.

#### **📌 Що перевіряють:**

*Знання API та можливостей для тонкого налаштування продуктивності I/O.*

* * *

### **9 ❓ Питання:**

Які є альтернативи `BufferedReader.readLine()` у циклі `while` з використанням Java 8 Stream API? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Java 8 Stream API нада, при використанні ланцюжка потоків, достатньо закрити **лише крайню зовнішню обгортку**. Вона сама подбає про закриття всіх внутрішніх потоків.
>
> Це дуже важлива властивість, на якій базується надійність `try-with-resources`.

#### **📌 Що перевіряють:**

*Знання контракту `close()` для потоків-декораторів.*

* * *

### **10 ❓ Питання:**

Як `BufferedReader.lines()` (з Java 8) відрізняється від читання в циклі `while` з `readLine()`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Метод **`lines()`** — це більш сучасний, функціональний підхід до построчного читання, який повертає **`Stream<String>`**.
>
> **Ключова відмінність:**
>
> * **`while ((line = reader.readLine()) != null)`:**
>   * Це **імперативний** підхід. Ви вручну керуєте циклом, присвоєнням та обробкою.
>
> * **`reader.lines()`:**
>   * Це **декларативний**, функціональний підхід.
>є більш сучасний, декларативний та часто зручніший спосіб читання файлів.
>
> 1. **`Files.lines(Path)`:**
>     * Це **найкраща альтернатива**. Цей статичний метод повертає **`Stream<String>`**, який **"ліниво" (lazily)** читає рядки з файлу.
>     * Він не завантажує весь файл у пам'ять, що робить його ідеальним для великих файлів.
>     * Ви можете одразу застосовувати до потоку рядків операції `filter`, `map`, `collect` тощо.
>
>     ```java
>     try (Stream<String> lines = Files.lines(Paths.get("file.txt"))) {
>         lines.filter(s -> s.startsWith("ERROR"))
>              .forEach(System.out::println);
>     }
>     ```
>
> 2. **`BufferedReader.lines()`:**
>
>     * Сам `BufferedReader` також отрима     *   Він повертає **"лінивий" (lazy) `Stream`**. Це означає, що файл **не читається весь одразу** в пам'ять. Рядки читаються з файлу по одному, тільки коли цього вимагає термінальна операція на стрімі (наприклад, `forEach`, `collect`).
>     * Це робить його **дуже ефективним для роботи з великими файлами**.
>
> **Приклад:**
>
> ```java
> try (BufferedReader reader = new BufferedReader(...)) {
>     long count = reader.lines() // Отримуємо Stream<String>
>                      .filter(line -> line.contains("ERROR"))
>                      .count();
>     System.out.println("Кількість рядків з помилкою: " + count);
> }
> ```
>
> **Важливо:** Стрім, повернутий з `lines()`, також є ресурсом. Він повинен бути закритий, щоб закрити базовий `BufferedReader`. Тому `reader` повинен бути в `try-with-resources`.

#### **📌 Що перевіряють:**

*Знання Java 8 Stream API та його застосування для роботи з I/O.*

* * *

### **11 ❓ Питання:**

Як би ви реалізували метод `readLineв метод`lines()`, який робить те ж саме — повертає`Stream<String>`.
>
> **Важливо:**
> Потоки, повернуті `Files.lines()` та `BufferedReader.lines()`, **також є ресурсами**. Вони "тримають" відкритий файловий потік. Тому їх **обов'язково потрібно закривати**, найкраще — за допомогою `try-with-resources`.

#### **📌 Що перевіряють:**

*Знання сучасного Java 8 Stream API для роботи з I/O.*

* * *

### **10 ❓ Питання:**

Що станеться, якщо я закрию `BufferedReader`, а потім спробую прочитати з нього? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Це призведе до викидання **`IOException`** з повідомленням на кшталт "Stream closed".
>
> Коли ви викликаєте `close()` на `BufferedReader`, він виконує дві дії:
>
> 1. Закриває вкладений потік (наприклад, `FileReader`).
> 2. Позначає себе як "закритий".
>
> Будь-яка наступна спроба виконати операцію читання (`read()`, `readLine()`) на закритому потоці пере()` вручну, маючи лише `Reader.read()`? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Це задача на розуміння алгоритму, що лежить в основі `readLine()`.
>
> **Алгоритм:**
>
> 1. Створити `StringBuilder` для накопичення символів поточного рядка.
> 2. В циклі читати символи по одному за допомогою `read()`, який повертає `int`.
> 3. Перевіряти кожен прочитаний символ:
>     * Якщо це **-1** — кінець файлу. Якщо в `StringBuilder` щось є, повернути це, інакше повернути `null`.
>     * Якщо це **`\n`** (новий рядок) — кінець поточного рядка. Повернути вміст `StringBuilder`.
>     * Якщо це **`\r`** (повернення каретки) — також кінець рядка. Додатково можна перевірити, чи наступний символ не `\n`, щоб коревірить цей внутрішній стан і негайно кине `IOException`.
>
> ```java
> BufferedReader reader = new BufferedReader(...);
> reader.close();
> reader.readLine(); // Кине IOException: Stream closed
> ```
>
> Це логічна поведінка, яка запобігає роботі з ресурсами, які вже були звільнені.

#### **📌 Що перевіряють:**

*Розуміння життєвого циклу потоків та наслідків їх закриття.*

* * *

### **11 ❓ Питання:**

Як `BufferedReader` визначає кінець рядка? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Метод `readLine()` є досить "розумним" і розпізнає **три основні послідовності** символів як кінець рядка:
>
> 1. **Символ нового рядка (`\n` - Line Feed, LF):** Використовується в *nix системах (Linux, macOS).
> 2. **Символ повернення каретки (`\r` - Carriage Return):** Використовувався в старих версіях Mac OS.
> 3. **Послідовність "повернення каретки + новий рядок" (`\r\ктно обробити`\r\n`.
>     * Інакше — додати символ до `StringBuilder`.
>
> **Приклад реалізації:**
>
> ```java
> public String customReadLine(Reader reader) throws IOException {
>     StringBuilder sb = new StringBuilder();
>     int ch;
>
>     while ((ch = reader.read()) != -1) {
>         if (ch == '\n') {
>             break;
>         }
>         if (ch == '\r') {
>             // Ігноруємо '\r' і перевіряємо на '\n' для '\r\n'
>             // Тут потрібна більш складна логіка з `mark`/`reset` або `PushbackReader`
>             break;
>         }
>         sb.append((char) ch);
>     }
>
>     if (ch == -1 && sb.length() == 0) {
>         return null; // Кінець файлу і буфер порожній
>     }
>     return sb.toString();
> }
> ```
>
> Цей приклад спрощений, але демонструє основну логіку.n` - CRLF):** Стандарт для Windows.
>
> `readLine()` читає символи доти, доки не зустріне одну з цих послідовностей. Самі ці символи-роздільники **не включаються** у повернутий рядок.
>
> Ця гнучкість робить `readLine()` **кросплатформенним**: він може коректно читати текстові файли, створені на будь-якій основній операційній системі.

#### **📌 Що перевіряють:**

*Глибоке знання того, як працює метод `readLine` "під капотом", та аспектів кросплатформенності.*

* * *

### **12 ❓ Питання:**

Чи є `BufferedReader` потокобезпечним? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, не є.** Як і більшість класів з `java.io`, `BufferedReader` **не є потокобезпечним**.
>
> Його методи (`read`, `readLine`) не синхронізовані. Якщо кілька потоків будуть одночасно читати з одного екземпляра `BufferedReader`, виникне **стан Реалізація в JDK є значно складнішою.

#### **📌 Що перевіряють:**

*Алгоритмічне мислення та здатність реалізувати базову I/O функціональність вручну.*

* * *

### **12 ❓ Питання:**

У `try (new BufferedReader(...) ...)` хто і як закриває вкладений `FileReader`? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Це питання про ланцюжок викликів `close()`.
>
> **Закривається лише `BufferedReader`. Але він, у свою чергу, закриває `FileReader`.**
>
> **Порядок:**
>
> 1. `try-with-resources` має посилання лише на **зовнішню обгортку** — `BufferedReader`.
>
> 2. Наприкінці блоку `try`, JVM викликає **`bufferedReader.close()`**.
>
> 3. Реалізація методу `BufferedReader.close()` спроектована так, що вона гонитви (race condition)**.
>
> **Наслідки:**
>
> * **Втрата або дублювання даних:** Два потоки можуть прочитати той самий рядок, або один може "перестрибнути" через дані, які збирався прочитати інший.
> * **Пошкодження внутрішнього буфера:** Внутрішній стан `BufferedReader` (позиція в буфері, лічильник символів) може стати непослідовним.
>
> **Як працювати з ним у багатопотоковому середовищі:**
>
> 1. **Кожен потік створює свій власний екземпляр `BufferedReader`** для читання з файлу. Це найпростіший і найкращий підхід, якщо це можливо.
>
> 2. **Використовувати зовнішню синхронізацію**, якщо потрібно, щоб потоки читали з одного **спочатку викликає `close()` на вкладеному `Reader`**, який був переданий у його конструктор (у цьому випадку, на екземплярі `FileReader`).
>
> 4. Потім `BufferedReader` виконує свою власну логіку очищення (наприклад, обнуляє свій внутрішній буфер).
>
> Отже, завдяки **патерну "Декоратор"**, вам потрібно піклуватися лише про закриття **найбільш зовнішнього** потоку, а він вже "ланцюжком" закриє всі внутрішні.
>
> Спроба закрити `FileReader` вручну після `try-with-resources` є зайвою і може навіть призвести до помилки, якщо він вже був закритий.

#### **📌 Що перевіряють:**

*Глибоке знання патерну "Декоратор" у `java.io`.*

* * *

### **13 ❓ Питання:**

Що таке **idempotency** методу `close()`, і чи є `BufferedReader.close()` ідемпотентним? ⭐️⭐️⭐️

> #### **💬 Відповідь спільного потоку послідовно
>
>     `synchronized(mySharedReader) { line = mySharedReader.readLine(); }`
>     Це сильно знижує продуктивність і є ознакою складного дизайну.

#### **📌 Що перевіряють:**

*Знання аспектів багатопотоковості для стандартних класів та розуміння, коли потрібна додаткова синхронізація.*

* * *

### **13 ❓ Питання:**

Як методи `mark()` та `reset()` у `BufferedReader` дозволяють "повертатися" назад у потоці? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> `BufferedReader` підтримує механізм **"мітки та повернення"**, що дозволяє "запам'ятати" поточну позицію в потоці і пізніше повернутися до неї.
>
> * **`void mark(int readAheadLimit)`:**
>     *:**
>
> **Ідемпотентність** методу означає, що **повторні його виклики** мають той самий ефект, що й **один єдиний виклик**.
>
> **Для `close()` це означає:**
> Перший виклик `close()` закриває ресурс. Всі наступні виклики `close()` на цьому ж об'єкті **не повинні робити нічого і не повинні кидати виняток**.
>
> **Чи є `BufferedReader.close()` ідемпотентним?**
>
> **Так.** Більшість потоків вводу/виводу в `java.io`, включаючи `BufferedReader`, **реалізують ідемпотентний `close()`**.
>
> Вони зазвичай мають внутрішній прапор (наприклад,   Встановлює мітку на **поточній позиції** у буфері.
>
> * `readAheadLimit` — це максимальна кількість символів, які можна прочитати після встановлення мітки, зберігаючи можливість повернутися. Якщо ви прочитаєте більше, мітка може стати недійсною.
>
> * **`void reset()`:**
>   * **Повертає** потік до позиції останньої встановленої мітки.
>   * Кидає `IOException`, якщо мітка не була встановлена або стала недійсною.
>
> **Призначення:**
>
> Це корисно для **парсингу даних, коли потрібно "заглянути наперед"**. Ви можете прочитати частину даних, проаналізувати її `closed = false`). При першому виклику `close()` вони звільняють ресурси і встановлюють `closed = true`. При наступних викликах вони просто перевіряють цей прапор і, бачачи, що потік вже закрито, нічого не роблять.
>
> Це робить код більш надійним, оскільки випадковий подвійний виклик `close()` не призведе до помилки.

#### **📌 Що перевіряють:**

*Знання теоретичних концепцій, як ідемпотентність, та їх реалізації в стандартній бібліотеці.*

* * *

### **14 ❓ Питання:**

Як за допомогою `BufferedReader` і Stream API знайти перші 5 унікальних слів у великому текстовому файлі? ⭐️⭐️⭐️

> #### **💬 Відповід, і, якщо потрібно, повернутися назад і почати обробку знову, можливо, іншим способом
>
> **Приклад:**
>
> ```java
> reader.mark(100); // Запам'ятовуємо позицію
> String line1 = reader.readLine();
> if (line1.startsWith("...")) {
>     // ...
> } else {
>     reader.reset(); // Повертаємося до мітки, щоб прочитати цей рядок знову
>     // ... інша логіка ...
> }
> ```

#### **📌 Що перевіряють:**

*Знання просунутого API `BufferedReader` та патернів парсингу.*

* * *

### **14 ❓ Питання:**

Уявіть, що ви обгортаєте `StringReader` у `BufferedReader`. Чи має буферизація сенс у цьому випадку? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, буферизація тут практично не має сенсу іь:**
>
> Це завдання чудово демонструє потужність комбінування `BufferedReader.lines()` та `Stream API`.
>
> **Алгоритм:**
>
> 1. Отримати `Stream<String>` з рядків файлу за допомогою `lines()`.
> 2. Для кожного рядка, розбити його на слова. Це дасть потік потоків слів, тому використовуємо `flatMap`, щоб "розгладити" його в один потік слів.
> 3. Відфільтрувати порожні слова (якщо є).
> 4. Використовувати `distinct()` для отримання лише унікальних слів.
> 5. Використовувати `limit(5)` для обмеження кількості.
> 6. Зібрати результат у список.
>
> **Код:**
>
> ```java
> Path path = Paths.get("large є надлишковою.**
>
> *   **`StringReader`** — це `Reader`, який читає символи зі звичайного **рядка (`String`)**.
> *   Рядок вже **повністю знаходиться в оперативній пам'яті (RAM)**. Доступ до будь-якого його символу є дуже швидкою операцією.
>
> **Буферизація** у `BufferedReader` призначена для **оптимізації повільних операцій вводу/виводу** (читання з диска, мережі). Вона зменшує кількість звернень до повільного ресурсу.
>
> У випадку зі `StringReader`, "ресурс" (рядок) вже в пам'яті. Немає ніяких повільних I/O операцій, які потрібно оптимізувати.
>
> Обгортання `_file.txt");
> List<String> uniqueWords;
>
> try (BufferedReader reader = Files.newBufferedReader(path)) {
>     uniqueWords = reader.lines()
>                         .flatMap(line -> Arrays.stream(line.split("\\s+"))) // розбиваємо на слова
>                         .filter(word -> !word.isEmpty()) // видаляємо порожні
>                         .map(String::toLowerCase) // приводимо до нижнього регістру
>                         .distinct() // залишаємо унікальні
>                         .limit(5) // беремо перші 5
>                         .collect(Collectors.toList());
> } catch (IOException e) {
>     e.printStackTrace();
>     uniqueWords = Collections.emptyList();
> }
>
> System.out.println(uniqueWords);
> ```
>
> Цей підхід є **ефективним**, оскільки завдяки "лінивості" стрімів, читання файлу припиниться, як тільки буде знайдено 5 унікальних слів.

#### **📌 Що перевіряють:**

*Практичні навички роботиnew BufferedReader(new StringReader(...))` лише створить **зайвий об'єкт та додатковий шар копіювання даних** з рядка в буфер `BufferedReader`, що може навіть трохи **сповільнити** процес.
>
> Єдиним виправданням для цього може бути необхідність у методі `readLine()`, якщо його немає в самому `StringReader`, але зазвичай таку логіку легше реалізувати інакше.

#### **📌 Що перевіряють:**

*Глибоке розуміння того, **коли і чому** буферизація є зі Stream API, включаючи проміжні операції (`flatMap`, `distinct`, `limit`) та термінальну операцію (`collect`).*

* * *

### **15 ❓ Питання:**

Чи можна змінити розмір буфера для `BufferedReader` після його створення? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, не можна.**
>
> Розмір буфера для `BufferedReader` **встановлюється один раз** у момент його створення через конструктор:
> `new BufferedReader(Reader in, int sz)`
>
> Після створення об'єкта `BufferedReader` його внутрішній буфер (`char[]`) створюється з заданим розміром, і **не існує публічного API**, щоб змінити цей розмір або замінити масив буфера на ін корисною, а коли — ні.*

* * *

### **15 ❓ Питання:**

Що буде, якщо довжина одного рядка у файлі значно перевищує розмір буфера `BufferedReader`? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Метод `readLine()` впорається з цим коректно**, але це може вплинути на продуктивність.
>
> **Як `readLine()` обробляє дуже довгі рядки:**
>
> 1. Він починає читати дані в свій внутрішній буфер (наприклад, 8KB).
> 2. Він ітерує по буферу в пошуках символу нового рядка.
> 3. Якщо він доходить до кінця буфера, але **не знаходить** символ нового рядка, він розуміє, що ряший.
>
> **Чому так зроблено:**
>
> * **Простота та передбачуваність:** Дозволяє уникнути складної логіки динамічної зміни розміру буфера "на льоту", що могло б вплинути на продуктивність та ускладнити код.
> * **Інкапсуляція:** Розмір буфера є деталлю реалізації.
>
> Якщо вам потрібна динамічна зміна розміру, вам доведеться створити новий екземпляр `BufferedReader` з новим розміром.

#### **📌 Що перевіряють:**

*Глибокі знання API та його обмежень. Розуміння того, які властивості об'єктів є незмінними після створення.*
