---
layout: default
title: "Метод clone() — клонування об’єктів"
parent: "`equals()`, `hashCode()`, `clone()`"
grand_parent: "Java Core"
nav_order: 6
---

# Метод clone() — клонування об’єктів

* короткий опис: Метод `clone()` з класу `Object` дозволяє створити копію (клон) об'єкта. Для його роботи клас повинен реалізовувати маркерний інтерфейс `java.lang.Cloneable`, інакше викинеться `CloneNotSupportedException`. За замовчуванням виконує поверхневе копіювання.

* поняття: `clone()`, `Cloneable`, поверхневе копіювання, глибоке копіювання.

* приклади: `return (User) super.clone();`.

* ключові моменти: `clone()` за замовчуванням робить `shallow copy`. Потребує `Cloneable`. Часто вважається антипатерном.

* що важливо знати на співбесіді: Призначення `clone()`, shallow vs deep, чому часто вважається антипатерном.

### **✅ Офіційне визначення:**

Метод **`clone()`** — це метод класу **`Object`**, який дозволяє створити копію (клон) об’єкта. Щоб метод **`clone()`** працював, клас повинен реалізовувати інтерфейс **`java.lang.Cloneable`**, інакше буде згенеровано **`CloneNotSupportedException`**.

### **🧠 Простими словами:**

**`clone()`** — це спосіб сказати: **"Зроби мені ще одного такого ж".** Але Java не зробить цього, якщо ти сам не скажеш: **"Я дозволяю себе клонувати"** (через **`implements`** `Cloneable`). Без цього Java скаже: **"Я не можу це зробити"** і викине помилку.

---

## **📊 Види копіювання при клонуванні:**

| Тип копіювання | Опис |
| ----- | ----- |
| Поверхневе (**`shallow`**) | Копіюються лише значення полів. Для об'єктів — копіюється посилання |
| Глибоке (**`deep`**) | Копіюються і поля, і об’єкти, на які посилаються — рекурсивно |

---

## **Пояснення на пальцях (💡)**

* **`clone()`** копіює об'єкт, але **за замовчуванням** це поверхнева копія. Якщо у твоєму класі є поля-об'єкти — вони залишаться спільними в оригіналі та клоні.  
  **`Cloneable`** — маркерний інтерфейс: у нього немає методів, але без нього **`clone()`** не запрацює.
* Метод **`super.clone()`** викликає клонування на рівні Object, і якщо **`Cloneable`** не реалізовано — буде кинуто виняток.
* Якщо хочеш **справжню незалежну копію** — реалізуй глибоке клонування вручну: викликай **`clone()`** або **`new`** і для вкладених об’єктів.

---

## **Корисні приклади (🧪)**

```java
public class User implements Cloneable {
    private String name;
    private int age;

    @Override
    protected User clone() {
        try {
            return (User) super.clone(); // поверхневе копіювання
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException("Cannot create User clone", e);
        }
    }
}
```

**🧪 Приклад використання:**

```java
User u1 = new User("Max", 30);
User u2 = u1.clone();

System.out.println(u1 == u2);        // false (різні обʼєкти)
System.out.println(u1.equals(u2));   // залежить від equals()
```

---

## **Порівняння (⚖️)**

| Параметр | Значення |
| :---: | :---: |
| Реалізація **`Cloneable`** | Обов’язкова для роботи **`clone()`** |
| **`clone()`** у Object | **`protected`**, треба перевизначити |
| Тип копіювання за замовчуванням | поверхневе |
| Глибоке копіювання | треба реалізовувати вручну |
| Альтернатива **`clone()`** | конструктор копіювання, **`builder pattern`** |

---

## **🧠 Мнемоніка для запам’ятовування:**

🧬 **`clone()`** \= **C**reate **L**ogical **O**bject **N**ew **E**xact

* **`C`** — клас повинен реалізувати **`Cloneable`**
* **`L`** — логічно той самий
* **`O`** — об'єкт новий
* **`N`** — не забудь перевизначити **`clone()`**
* **`E`** — експліцитно викликай **`super.clone()`**

---

## **🟩 Підсумок:**

Метод **`clone()`** дозволяє створювати копії обʼєктів у Java. Але за замовчуванням він виконує **поверхневе копіювання**, і для його використання потрібно реалізувати інтерфейс **`Cloneable`**. Це досить старий підхід, тому в сучасному коді часто рекомендується використовувати **конструктори копіювання** або **Builder pattern** як безпечнішу альтернативу.

---

### **🔗 Додаткові джерела:**

* [**Java Cloneable Interface — Oracle Docs**](https://docs.oracle.com/javase/8/docs/api/java/lang/Cloneable.html)

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке метод `clone()` і яка його основна мета в Java?

> #### **💬 Відповідь:**
>
> Метод `protected native Object clone()` з класу `java.lang.Object` призначений для створення та повернення **копії (клону)** об'єкта.
>
> **Основна мета** — створити новий об'єкт з таким самим станом, як у вихідного об'єкта, але з іншим посиланням. Тобто `x.clone() != x` буде `true`, тоді як `x.clone().equals(x)` зазвичай очікується як `true`.
>
> Для того, щоб клонування було можливим, клас об'єкта повинен реалізовувати маркерний інтерфейс `Cloneable`. В іншому випадку виклик `super.clone()` призведе до винятку `CloneNotSupportedException`.

#### **📝 Аналогія:**

Це як зробити ксерокопію документа. Ви отримуєте новий аркуш паперу (новий об'єкт у пам'яті), який має той самий вміст, що й оригінал. Але це два різні, незалежні аркуші.

#### **📌 Що перевіряють:**

*Розуміння базового призначення методу `clone()` та його основної вимоги — реалізації інтерфейсу `Cloneable`.*

* * *

### **2 ❓ Питання:**

У чому різниця між поверхневим (`shallow`) та глибоким (`deep`) копіюванням?

> #### **💬 Відповідь:**
>
> Це ключове поняття у клонуванні, яке визначає, наскільки незалежною буде копія.
>
> * **Поверхневе копіювання (Shallow Copy):**
>   * Це поведінка `clone()` за замовчуванням.
>   * Копіюються лише значення полів об'єкта. Якщо поле є примітивним типом (`int`, `boolean`), копіюється його значення.
>   * Якщо поле є посиланням на інший об'єкт, копіюється **тільки посилання**, а не сам об'єкт. В результаті, і оригінал, і клон будуть посилатися на **один і той самий вкладений об'єкт**.
>
> * **Глибоке копіювання (Deep Copy):**
>   * Потребує ручної реалізації.
>   * Копіюються не тільки поля, але й **всі об'єкти, на які вони посилаються**, рекурсивно.
>   * В результаті оригінал та клон стають повністю незалежними один від одного. Зміна вкладеного об'єкта в клоні не вплине на оригінал.

#### **📝 Коментар:**

Нерозуміння цієї різниці є найпоширенішою причиною помилок при роботі з `clone()`. Зміна "спільного" об'єкта призводить до несподіваної зміни стану в оригіналі або клоні.

#### **📌 Що перевіряють:**

*Розуміння фундаментальної різниці між поверхневим та глибоким копіюванням та наслідків кожного підходу.*

* * *

### **3 ❓ Питання:**

Яку роль відіграє маркерний інтерфейс `Cloneable`?

> #### **💬 Відповідь:**
>
> Інтерфейс `java.lang.Cloneable` є **маркерним**, тобто він не містить жодних методів для реалізації. Його єдина мета — повідомити JVM, що об'єкти цього класу **можна** клонувати.
>
> Він змінює поведінку `native`-методу `Object.clone()`.
>
> * Якщо клас реалізує `Cloneable`, виклик `Object.clone()` створює побітову копію об'єкта (поверхневе копіювання).
> * Якщо клас **не** реалізує `Cloneable`, виклик `Object.clone()` кине виняток `CloneNotSupportedException`.
>
> Це свого роду "дозвіл" або "опція", яку розробник свідомо вмикає для свого класу.

#### **📝 Коментар:**</h4>

Дизайн `Cloneable` вважається невдалим. Маркерний інтерфейс не повинен змінювати поведінку методів суперкласу. Це одна з причин, чому `clone()` вважають проблемним механізмом.

#### **📌 Що перевіряють:**

*Розуміння концепції маркерних інтерфейсів та специфічної ролі `Cloneable` як умови для роботи `Object.clone()`.*

* * *

### **4 ❓ Питання:**

Напишіть канонічний приклад реалізації `clone()` для простого класу.

> #### **💬 Відповідь:**
>
> Правильна реалізація `clone()` вимагає виконання кількох кроків:
>
> 1. Клас має реалізувати інтерфейс `Cloneable`.
> 2. Перевизначити `protected` метод `clone()` з `Object`, зробивши його `public`.
> 3. Всередині методу викликати `super.clone()`.
> 4. Обробити `CloneNotSupportedException` (хоча для `Cloneable`-класу він ніколи не виникне). Зазвичай його загортають у неперевіряємий виняток.
> 5. Привести тип результату `super.clone()` до поточного класу.

#### **📝 Приклад (поверхневе копіювання):**

```java
public class User implements Cloneable {
    private String name;
    private int age;

    // Конструктор, геттери...

    @Override
    public User clone() { // Зверніть увагу: метод став public
        try {
            // Виклик clone() з класу Object, який виконує поверхневе копіювання
            return (User) super.clone();
        } catch (CloneNotSupportedException e) {
            // Цей виняток не виникне, бо клас реалізує Cloneable,
            // але компілятор вимагає його обробити.
            throw new AssertionError("Клонування не підтримується, хоча клас реалізує Cloneable", e);
        }
    }
}
```

#### **📌 Що перевіряють:**

*Практичні навички реалізації `clone()` згідно з прийнятими конвенціями.*

* * *

### **5 ❓ Питання:**

Чому `clone()` в класі `Object` оголошений як `protected`?

> #### **💬 Відповідь:**
>
> Метод `clone()` в `Object` оголошений як `protected`, щоб **заборонити довільне клонування** будь-якого об'єкта.
>
> Це дизайнерське рішення змушує розробника **свідомо** приймати рішення про те, чи можна клонувати його клас. Щоб зробити об'єкт клонованим для зовнішнього світу, розробник повинен:
>
> 1. Реалізувати `Cloneable`.
> 2. Перевизначити `clone()` і змінити його модифікатор доступу на `public`.
>
> Якби `clone()` був `public` в `Object`, будь-який об'єкт можна було б спробувати клонувати, що могло б призвести до непередбачуваних наслідків для класів, не розрахованих на це. `protected` доступ служить своєрідним захисним бар'єром.

#### **📌 Що перевіряють:**

*Розуміння принципів дизайну Java API та ролі модифікаторів доступу у забезпеченні інкапсуляції та безпеки.*

* * *

### **6 ❓ Питання:**

Який зв'язок між результатом `clone()` та методами `==` та `equals()`?

> #### **💬 Відповідь:**
>
> Для об'єкта `x` та його клону `y = x.clone()`, зазвичай очікується така поведінка:
>
> * **`x == y`** повинно повертати **`false`**.
>     Метод `clone()` створює **новий** об'єкт, тому посилання на оригінал та клон будуть різними.
>
> * **`x.equals(y)`** повинно повертати **`true`**.
>     Це не є суворою вимогою контракту `clone()`, але є логічним очікуванням. Клон має бути логічно еквівалентним оригіналу. Якщо це не так, то сам сенс клонування втрачається.
>
> * **`x.getClass() == y.getClass()`** повинно повертати **`true`**.
>     Клон має бути того ж самого класу, що і оригінал.
>
> По суті, клонування створює новий екземпляр, але з тим самим логічним станом.

#### **📌 Що перевіряють:**

*Розуміння відмінностей між ідентичністю (посиланням) та логічною рівністю об'єкта, та як клонування впливає на них.*

* * *

### **7 ❓ Питання:**

Чому метод `clone()` і інтерфейс `Cloneable` часто вважаються "зламаними" або антипатерном? ⭐️

> #### **💬 Відповідь:**
>
> На це є кілька вагомих причин, описаних Джошуа Блохом у книзі "Effective Java":
>
> 1. **"Зламаний" інтерфейс `Cloneable`:** Він є маркерним, але при цьому змінює поведінку `protected`-методу `Object.clone()`. Це нетипово і порушує основну ідею інтерфейсів як контрактів поведінки.
>
> 2. **Немає конструкторів:** `clone()` створює об'єкт без виклику конструктора. Це "магічний" процес, який може обійти інваріанти, встановлені в конструкторах, і призводить до проблем з `final`-полями.
>
> 3. **Обов'язкова обробка `CloneNotSupportedException`:** Цей перевіряємий виняток потрібно обробляти, хоча для `Cloneable`-класу він ніколи не буде кинутий. Це додає непотрібного шаблонного коду.
>
> 4. **Складність глибокого копіювання:** За замовчуванням `clone()` є поверхневим. Реалізація глибокого копіювання є складною, схильною до помилок і вимагає рекурсивного клонування всіх вкладених об'єктів.
>
> 5. **Проблеми з `final`-полями:** `clone()` не може змінити `final`-поля, тому якщо таке поле посилається на мутабельний об'єкт, ви не зможете його глибоко скопіювати, і оригінал та клон будуть розділяти спільний стан.
>
> Через ці проблеми в сучасному коді перевага надається альтернативам.

#### **📌 Що перевіряють:**

*Критичне мислення та розуміння недоліків стандартних механізмів Java. Знання "best practices", популяризованих авторитетними джерелами.*

* * *

### **8 ❓ Питання:**

Наведіть приклад реалізації глибокого копіювання (`deep copy`). ⭐️

> #### **💬 Відповідь:**
>
> Глибоке копіювання вимагає спочатку виконати поверхневе копіювання, а потім вручну клонувати всі мутабельні поля.
>
> Припустимо, у нас є клас `Department`, який є мутабельним, і клас `Employee`, що містить посилання на нього.
>
> ```java
> class Department implements Cloneable {
>     public String name;
>     @Override public Department clone() { /* ... */ }
> }
>
> class Employee implements Cloneable {
>     private String name;
>     private Department department;
>
>     @Override
>     public Employee clone() {
>         try {
>             // 1. Починаємо з поверхневого копіювання
>             Employee cloned = (Employee) super.clone();
>
>             // 2. Вручну клонуємо мутабельне поле
>             cloned.department = this.department.clone();
>
>             return cloned;
>         } catch (CloneNotSupportedException e) {
>             throw new AssertionError();
>         }
>     }
> }
> ```> У цьому прикладі ми спочатку створюємо клон `Employee`, а потім замінюємо його поле `department` на клон оригінального департаменту. Тепер зміна департаменту у клоні не вплине на оригінал.

#### **📌 Що перевіряють:**

*Практичні навички реалізації глибокого клонування та розуміння необхідності рекурсивного копіювання мутабельних полів.*

* * *

### **9 ❓ Питання:**

Які є альтернативи механізму `clone()` і чому вони вважаються кращими? ⭐️

> #### **💬 Відповідь:**
>
> Двома найпоширенішими та рекомендованими альтернативами є:
>
> 1. **Конструктор копіювання (Copy Constructor):**
>     * Це конструктор, який приймає на вхід об'єкт того ж класу і копіює його поля.
>     * `public User(User other) { this.name = other.name; ... }`
>
> 2. **Статичний фабричний метод копіювання (Copy Factory):**
>     * Це статичний метод, який робить те саме, що і конструктор копіювання, але має більш гнучку назву.
>     * `public static User newInstance(User other) { return new User(other); }`
>
> **Чому вони кращі?**
>
> * **Простота та ясність:** Код є простим і зрозумілим, без `try-catch` та магії.
> * **Безпека типів:** Немає потреби у приведенні типів.
> * **Немає `Cloneable`:** Немає зв'язку з проблемним інтерфейсом.
> * **Робота з `final`:** Вони викликають конструктор, тому можуть ініціалізувати `final`-поля.
> * **Гнучкість:** Конструктор копіювання може приймати на вхід об'єкт іншого, сумісного типу (наприклад, інтерфейс), що робить його більш гнучким.

#### **📌 Що перевіряють:**

*Знання сучасних патернів проектування та здатність вибирати більш надійні та чисті рішення замість застарілих механізмів.*

* * *

### **10 ❓ Питання:**

Як `clone()` взаємодіє з `final` полями? ⭐️

> #### **💬 Відповідь:**
>
> Взаємодія є дуже проблематичною і це одна з головних причин уникати `clone()`.
>
> * Метод `super.clone()` створює об'єкт, копіюючи біти, **без виклику конструктора**.
> * `final`-поля можуть бути ініціалізовані лише один раз: або при оголошенні, або в конструкторі.
>
> **Наслідки:**
>
> 1. Оскільки конструктор не викликається, ви **не можете змінити значення `final`-поля** всередині методу `clone()` після виклику `super.clone()`.
> 2. `super.clone()` просто скопіює значення `final`-поля з оригіналу.
>
> **Проблема:** Якщо у вас є `final`-поле, що посилається на **мутабельний** об'єкт (наприклад, `private final List<String> items`), то після клонування і оригінал, і клон будуть посилатися на той самий екземпляр `List`. І ви **не зможете** "виправити" це в методі `clone()`, присвоївши клону новий `List`, тому що поле є `final`.
>
> **Висновок:** Для класів, що містять `final`-поля, які є посиланнями на мутабельні об'єкти, механізм `clone()` є непридатним для реалізації глибокого копіювання.

#### **📌 Що перевіряють:**

*Розуміння глибоких обмежень механізму `clone()` і його несумісності з деякими ключовими можливостями мови, як-от `final`.*

* * *

### **11 ❓ Питання:**

Як відбувається клонування масивів і який тип копіювання при цьому виконується? ⭐️

> #### **💬 Відповідь:**
>
> Масиви є особливими об'єктами в Java і мають вбудовану підтримку клонування.
>
> * Усі масиви автоматично реалізують інтерфейс `Cloneable`.
> * Метод `clone()` для масивів є `public`, тому його можна викликати напряму.
>
> Найважливіша деталь: **клонування масиву завжди виконує поверхневе (`shallow`) копіювання**.
>
> * Створюється новий масив такого ж розміру і типу.
> * Якщо це масив примітивів (`int[]`, `char[]`), то копіюються значення.
> * Якщо це масив об'єктів (`String[]`, `User[]`), то копіюються **посилання** на ці об'єкти.
>
> **Приклад:**
>
> ```java
> User[] original = { new User("Alice"), new User("Bob") };
> User[] cloned = original.clone();
>
> // cloned != original -> true (це різні масиви)
> // cloned[0] == original[0] -> true (але вони посилаються на ті ж самі об'єкти User)
> ```
>
> Зміна стану `cloned[0]` (наприклад, `cloned[0].setName("Alicia")`) призведе до зміни `original[0]`.

#### **📌 Що перевіряють:**

*Знання специфічної поведінки масивів та уважність до деталей реалізації `clone()` для них.*

* * *

### **12 ❓ Питання:**

Чи викликається конструктор при клонуванні об'єкта? Чому? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Ні, **конструктор не викликається**.
>
> Це одна з найважливіших і найбільш "небезпечних" особливостей механізму `clone()`. Метод `Object.clone()` є `native`. Це означає, що JVM створює новий об'єкт, просто **копіюючи байти пам'яті** з вихідного об'єкта в нову область пам'яті.
>
> Це "екстралінгвістичний" спосіб створення об'єкта, який відбувається поза звичайними правилами мови Java, що вимагають ініціалізації через конструктор.
>
> **Наслідки:**
>
> * Будь-яка логіка, що міститься в конструкторі (валідація, ініціалізація `transient`-полів, реєстрація в якихось сервісах), не буде виконана для клонованого об'єкта.
> * Це робить механізм `clone()` несумісним з імутабельними об'єктами, `final`-поля яких мають бути ініціалізовані саме в конструкторі.
> * Це може призвести до створення об'єктів у невалідному стані, якщо не подбати про всю необхідну логіку всередині самого методу `clone()`.

#### **📌 Що перевіряють:**

*Глибоке розуміння життєвого циклу об'єкта та відмінностей між створенням через `new` та створенням через `clone()`. Це питання відсіває кандидатів, які знають тему поверхнево.*

* * *

### **13 ❓ Питання:**

Як `clone()` має працювати в ієрархії успадкування? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Правильна реалізація `clone()` в ієрархії успадкування має слідувати **ланцюжку викликів `super.clone()`**.
>
> Кожен клас в ієрархії, який додає власні мутабельні поля, що потребують глибокого копіювання, відповідає за клонування **тільки цих полів**.
>
> **Правильний алгоритм для класу-нащадка:**
>
> 1. Викликати `super.clone()`, щоб отримати клон, створений батьківським класом. На цьому етапі всі поля батька вже мають бути правильно скопійовані (глибоко, якщо потрібно).
> 2. Вручну виконати глибоке копіювання для тих мутабельних полів, які були оголошені **в самому класі-нащадку**.
>
> ```java
> public class SubClass extends SuperClass implements Cloneable {
>     private AnotherMutableField subField;
>
>     @Override
>     public SubClass clone() {
>         SubClass cloned = (SubClass) super.clone(); // Батько подбав про свої поля
>         cloned.subField = this.subField.clone(); // Ми дбаємо тільки про свої
>         return cloned;
>     }
> }
> ```
>
> Якщо будь-який клас у цьому ланцюжку не реалізує `Cloneable` або не викличе `super.clone()`, механізм зламається. Це робить `clone()` дуже крихким при зміні ієрархії класів.

#### **📌 Що перевіряють:**

*Розуміння того, як `super` та успадкування працюють у контексті `clone()`, та усвідомлення крихкості цього механізму.*

* * *

### **14 ❓ Питання:**

Чи є метод `clone()` потокобезпечним (thread-safe)? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Ні, сам по собі `clone()` **не є потокобезпечним**.
>
> `Object.clone()` виконує побітову копію об'єкта. Якщо в цей час інший потік змінює стан цього об'єкта, можлива ситуація "розірваного читання" (**torn read**). Це означає, що клонований об'єкт може отримати частково старий і частково новий стан, що призведе до створення об'єкта в некоректному (неконсистентному) стані.
>
> **Приклад:**
>
> * Потік 1 починає клонувати об'єкт, що містить поля `a` і `b`.
> * Він копіює значення поля `a`.
> * У цей момент Потік 2 змінює поля `a` і `b`.
> * Потік 1 продовжує клонування і копіює **нове** значення поля `b`.
> * В результаті клон має **старе** `a` і **нове** `b`, що є невалідною комбінацією.
>
> **Рішення:**
> Щоб безпечно клонувати об'єкт у багатопотоковому середовищі, необхідно забезпечити синхронізацію. Наприклад, обернути виклик `clone()` у блок `synchronized` на об'єкті, що клонується, або використовувати інші механізми блокування (`Lock`).
>
> ```java
> synchronized (original) {
>     cloned = original.clone();
> }
> ```

#### **📌 Що перевіряють:**

*Розуміння проблем, пов'язаних із конкурентним доступом. Здатність застосовувати знання з багатопотоковості до інших аспектів мови, таких як клонування.*

* * *

### **15 ❓ Питання:**

Чи можна реалізувати `clone()` для класу Singleton? Що станеться? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Реалізація `clone()` для Singleton'а є **прямим порушенням** самого патерну Singleton.
>
> **Патерн Singleton** гарантує, що у класа існує **лише один** екземпляр. Метод `clone()` за своїм визначенням створює **новий** екземпляр.
>
> **Що станеться:**
>
> Якщо ви реалізуєте `Cloneable` та `clone()` для Singleton, будь-хто зможе викликати `Singleton.getInstance().clone()` і отримати другий, третій, і так далі екземпляр Singleton'а, що руйнує всю ідею патерну.
>
> **Як правильно захистити Singleton від клонування:**
>
> Є два підходи:
>
> 1. **Не реалізовувати `Cloneable`**. Це найпростіший шлях. Спроба викликати `clone` через рефлексію все одно призведе до `CloneNotSupportedException`.
> 2. **Перевизначити `clone()` і кинути виняток.** Якщо ваш суперклас є клонованим і ви не можете уникнути цього, ви можете перевизначити `clone`, щоб він не створював новий об'єкт.
>
>     ```java
>     @Override
>     protected final Object clone() throws CloneNotSupportedException {
>         // Повертаємо той самий екземпляр
>         // return INSTANCE;
>         // Або, що краще, забороняємо клонування
>         throw new CloneNotSupportedException("Клонування Singleton'а заборонено");
>     }
>     ```
>
> Таким чином, ви явно захищаєте інваріант вашого класу.

#### **📌 Що перевіряють:**

*Вміння думати про те, як різні патерни проектування та механізми мови взаємодіють між собою, і як захистити інваріанти класу від їх порушення.*
