---
layout: default
title: "Правила перевизначення equals()"
parent: "`equals()`, `hashCode()`, `clone()`"
grand_parent: "Java Core"
nav_order: 2
---

# Правила перевизначення equals()

* короткий опис: Правильне перевизначення `equals()` вимагає дотримання 5 обов'язкових правил контракту `equals()`: рефлексивність, симетричність, транзитивність, консистентність, та правильне порівняння з `null`.

* поняття: Контракт `equals()`, рефлексивність, симетричність, транзитивність, консистентність, `null`-перевірка.

* приклади: `if (this == obj) return true;`, `Objects.equals(name, other.name);` (для безпечного порівняння полів).

* ключові моменти: Ці правила гарантують передбачувану та послідовну поведінку, що критично для роботи хеш-колекцій.

* що важливо знати на співбесіді: Назвати та пояснити 5 правил, `getClass()` vs `instanceof`.

### **✅ Офіційне визначення:**

Правильне перевизначення методу **`equals(Object obj)`** передбачає дотримання **контракту equals**, описаного в документації Java. Метод повинен бути **`рефлексивним`**, **`симетричним`**, **`транзитивним`**, **`консистентним`**, а також правильно працювати при порівнянні з **`null`**

### **🧠 Простими словами:**

Java очікує, що метод **`equals()`** працює логічно і передбачувано. Якщо ти кажеш, що обʼєкт рівний іншому, то маєш бути впевнений, що це завжди так: і сьогодні, і завтра, і в будь-якому контексті. Інакше колекції типу **`HashSet`**, **`Map`** і просто логіка програми почне “плисти”

---

## **Основні види  / категорії / типи**

#### 📊 5 правил, які **обов’язково** мають виконуватись

| Правило | Опис |
| ----- | ----- |
| **Рефлексивність** | **`x.equals(x)`** має повертати **`true`** |
| **Симетричність** | Якщо **`x.equals(y)`** -> **`true`**, то **`y.equals(x)`** теж **`true`** |
| **Транзитивність** | Якщо **`x.equals(y)`** і **`y.equals(z)`** -> **`x.equals(z)`** |
| **Консистентність** | Якщо поля об’єктів не змінювались -> результат **`equals()`** не змінюється |
| **Порівняння з `null`** | **`x.equals(null)`** завжди має повертати **`false`** |

---

## **Пояснення на пальцях (💡)**

* Уяви, що **`equals()`** — це договір. Він має бути чесним і логічним.
* Якщо обʼєкт рівний сам собі — це нормально (**`рефлексивність`**).
* Якщо я сказав, що ти мені рівний, то і ти маєш так сказати про мене (**`симетричність`**).
* Якщо я рівний Петі, а Петя рівний Васі — значить я рівний Васі (**`транзитивність`**).
* Якщо я тебе порівнюю сьогодні й завтра, і нічого не змінюється — результат має бути однаковим (**`консистентність`**).
* **`null`** — завжди не рівне будь-якому обʼєкту.

---

## **Корисні приклади (🧪)**

```java
public class User {
    private String name;
    private int age;

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;                      // Рефлексивність
        if (obj == null || getClass() != obj.getClass())   // Порівняння з null + Тип
            return false;
        User other = (User) obj;
        return age == other.age && Objects.equals(name, other.name); // Безпечне порівняння
    }
}
```

**Пояснення**:

**`this == obj`** — короткий шлях: якщо посилання однакове, обʼєкти точно рівні

**`obj == null`** або клас інший — одразу false

**`Objects.equals(a, b)`** — не викликає NullPointerException, якщо name \== null

---

## **Порівняння (⚖️)**

| Перевірка | Пояснення |
| :---: | :---: |
| **`this == obj`** | Той самий об'єкт у пам'яті (швидка перевірка) |
| **`obj == null`** | Null не дорівнює нічому |
| **`getClass() != obj.getClass()`** | Перевірка типу класу |
| **`Objects.equals(a, b)`** | Null-safe перевірка значень |

---

## **🧠 Мнемоніка для запам’ятовування:**

**Р-С-Т-К-N:**

* **Р**ефлексивність
* **С**иметричність
* **Т**ранзитивність
* **К**онсистентність
* **N**ull check

---

## **🟩 Підсумок:**

Метод **`equals()`** має перевизначатися чітко й грамотно. Дотримання 5 правил — обовʼязкова вимога для коректної логіки програми, особливо при роботі з колекціями. Використовуй **`Objects.equals()`** для зручного і безпечного порівняння, а також пильнуй, щоб **`hashCode()`** відповідав **`equals()`**.

### **🔗 Додаткові джерела:**

* [**Офіційний Java контракт equals**](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-)

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке контракт методу `equals()` і чому він такий важливий?

> #### **💬 Відповідь:**
>
> **Контракт `equals()`** — це набір з п'яти правил, описаних в офіційній документації `java.lang.Object`, яких необхідно суворо дотримуватися при перевизначенні цього методу. Ці правила гарантують, що поняття "логічної рівності" буде поводитися передбачувано та послідовно в усій Java-екосистемі.
>
> **Чому він важливий?**
> Тому що безліч стандартних класів, особливо **колекції (`HashSet`, `HashMap`)**, повністю покладаються на цей контракт. Якщо ви порушите хоча б одне з правил, поведінка цих колекцій стане хаотичною та непередбачуваною. Наприклад, ви не зможете знайти в `HashSet` об'єкт, який ви щойно туди додали, або `HashMap` поверне `null` для ключа, який точно є в мапі.

#### **📝 Коментар:**

Дотримання контракту — це не рекомендація, а вимога. Ігнорування цих правил призводить до складних для відстеження помилок, які проявляються не в самому методі `equals()`, а в абсолютно інших частинах програми.

#### **📌 Що перевіряють:**

*Розуміння того, що правила `equals()` є не просто формальністю, а фундаментальною основою для коректної роботи багатьох механізмів Java, зокрема, колекцій.*

* * *

### **2 ❓ Питання:**

Назвіть та коротко поясніть усі п'ять правил контракту `equals()`.

> #### **💬 Відповідь:**
>
> 1. **Рефлексивність (Reflexivity):** Об'єкт завжди рівний сам собі.
>     * `x.equals(x)` має завжди повертати `true`.
>
> 2. **Симетричність (Symmetry):** Якщо `A` рівне `B`, то і `B` має бути рівним `A`.
>     * `x.equals(y)` повертає `true` тоді й тільки тоді, коли `y.equals(x)` повертає `true`.
>
> 3. **Транзитивність (Transitivity):** Якщо `A` рівне `B`, а `B` рівне `C`, то `A` має бути рівним `C`.
>     * Якщо `x.equals(y)` та `y.equals(z)` є `true`, то `x.equals(z)` також має бути `true`.
>
> 4. **Консистентність (Consistency):** Повторні порівняння двох об'єктів дають однаковий результат, якщо їхні поля не змінювались.
>     * Багаторазовий виклик `x.equals(y)` повертає те саме значення, доки дані в `x` або `y` не зміняться.
>
> 5. **Порівняння з `null`:** Жоден об'єкт не може бути рівним `null`.
>     * `x.equals(null)` завжди має повертати `false`.

#### **📝 Мнемоніка:**

Для запам'ятовування правил можна використовувати акронім **RSTCN**:

* **R** - Reflexive
* **S** - Symmetric
* **T** - Transitive
* **C** - Consistent
* **N** - Null-check

#### **📌 Що перевіряють:**

*Чітке знання всіх п'яти правил та здатність їх лаконічно пояснити. Це одне з найпоширеніших теоретичних питань на співбесідах з Java Core.*

* * *

### **3 ❓ Питання:**

Що таке рефлексивність і як її можна випадково порушити?

> #### **💬 Відповідь:**
>
> **Рефлексивність** — це найпростіше правило, яке стверджує, що будь-який об'єкт має бути рівним самому собі (`x.equals(x)` повинно повертати `true`).
>
> Порушити це правило випадково досить складно, але теоретично можливо, якщо логіка порівняння залежить від якогось зовнішнього або випадкового фактора, що є грубою помилкою дизайну.
>
> **Приклад порушення (дуже надуманий):**
>
> ```java
> public class UnstableObject {
>     @Override
>     public boolean equals(Object obj) {
>         // Порушення: результат залежить від зовнішнього фактора
>         return Math.random() > 0.5;
>     }
> }
> ```
>
> У цьому прикладі `obj.equals(obj)` може повернути `false`. Хоча такий код безглуздий, він ілюструє суть порушення. У реальному житті це правило майже ніколи не порушується, якщо логіка залежить тільки від полів об'єктів `this` та `obj`.

#### **📌 Що перевіряють:**

*Повноту знань контракту. Хоча це правило рідко порушується на практиці, кандидат має знати про його існування.*

* * *

### **4 ❓ Питання:**

Поясніть на прикладі, як можна порушити правило симетричності.

> #### **💬 Відповідь:**
>
> **Симетричність** вимагає, щоб `x.equals(y)` та `y.equals(x)` давали однаковий результат. Найчастіше це правило порушується при некоректній роботі з успадкуванням та використанні `instanceof`.
>
> Розглянемо приклад: клас `Point` і його нащадок `ColorPoint`.
>
> ```java
> class Point {
>     final int x, y;
>     // ... конструктор ...
>
>     @Override
>     public boolean equals(Object obj) {
>         if (!(obj instanceof Point)) return false;
>         Point p = (Point) obj;
>         return p.x == x && p.y == y;
>     }
> }
>
> class ColorPoint extends Point {
>     final Color color;
>     // ... конструктор ...
>
>     @Override
>     public boolean equals(Object obj) {
>         if (!(obj instanceof ColorPoint)) return false;
>         // Порівнює x, y ТА колір
>         return super.equals(obj) && ((ColorPoint) obj).color == color;
>     }
> }
> ```
>
> **Порушення симетричності:**
>
> ```java
> Point p = new Point(1, 2);
> ColorPoint cp = new ColorPoint(1, 2, Color.RED);
>
> // p.equals(cp) -> true (бо cp є instanceof Point, а x, y збігаються)
> // cp.equals(p) -> false (бо p не є instanceof ColorPoint)
> ```
>
> В результаті `p.equals(cp) != cp.equals(p)`, що порушує контракт і призведе до хаосу в колекціях. Саме тому для перевірки типів рекомендується використовувати `getClass() == obj.getClass()`.

#### **📌 Що перевіряють:**

*Глибоке розуміння підводних каменів успадкування при перевизначенні `equals`. Це питання перевіряє здатність аналізувати складні взаємодії між класами.*

* * *

### **5 ❓ Питання:**

Як можна порушити правило транзитивності? Наведіть приклад.

> #### **💬 Відповідь:**
>
> **Транзитивність** вимагає, щоб якщо `x.equals(y)` та `y.equals(z)`, то і `x.equals(z)`. Це правило також часто порушується при некоректному успадкуванні та змішуванні логіки порівняння.
>
> Розглянемо той самий приклад, але змінимо `equals` в `ColorPoint` у спробі "виправити" симетричність:
>
> ```java
> class ColorPoint extends Point {
>     // ...
>     @Override
>     public boolean equals(Object obj) {
>         if (!(obj instanceof Point)) return false;
>
>         // Якщо це ColorPoint, порівнюємо колір
>         if (obj instanceof ColorPoint) {
>             return super.equals(obj) && ((ColorPoint) obj).color == color;
>         }
>
>         // Якщо це просто Point, порівнюємо тільки координати (ігноруємо колір)
>         return super.equals(obj);
>     }
> }
> ```
>
> **Порушення транзитивності:**
>
> ```java
> ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
> Point p2 = new Point(1, 2);
> ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
>
> // p1.equals(p2) -> true (p2 - це Point, порівнюються тільки x, y)
> // p2.equals(p3) -> true (p2 - це Point, порівнюється з p3 як з Point'ом, колір ігнорується)
>
> // Але p1.equals(p3) -> false (бо p1 та p3 є ColorPoint і їхні кольори різні)
> ```
>
> Ми отримали ситуацію, де `p1` рівний `p2`, `p2` рівний `p3`, але `p1` **не** рівний `p3`. Транзитивність порушена.

#### **📝 Коментар:**

Це демонструє, чому "композиція краща за успадкування". Якщо б `Point` був полем у `ColorPoint`, а не батьком, цих проблем можна було б уникнути.

#### **📌 Що перевіряють:**

*Здатність проаналізувати ще більш складний сценарій і зрозуміти, чому спроби "виправити" симетричність за допомогою `instanceof` часто призводять до порушення транзитивності.*

* * *

### **6 ❓ Питання:**

Що таке консистентність і як її можна порушити?

> #### **💬 Відповідь:**
>
> **Консистентність** вимагає, щоб повторні виклики `x.equals(y)` повертали той самий результат, якщо інформація, що використовується для порівняння в об'єктах `x` та `y`, не змінювалася.
>
> Це правило порушується, якщо логіка `equals()` залежить від **нестабільних або зовнішніх ресурсів**.
>
> **Приклад порушення:**
>
> ```java
> import java.net.URL;
>
> public class UrlEquality {
>     private final URL url;
>     //...
>     @Override
>     public boolean equals(Object o) {
>         // НЕПРАВИЛЬНО! Результат залежить від мережі!
>         // Метод equals для URL намагається розрізнити IP-адреси,
>         // що може змінюватися залежно від DNS, мережі тощо.
>         return (o instanceof UrlEquality) && url.equals(((UrlEquality) o).url);
>     }
> }
> ```
>
> Стандартний метод `java.net.URL.equals()` виконує мережевий запит для визначення IP-адреси. Результат такого порівняння може змінюватися залежно від стану мережі або налаштувань DNS, що прямо порушує консистентність.
>
> **Правильне рішення:** `equals()` повинен залежати лише від **внутрішніх, стабільних полів** об'єкта. Для порівняння URL слід було б порівнювати їхнє рядкове представлення.

#### **📌 Що перевіряють:**

*Розуміння того, що логіка `equals()` має бути чистою функцією від стану об'єктів і не повинна мати побічних ефектів або залежати від зовнішнього середовища.*

* * *

### **7 ❓ Питання:**

Чому `x.equals(null)` завжди має повертати `false`?

> #### **💬 Відповідь:**
>
> Це правило є логічним наслідком самої природи `equals()` — методу для порівняння **об'єктів**. `null` не є об'єктом, це спеціальне значення, яке вказує на відсутність посилання на об'єкт.
>
> Об'єкт не може бути логічно еквівалентним "нічому".
>
> Правильна реалізація `equals()` завжди починається з перевірок, одна з яких має бути перевірка на `null`. Найчастіше це робиться так: `if (obj == null) return false;`. Це також захищає від `NullPointerException` при подальшому доступі до методів або полів `obj`.
>
> Якщо б `x.equals(null)` могло повернути `true`, це зламало б багато алгоритмів, наприклад, `List.remove(null)` працював би непередбачувано.

#### **📌 Що перевіряють:**

*Чітке розуміння семантики `null` в Java та його місця у логіці порівняння.*

* * *

### **8 ❓ Питання:**

Чому для порівняння об'єктних полів всередині `equals()` рекомендується використовувати `Objects.equals(a, b)`? ⭐️

> #### **💬 Відповідь:**
>
> `Objects.equals(a, b)` — це статичний утилітарний метод з `java.util.Objects`, який порівнює два об'єкти і є **`null-safe` (безпечним до `null`)**.
>
> Його реалізація виглядає приблизно так:
>
> ```java
> public static boolean equals(Object a, Object b) {
>     return (a == b) || (a != null && a.equals(b));
> }
> ```
>
> **Переваги:**
>
> 1. **Захист від `NullPointerException`**: Якщо написати `this.field.equals(other.field)`, і `this.field` виявиться `null`, ви отримаєте `NullPointerException`. `Objects.equals()` коректно обробляє цей випадок.
> 2. **Стислість і читабельність**: Він замінює громіздкі `if`-`else` перевірки на `null` одним лаконічним викликом.
>
> Використання `Objects.equals()` є сучасною найкращою практикою для порівняння полів-об'єктів.

#### **📌 Що перевіряють:**

*Знання сучасних утилітарних класів, які спрощують написання коду, та розуміння важливості `null-safe` операцій.*

* * *

### **9 ❓ Питання:**

Як правило симетричності пов'язане з використанням `instanceof` проти `getClass()`? Який підхід кращий? ⭐️

> #### **💬 Відповідь:**
>
> Цей вибір напряму впливає на дотримання правила симетричності при успадкуванні.
>
> * `instanceof`: Ця перевірка є "поліморфною". `obj instanceof MyClass` поверне `true` і для `MyClass`, і для всіх його нащадків. Як було показано раніше, це **легко може призвести до порушення симетричності**, коли об'єкт батьківського класу "вважає" об'єкт дочірнього класу рівним собі, а дочірній батьківський — ні.
>
> * `getClass() == obj.getClass()`: Ця перевірка є "строгою". Вона вимагає, щоб об'єкти були **одного і того ж класу**. Вона забороняє рівність між об'єктами різних класів, навіть якщо вони є в одній ієрархії наслідування.
>
> **Який підхід кращий?**
> **`getClass() == obj.getClass()` є набагато кращим і безпечнішим** у більшості випадків, оскільки він гарантує дотримання симетричності та запобігає складним для розуміння проблемам з успадкуванням.
>
> Джошуа Блох у своїй книзі "Effective Java" рекомендує саме цей підхід, стверджуючи, що немає способу розширити екземплярний клас і додати значуще поле, зберігши при цьому контракт `equals`.

#### **📌 Що перевіряють:**

*Глибоке розуміння компромісів між `instanceof` та `getClass()`. Здатність аргументувати вибір на користь `getClass()` з точки зору дотримання контракту.*

* * *

### **10 ❓ Питання:**

Як перевірити на рівність поля типу `float` або `double` всередині `equals()`? ⭐️

> #### **💬 Відповідь:**
>
> Пряме порівняння `float` та `double` за допомогою `==` є ризикованим через можливі помилки представлення чисел з плаваючою комою. Два числа, які логічно є рівними, можуть мати трохи різне бінарне представлення.
>
> Однак, для цілей `equals()` і `hashCode()` зазвичай вважається прийнятним використання `==`, якщо значення присвоюються напряму.
>
> **Правильний та надійний підхід** полягає у використанні статичних методів `Float.compare()` та `Double.compare()`.
>
> ```java
> return Double.compare(this.value, other.value) == 0;
> ```
>
> **Чому це краще?**
>
> * `Double.compare()` коректно обробляє значення `NaN` та `-0.0` і `+0.0`.
>   * За стандартом `NaN == NaN` повертає `false`, але `Double.compare(NaN, NaN)` повертає `0`, що є логічним для `equals()`.
>   * `-0.0 == +0.0` повертає `true`, але `Double.compare()` розрізняє їх, що може бути важливо в деяких випадках (хоча зазвичай для `equals()` це не так).
>
> Для приведення до цілого типу для `hashCode` слід використовувати `Double.doubleToLongBits()`.

#### **📌 Що перевіряють:**

*Знання особливостей роботи з числами з плаваючою комою та вміння використовувати безпечні методи для їх порівняння.*

* * *

### **11 ❓ Питання:**

Чи потрібно включати `transient` або обчислювані поля у перевірку `equals()`? ⭐️

> #### **💬 Відповідь:**
>
> Ні, не потрібно. Логіка `equals()` повинна базуватися тільки на **значущих полях**, які визначають стан об'єкта.
>
> * **`transient`-поля**: Вони за визначенням не є частиною збереженого стану об'єкта. Включати їх у `equals()` безглуздо, бо після десеріалізації вони будуть мати значення за замовчуванням, що призведе до нерівності з оригіналом.
>
> * **Обчислювані поля (кеш)**: Це поля, значення яких залежить від інших полів. Якщо ви порівняєте основні поля, з яких вони обчислюються, то цього буде достатньо. Включення обчислюваних полів є надлишковим і може трохи знизити продуктивність.
>
> **Приклад:**
>
> ```java
> public class Circle {
>     private double radius;
>     private transient double areaCache; // Обчислюване поле
>
>     // ...
>
>     @Override
>     public boolean equals(Object obj) {
>         // ... перевірки
>         Circle other = (Circle) obj;
>         // Порівнюємо ТІЛЬКИ radius. Поле areaCache ігноруємо.
>         return Double.compare(this.radius, other.radius) == 0;
>     }
> }
> ```

#### **📌 Що перевіряють:**

*Розуміння того, що визначає "логічний стан" об'єкта, та здатність відокремити значущі поля від допоміжних.*

* * *

### **12 ❓ Питання:**

У чому може бути проблема з `equals`, якщо в ньому порівнювати поля, успадковані від абстрактного класу? ⭐️

> #### **💬 Відповідь:**
>
> Проблема може виникнути, якщо різні конкретні реалізації цього абстрактного класу додають власні значущі поля, але `equals` реалізований тільки в абстрактному класі.
>
> Припустимо:
>
> ```java
> abstract class Shape {
>     abstract double area();
>
>     @Override
>     public boolean equals(Object obj) { // Порівнює тільки площу
>         if(this == obj) return true;
>         if(!(obj instanceof Shape)) return false;
>         return area() == ((Shape)obj).area();
>     }
> }
>
> class Circle extends Shape { double radius; /* ... */ }
> class Square extends Shape { double side; /* ... */ }
> ```
>
> `Circle` з радіусом 1 і `Square` зі стороною `sqrt(PI)` матимуть однакову площу. З точки зору `Shape.equals()`, вони будуть рівні. Це може бути не тією поведінкою, яку ви очікуєте.
>
> Це також може порушити **симетричність**, якщо один з нащадків перевизначить `equals`, а інший ні.
>
> **Найкраща практика:** Якщо абстрактний клас не може повністю визначити критерії рівності, він не повинен реалізовувати `equals()`. Замість цього він має делегувати це своїм конкретним підкласам, можливо, оголосивши себе як `abstract public boolean equals(Object obj)`.

#### **📌 Що перевіряють:**

*Вміння аналізувати проблеми дизайну, пов'язані з успадкуванням, та розуміння, на якому рівні ієрархії доцільно реалізовувати ту чи іншу логіку.*

* * *

### **13 ❓ Питання:**

Припустимо, ми пишемо `equals` для `enum`. Якою має бути його реалізація? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Це питання з підступом. Для `enum` **не потрібно (і не можна)** перевизначати метод `equals()`.
>
> Java гарантує, що для кожного елемента `enum` існує **лише один екземпляр** в межах однієї JVM. Це означає, що `enum`-константи є синглтонами за своєю природою.
>
> Оскільки екземпляр завжди один, для їх порівняння достатньо і абсолютно надійно використовувати оператор `==`.
>
> Фінальна реалізація `equals()` в класі `java.lang.Enum` (який є неявним батьком для всіх `enum`'ів) виглядає так:
>
> ```java
> public final boolean equals(Object other) {
>     return this == other;
> }
> ```
>
> Вона оголошена як `final`, тому ви не можете її перевизначити, навіть якби хотіли. Те ж саме стосується `hashCode()` і `clone()`. Це зроблено навмисно для забезпечення гарантій унікальності.

#### **📌 Що перевіряють:**

*Знання особливостей `enum` та розуміння того, чому деякі стандартні методи для них не потрібно або заборонено перевизначати. Це демонструє глибоке розуміння платформи.*

* * *

### **14 ❓ Питання:**

Яким чином інструменти типу Lombok або "Generate..." в IDE допомагають з реалізацією `equals()`, і які в цьому є ризики? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Як допомагають:**
> Інструменти кодогенерації (Lombok з анотацією `@EqualsAndHashCode`, функція "Generate `equals()` and `hashCode()`" в IntelliJ IDEA / Eclipse) автоматично створюють реалізацію цих методів на основі полів класу.
>
> * **Переваги:** Це значно зменшує кількість шаблонного коду, прискорює розробку та знижує ризик зробити помилку вручну (наприклад, забути додати нове поле в `equals`). Реалізація, як правило, є коректною і дотримується всіх правил контракту.
>
> **Які є ризики:**
>
> 1. **Неправильний вибір полів:** Розробник може випадково включити у порівняння нерелевантні поля (наприклад, ID з бази даних, кешовані значення) або, навпаки, забути включити значущі. Генератор працює за замовчуванням з усіма полями.
> 2. **Продуктивність:** Для класів з великою кількістю полів згенерований `equals` може бути неоптимальним. Іноді є сенс порівнювати поля в певному порядку (від найбільш ймовірно різних до найменш).
> 3. **Сліпа довіра:** Розробники можуть перестати думати про контракт `equals` і просто додавати анотацію `@EqualsAndHashCode` до всього підряд, навіть там, де логічна рівність не має сенсу (наприклад, для `Entity` класів з JPA).
> 4. **Проблеми з успадкуванням:** Lombok надає опції для керування поведінкою `equals` при наслідуванні (`callSuper=true`), але якщо розробник не розуміє, що він робить, це може призвести до порушення контракту.
>
> **Висновок:** Інструменти є надзвичайно корисними, але вони не звільняють розробника від необхідності розуміти, що відбувається "під капотом".

#### **📌 Що перевіряють:**

*Розуміння не тільки теорії, а й сучасних практик розробки. Здатність оцінювати переваги та недоліки інструментів автоматизації.*

* * *

### **15 ❓ Питання:**

Уявіть, що ви працюєте з класом, який не можете змінити (наприклад, з зовнішньої бібліотеки), і його `equals()` реалізовано некоректно. Як можна порівняти об'єкти цього класу в `HashSet`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Це складна, але реалістична проблема. Якщо не можна змінити клас, потрібно створити власну логіку порівняння та "обгорнути" об'єкти.
>
> **Рішення — патерн "Обгортка" (Wrapper):**
>
> 1. Створюється новий клас-обгортка, який буде зберігати посилання на об'єкт проблемного класу.
>
>     ```java
>     public class ThirdPartyClassWrapper {
>         private final ThirdPartyClass instance;
>
>         public ThirdPartyClassWrapper(ThirdPartyClass instance) {
>             this.instance = instance;
>         }
>
>         public ThirdPartyClass getInstance() {
>             return instance;
>         }
>
>         // ... тут будуть equals та hashCode
>     }
>     ```
>
> 2. У цьому класі-обгортці **правильно перевизначаються `equals()` та `hashCode()`**. Логіка цих методів буде отримувати доступ до полів оригінального об'єкта через геттери (`instance.getSomeField()`) і реалізовувати коректне порівняння.
>
>     ```java
>     @Override
>     public boolean equals(Object obj) {
>         // Правильна реалізація...
>         // порівнюємо this.instance та other.instance за потрібними полями
>     }
>
>     @Override
>     public int hashCode() {
>         // Правильна реалізація...
>     }
>     ```
>
> 3. Замість `HashSet<ThirdPartyClass>` тепер використовується **`HashSet<ThirdPartyClassWrapper>`**. Ви обгортаєте кожен об'єкт проблемного класу у свій wrapper перед додаванням у множину.
>
> Таким чином, ви "нав'язуєте" свою логіку рівності колекції, не змінюючи вихідний клас.
>
> Це чисте та гнучке рішення, яке ізолює "проблему" і дозволяє працювати з некоректним стороннім кодом.

#### **📌 Що перевіряють:**

*Здатність вирішувати нетривіальні проблеми за допомогою патернів проектування. Вміння думати "навколо" проблеми, коли пряме її вирішення неможливе. Це демонструє високий рівень інженерного мислення.*
