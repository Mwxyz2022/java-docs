---
layout: default
title: "Додаткові Assertions та розширені можливості JUnit"
parent: "Java JUnit"
grand_parent: "Java Core"
nav_order: 7
---

# Додаткові Assertions та розширені можливості JUnit

* короткий опис: JUnit надає розширені `assert`-методи для гнучкішого тестування: `assertAll()` (для групових перевірок), `assertTimeout()` (для перевірки часу виконання), `assertArrayEquals()` (для масивів), а також `@ParameterizedTest` для запуску одного тесту з різними вхідними даними.

* поняття: `assertAll()`, `assertTimeout()`, `assertArrayEquals()`, `messageSupplier` (для кастомних повідомлень), `@ParameterizedTest`.

* приклади: `@Test void testMultipleAssertions() { assertAll(() -> ..., () -> ...); }`, `@ParameterizedTest @ValueSource(strings = {"a", "b"})`.

* ключові моменти: Підвищують читабельність, зменшують дублювання коду (`@ParameterizedTest`), дозволяють більш детальний контроль над тестами.

* що важливо знати на співбесіді: Як використовувати `assertAll()`, `assertTimeout()`, `assertArrayEquals()`, `@ParameterizedTest`.

### **✅ Офіційне визначення:**

**`JUnit`** має не лише базові assert-методи, а й **додаткові розширення**: перевірка часу, масивів, групові перевірки,
кастомні повідомлення та параметризовані тести — усе це для гнучкіших і чистіших тестів.

### **🧠 Простими словами:**

Це як «режим PRO» у JUnit: більше інструментів \= більше контрольованих тестів.

---

## **Основне**

|     Метод / Анотація      |                           Призначення                            |
|:-------------------------:|:----------------------------------------------------------------:|
|     **`assertAll()`**     |    Виконує **групу** перевірок, навіть якщо одна з них падає     |
|   **`assertTimeout()`**   |          Перевіряє, що код виконується за обмежений час          |
| **`assertArrayEquals()`** |               Порівнює масиви елемент за елементом               |
|   **`messageSupplier`**   |      Додає **кастомне повідомлення** у разі падіння асерту       |
| **`@ParameterizedTest`**  | Дозволяє **тест з різними вхідними даними**, уникаючи дублювання |

---

## **Пояснення на пальцях (💡)**

* **`assertAll`**: усі перевірки **виконуються**, навіть якщо одна з них не пройшла (на відміну від звичайних
  assert’ів).
* **`assertTimeout`**: не дозволяє коду «залипати» — тест падає, якщо метод повільний.
* **`assertArrayEquals`**: вміє розрізнити, чи масиви ідентичні (навіть якщо їх порівнювати через **`==`** не можна).
* Кастомні повідомлення допомагають **зрозуміти**, що саме пішло не так.
* **`@ParameterizedTest`**: економить час — **один тест, багато сценаріїв**.

---

## **Корисні приклади (🧪)**

### **🔹 `assertAll`**

```java
@Test
void testMultipleAssertions() {
    String name = "JUnit";
    int number = 5;

    assertAll("Grouped assertions",
        () -> assertEquals("JUnit", name),
        () -> assertTrue(number > 3),
        () -> assertNotNull(name)
    );
}
```

### **🔹 `assertTimeout`**

```java
@Test
void testTimeout() {
    assertTimeout(Duration.ofMillis(100), () -> {
        Thread.sleep(50); // Pass
    });
}
```

### **🔹 `assertArrayEquals`**

```java
@Test
void testArrayEquality() {
    int[] expected = {1, 2, 3};
    int[] actual = {1, 2, 3};
    assertArrayEquals(expected, actual);
}
```

### **🔹 Кастомне повідомлення**

```java
@Test
void testWithMessage() {
    int actual = 42;
    assertEquals(43, actual, "Має бути відповідь на все -- 43!");
}
```

### **🔹 `@ParameterizedTest` (із `@ValueSource`)**

```java
@ParameterizedTest
@ValueSource(strings = {"java", "junit", "test"})
void testWithParameters(String word) {
    assertTrue(word.length() > 2);
}
```

---

## **Порівняння (⚖️)**

|        Функція         | `assertEquals`  |    `assertAll`    |    `@ParameterizedTest`    |
|:----------------------:|:---------------:|:-----------------:|:--------------------------:|
|    Тестує значення     |        ✅        | ✅ (кілька одразу) | ✅ (із різними параметрами) |
| Продовжує після фейлу  | ❌ (зупиняється) |         ✅         | ✅ (для кожного параметра)  |
| Підтримує повідомлення |        ✅        |         ✅         |             ✅              |

---

## **🧠 Мнемоніка для запам’ятовування:**

**"A-T-A-M-P" \= A-TAMP (типу, ми «тампаємо» все в тест)**:

* **A**ssertAll – група
* **T**imeout – ліміт
* **A**rrayEquals – масив
* **M**essage – пояснення
* **P**arameterized – багато даних

Мнемоніка: "**A-TAMP** — усі тести під контролем, навіть якщо горить\! 🔥"

---

## **🟩 Підсумок:**

JUnit дає в руки не просто "молоток", а цілий набір **тестових інструментів**. Методи **`assertAll`**, **`assertTimeout`
**, **`assertArrayEquals`** підвищують **якість, гнучкість і читабельність** тестів. А **`@ParameterizedTest`** —
справжній must-have для сценаріїв з багатьма вхідними значеннями. Не забувай і про кастомні повідомлення — вони рятують
під час дебагу.

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке `assertAll()` і яку проблему він вирішує порівняно зі звичайними твердженнями?

> #### **💬 Відповідь:**
>
> **`assertAll()`** — це метод в JUnit 5, який дозволяє згрупувати кілька тверджень в один блок.
>
> **Проблема, яку він вирішує:**
>
> Якщо ви пишете кілька тверджень одне за одним, і **перше ж з них провалюється**, виконання тесту зупиняється, і ви ніколи не дізнаєтесь про результат наступних перевірок.
>
> **Рішення `assertAll()`:**
>
> `assertAll()` **виконує усі** твердження всередині себе, незалежно від того, чи провалилися попередні. В кінці він збирає всі помилки і видає єдиний звіт про всі невдалі перевірки. Це дозволяє отримати повну картину збоїв за один запуск тесту, що значно прискорює налагодження.

#### **📝 Аналогія:**

Звичайні твердження — це як прискіпливий контролер, який зупиняє всю лінію, помітивши перший дефект. `assertAll()` — це як лікар, який проводить повний огляд, записує всі скарги пацієнта, і лише потім ставить комплексний діагноз.

#### **📝 Приклад:**

```java
@Test
void groupedAssertions() {
    User user = new User("John", "", 25); // Прізвище порожнє

    assertAll("User properties",
        () -> assertNotNull(user.getFirstName(), "Ім'я не має бути null"),
        () -> assertFalse(user.getLastName().isEmpty(), "Прізвище не має бути порожнім"), // Цей впаде
        () -> assertTrue(user.getAge() > 18, "Вік має бути більше 18")
    );
    // Звіт покаже, що провалилося твердження про прізвище.
    // Без assertAll тест зупинився б на ньому, і ми б не дізнались про вік.
}
```

#### **📌 Що перевіряють:**

*Розуміння того, як писати більш інформативні та ефективні тести. Використання `assertAll` свідчить про прагнення отримувати максимум інформації від кожного запуску тестів.*

* * *

### **2 ❓ Питання:**

Чому для порівняння масивів потрібно використовувати `assertArrayEquals()`, а не `assertEquals()`?

> #### **💬 Відповідь:**
>
> Це пов'язано з тим, як Java працює з масивами. Масиви в Java — це об'єкти, але вони **не перевизначають метод `equals()`** з класу `Object`.
>
> * **`assertEquals(array1, array2)`** викликає `array1.equals(array2)`, що для масивів еквівалентно перевірці за посиланням (`array1 == array2`). Ця перевірка буде `true` тільки якщо `array1` і `array2` — це посилання на один і той самий об'єкт в пам'яті. Вона **не порівнює вміст** масивів.
>
> * **`assertArrayEquals(expectedArray, actualArray)`**, навпаки, є спеціалізованим методом, який:
>     1. Перевіряє, чи мають масиви однакову довжину.
>     2. **Поелементно** порівнює вміст масивів.
>
> Таким чином, для коректної перевірки вмісту масивів слід завжди використовувати `assertArrayEquals()`.

#### **📝 Коментар:**

`assertEquals` прекрасно працює для колекцій, таких як `List`, оскільки вони перевизначають `equals()` для порівняння вмісту. Масиви цього не роблять.

#### **📝 Приклад:**

```java
@Test
void arrayComparisonTest() {
    int[] a = {1, 2, 3};
    int[] b = {1, 2, 3};
    
    // assertEquals(a, b); // ПРОВАЛИТЬСЯ, бо `a` і `b` - різні об'єкти.
    assertArrayEquals(a, b); // УСПІШНО, бо вміст масивів однаковий.
}
```

#### **📌 Що перевіряють:**

*Знання основ Java (різниця між `equals()` та `==`, поведінка масивів) та відповідних інструментів у JUnit для коректної роботи з ними.*

* * *

### **3 ❓ Питання:**

Як протестувати, що виконання методу не займає більше заданого часу?

> #### **💬 Відповідь:**
>
> В JUnit 5 для цього є спеціальний метод твердження **`assertTimeout()`**. Він дозволяє обгорнути виконуваний код і перевірити, чи завершився він у межах заданого часового ліміту.
>
> **Синтаксис:**
> `assertTimeout(Duration timeout, Executable executable)`
>
> * `timeout`: об'єкт `java.time.Duration`, що вказує максимальний дозволений час.
> * `executable`: блок коду для виконання (зазвичай лямбда-вираз).
>
> Якщо код всередині `executable` виконується довше, ніж вказано в `timeout`, тест буде провалено з `AssertionFailedError`.
>
> Цей метод корисний для виявлення регресій продуктивності, коли якась операція починає працювати аномально довго.

#### **📝 Приклад:**

```java
import static org.junit.jupiter.api.Assertions.assertTimeout;
import java.time.Duration;

@Test
void performanceTest() {
    // Тест впаде, якщо метод longRunningTask() виконується довше 100 мс.
    assertTimeout(Duration.ofMillis(100), () -> {
        // Симуляція роботи, яка вписується в ліміт
        Thread.sleep(50); 
    });
}
```

#### **📌 Що перевіряють:**

*Знання інструментів JUnit для написання тестів на базову продуктивність (не плутати з повноцінним навантажувальним тестуванням).*

* * *

### **4 ❓ Питання:**

Що таке параметризовані тести і як їх створити в JUnit 5?

> #### **💬 Відповідь:**
>
> **Параметризовані тести** — це потужна можливість JUnit 5, що дозволяє запустити один і той самий тестовий метод **кілька разів з різними наборами вхідних даних**.
>
> **Навіщо це потрібно:**
> Це дозволяє уникнути дублювання коду, коли потрібно перевірити одну й ту саму логіку на багатьох різних значеннях (наприклад, перевірити калькулятор з різними числами або валідатор з різними форматами рядків).
>
> **Як створити:**
>
> 1. Позначити метод анотацією **`@ParameterizedTest`** замість `@Test`.
> 2. Надати **джерело параметрів** за допомогою однієї зі спеціальних анотацій (`@ValueSource`, `@CsvSource`, `@MethodSource` і т.д.).
> 3. Оголосити в сигнатурі тестового методу параметри, які будуть приймати значення з джерела.

#### **📝 Приклад з `@ValueSource`:**

```java
import static org.junit.jupiter.api.Assertions.assertTrue;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

class StringUtilsTest {
    // Цей тест буде запущено 3 рази для кожного рядка
    @ParameterizedTest
    @ValueSource(strings = {"racecar", "madam", "level"})
    void testIsPalindrome(String word) {
        assertTrue(StringUtils.isPalindrome(word));
    }
}
```

#### **📌 Що перевіряють:**

*Знання розширених можливостей JUnit 5 для написання більш чистих та ефективних тестів. Параметризовані тести є дуже поширеною практикою.*

* * *

### **5 ❓ Питання:**

Як надати кілька аргументів для параметризованого тесту?

> #### **💬 Відповідь:**
>
> Якщо потрібно надати кілька аргументів для кожного запуску тесту, анотація `@ValueSource` вже не підходить, оскільки вона надає лише один аргумент за раз.
>
> Для цього існують більш гнучкі джерела, найпопулярніші з яких:
>
> 1. **`@CsvSource`**: Дозволяє задавати аргументи у форматі CSV (Comma-Separated Values), де кожен рядок є набором аргументів для одного запуску.
>
> 2. **`@MethodSource`**: Дозволяє вказати ім'я статичного методу, який поверне потік (`Stream`) або колекцію аргументів. Це найгнучкіший підхід, що дозволяє створювати складні об'єкти як параметри.

#### **📝 Приклад з `@CsvSource`:**

```java
import static org.junit.jupiter.api.Assertions.assertEquals;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.CsvSource;

class CalculatorTest {
    @ParameterizedTest
    @CsvSource({
        "1, 2, 3",     // a=1, b=2, expected=3
        "5, 5, 10",    // a=5, b=5, expected=10
        "-1, 1, 0"     // a=-1, b=1, expected=0
    })
    void testAddition(int a, int b, int expected) {
        Calculator calculator = new Calculator();
        assertEquals(expected, calculator.add(a, b));
    }
}
```

#### **📌 Що перевіряють:**

*Вміння працювати з більш складними сценаріями параметризації, що є типовим завданням при тестуванні бізнес-логіки.*

* * *

### **6 ❓ Питання:**

Чому рекомендується використовувати `Supplier<String>` для повідомлень у твердженнях замість звичайного `String`?

> #### **💬 Відповідь:**
>
> Використання `Supplier<String>` (зазвичай у вигляді лямбда-виразу) для повідомлень про помилку є **оптимізацією продуктивності**.
>
> **Пояснення:**
>
> * **При використанні звичайного `String`:**
>     `assertEquals(expected, actual, "Error for ID: " + id);`
>     Рядок повідомлення (включаючи конкатенацію) буде створюватися **при кожному запуску тесту**, незалежно від того, успішний він чи ні. Для тисяч тестів це може створювати невеликі, але зайві накладні витрати.
>
> * **При використанні `Supplier<String>`:**
>     `assertEquals(expected, actual, () -> "Error for ID: " + id);`
>     Лямбда-вираз **не буде виконаний**, і рядок повідомлення не буде створений, якщо тест **проходить успішно**. Він обчислюється "ліниво" (lazily), тобто **тільки в тому випадку, коли твердження провалюється**.
>
> Хоча різниця в продуктивності для одного тесту мізерна, це є гарною практикою, особливо у великих проектах з високими вимогами до швидкості виконання тестів.

#### **📌 Що перевіряють:**

*Увагу до деталей та розуміння механізмів оптимізації. Це показує, що кандидат думає про продуктивність навіть у тестовому коді.*

* * *

### **7 ❓ Питання:**

Для чого потрібен `assertDoesNotThrow` і як він доповнює `assertThrows`?

> #### **💬 Відповідь:**
>
> **`assertDoesNotThrow`** — це твердження, яке перевіряє, що виконання певного блоку коду **не кидає жодного винятку**.
>
> **Як він доповнює `assertThrows`:**
>
> * `assertThrows`: Перевіряє **"нещасливий шлях"** (negative path) — те, що код *правильно* реагує на помилкові дані, кидаючи очікуваний виняток.
> * `assertDoesNotThrow`: Перевіряє **"щасливий шлях"** (happy path) — те, що код *не кидає* виняток при обробці коректних даних.
>
> Використання обох цих тверджень дозволяє повністю покрити логіку обробки помилок: перевірити як наявність винятку там, де він потрібен, так і його відсутність там, де його бути не повинно.

#### **📝 Приклад:**

```java
class Parser {
    public int parse(String s) {
        if (s == null || !s.matches("\\d+")) {
            throw new NumberFormatException();
        }
        return Integer.parseInt(s);
    }
}

class ParserTest {
    @Test
    void testParseValidString() {
        Parser parser = new Parser();
        // Перевіряємо, що при коректних даних винятку НЕ буде
        assertDoesNotThrow(() -> parser.parse("123"));
    }
    
    @Test
    void testParseInvalidString() {
        Parser parser = new Parser();
        // Перевіряємо, що при некоректних даних буде виняток
        assertThrows(NumberFormatException.class, () -> parser.parse("abc"));
    }
}
```

#### **📌 Що перевіряють:**

*Повноту мислення при тестуванні. Кандидат повинен розуміти, що важливо перевіряти не тільки виникнення помилок, а і їх відсутність у правильних сценаріях.*

* * *

### **8 ❓ Питання:**

Як перевірити, що метод `assertTimeout` не тільки завершився вчасно, але й повернув правильний результат? ⭐️

> #### **💬 Відповідь:**
>
> Методи `assertTimeout` та `assertTimeoutPreemptively` мають перевантажені версії, які повертають результат виконання блоку коду.
>
> **Як це працює:**
>
> 1. Блок коду всередині `assertTimeout` реалізується через `Executable`, який може повертати значення.
> 2. Метод `assertTimeout` повертає це значення, якщо виконання завершилося вчасно.
> 3. Ви можете зберегти цей результат у змінну і потім використати його в наступних твердженнях.

#### **📝 Приклад:**

```java
@Test
void testMethodWithTimeoutAndReturnValue() {
    String result = assertTimeout(Duration.ofSeconds(1), () -> {
        // Симуляція операції, що повертає результат
        Thread.sleep(500);
        return "Task Completed";
    });

    // Додаткова перевірка повернутого значення
    assertEquals("Task Completed", result);
}
```

#### **📌 Що перевіряють:**

*Знання перевантажених версій методів JUnit та вміння писати комплексні тести, що перевіряють кілька аспектів одночасно (в даному випадку — і час, і результат).*

* * *

### **9 ❓ Питання:**

Як можна кастомізувати назви для кожного запуску параметризованого тесту? ⭐️

> #### **💬 Відповідь:**
>
> За замовчуванням назви параметризованих тестів у звіті виглядають не дуже інформативно (наприклад, `[1] 2, 3, 5`, `[2] -1, 1, 0`).
>
> Для надання більш значущих імен використовується атрибут **`name`** в анотації `@ParameterizedTest`.
>
> В цьому атрибуті можна використовувати спеціальні плейсхолдери для підстановки значень:
>
> * `{index}`: Порядковий номер запуску (починаючи з 1).
> * `{arguments}`: Повний список аргументів.
> * `{0}`, `{1}`, ...: Конкретний аргумент за його індексом.

#### **📝 Приклад:**

```java
@ParameterizedTest(name = "Запуск №{index}: {0} + {1} = {2}")
@CsvSource({ "2, 3, 5", "-1, 1, 0" })
void testAdditionWithCustomNames(int a, int b, int expected) {
    // ...
}
```

**Результат у звіті буде виглядати так:**

* `Запуск №1: 2 + 3 = 5`
* `Запуск №2: -1 + 1 = 0`

#### **📌 Що перевіряють:**

*Практичні навички покращення читабельності та інформативності тестових звітів, що є важливим при аналізі великої кількості тестів.*

* * *

### **10 ❓ Питання:**

Поясніть, для чого потрібен `@MethodSource` в параметризованих тестах і чим він кращий за `@CsvSource`. ⭐️

> #### **💬 Відповідь:**
>
> Анотація **`@MethodSource`** — це найгнучкіший спосіб надання даних для параметризованих тестів. Вона дозволяє вказати **статичний метод**, який буде генерувати і повертати тестові дані.
>
> **Чим він кращий за `@CsvSource`:**
>
> 1. **Підтримка будь-яких типів даних:** `@CsvSource` працює тільки з простими типами, які можна представити як рядки (int, double, string). `@MethodSource` може повертати **складні об'єкти**, списки, мапи — будь-що.
>
> 2. **Динамічне генерування даних:** Дані в `@CsvSource` є статичними. Метод для `@MethodSource` може **динамічно генерувати** тестові дані на основі якоїсь логіки, що робить тести більш гнучкими.
>
> **Вимоги до методу-джерела:**
>
> * Має бути `static`.
> * Не повинен приймати аргументів.
> * Повинен повертати `Stream`, `Collection`, ітератор або масив об'єктів `Arguments` (де кожен `Arguments.of(...)` — це набір параметрів для одного запуску).

#### **📝 Приклад:**

```java
class UserTest {
    @ParameterizedTest
    @MethodSource("userProvider")
    void testUserValidation(User user, boolean expectedValidity) {
        assertEquals(expectedValidity, user.isValid());
    }

    static Stream<Arguments> userProvider() {
        return Stream.of(
            Arguments.of(new User("Admin", "pass"), true),  // Валідний
            Arguments.of(new User("", "pass"), false),      // Невалідний
            Arguments.of(new User("User", null), false)    // Невалідний
        );
    }
}
```

#### **📌 Що перевіряють:**

*Знання найбільш потужного інструменту для параметризації та вміння тестувати методи, що приймають складні об'єкти.*

* * *

### **11 ❓ Питання:**

Що таке твердження з таймаутом `assertTimeoutPreemptively` і в чому його небезпека? ⭐️

> #### **💬 Відповідь:**
>
> **`assertTimeoutPreemptively`** — це альтернатива `assertTimeout`, яка відрізняється поведінкою при перевищенні часового ліміту.
>
> * **`assertTimeout`**: Виконує код в тому ж потоці. Якщо час вичерпано, він **чекає завершення коду** і лише потім провалює тест.
> * **`assertTimeoutPreemptively`**: Виконує код в **іншому потоці**. Якщо час вичерпано, він **примусово перериває** цей потік (через `Thread.interrupt()`).
>
> **Небезпека:**
>
> Примусове переривання потоку може залишити систему в **неконсистентному стані**. Наприклад, якщо код тримав блокування (lock) або відкрив файл, ці ресурси можуть не бути коректно звільнені, що може вплинути на наступні тести.
>
> **Коли використовувати:**
>
> Цей метод варто використовувати **дуже обережно** і лише тоді, коли ви тестуєте код, який потенційно може увійти в **нескінченний цикл**, і ви хочете гарантовано зупинити виконання тесту, а не чекати вічно.

#### **📌 Що перевіряють:**

*Глибоке розуміння API JUnit та пов'язаних з ним ризиків, особливо тих, що стосуються багатопотоковості.*

* * *

### **12 ❓ Питання:**

Як порівняти два списки на рівність, ігноруючи порядок елементів? ⭐️

> #### **💬 Відповідь:**
>
> Стандартний `assertEquals(list1, list2)` для `List` враховує порядок елементів. Якщо вам потрібно перевірити, що два списки містять однакові елементи, але в довільному порядку, існують кілька підходів.
>
> **Підхід 1: Сортування (якщо елементи `Comparable`)**
>
> 1. Створити копії обох списків.
> 2. Відсортувати обидві копії.
> 3. Порівняти відсортовані списки за допомогою `assertEquals`.
>
> **Підхід 2: Використання `HashSet` (кращий для перевірки наявності)**
>
> 1. Перетворити обидва списки на `HashSet`.
> 2. Порівняти сети за допомогою `assertEquals`. Це перевірить, що набори елементів однакові, ігноруючи дублікати та порядок.
>
> **Підхід 3: Використання сторонніх бібліотек (найкращий варіант)**
>
> * **AssertJ** надає дуже елегантний спосіб для цього:
>
>     ```java
>     assertThat(actualList).containsExactlyInAnyOrderElementsOf(expectedList);
>     ```
>
>     Цей підхід є найбільш читабельним і не вимагає ручних маніпуляцій з колекціями.

#### **📌 Що перевіряють:**

*Здатність вирішувати нетривіальні завдання з тестування колекцій та знання альтернативних підходів, включаючи використання популярних бібліотек.*

* * *

### **13 ❓ Питання:**

Уявіть, що тест провалився на `assertEquals` для двох складних об'єктів. Стандартне повідомлення `toString()` неінформативне. Як покращити діагностику, не змінюючи `toString()`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Це поширена проблема. Якщо об'єкти не мають інформативного `toString()`, налагодження може бути складним.
>
> **Рішення:**
>
> 1. **`assertAll` з поелементною перевіркою:**
>     Замість одного `assertEquals` для всього об'єкта, можна використовувати `assertAll` для перевірки кожного поля окремо. Це одразу покаже, яке саме поле не збігається.
>
>     ```java
>     assertAll("user",
>         () -> assertEquals(expected.getName(), actual.getName(), "Name mismatch"),
>         () -> assertEquals(expected.getAge(), actual.getAge(), "Age mismatch")
>     );
>     ```
>
> 2. **Використання AssertJ з `usingRecursiveComparison()`:**
>     **AssertJ** надає потужний механізм для "глибокого" порівняння об'єктів.
>
>     ```java
>     assertThat(actualUser).usingRecursiveComparison().isEqualTo(expectedUser);
>     ```
>
>     Якщо тест впаде, AssertJ видасть дуже детальний звіт, в якому саме полі (навіть вкладеному) сталася розбіжність. Це найпотужніший та найзручніший підхід.
>
> 3. **Використання `org.junit.jupiter.api.Assertions.assertLinesMatch`:**
>     Якщо стан об'єкта можна представити у вигляді списку рядків, цей метод дозволяє гнучко порівнювати їх, підтримуючи плейсхолдери.
>
> Найбільш рекомендованим для таких випадків є використання **AssertJ**.

#### **📌 Що перевіряють:**

*Досвід роботи з тестуванням складних доменних моделей та знання інструментів, що значно спрощують цей процес. Кандидат повинен думати про зручність налагодження.*

* * *

### **14 ❓ Питання:**

Що таке `ArgumentConverter` в параметризованих тестах і для чого він потрібен? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **`ArgumentConverter`** — це частина API параметризованих тестів JUnit 5, яка дозволяє виконувати **кастомне перетворення типів** для аргументів, що надходять з джерел даних (напр., `@CsvSource`).
>
> **Проблема, яку він вирішує:**
> JUnit "з коробки" може автоматично перетворювати рядки з джерел даних у базові типи (`int`, `double`, `boolean` і т.д.). Але він не знає, як перетворити рядок, наприклад, у ваш кастомний об'єкт `User` або в `LocalDate`.
>
> **Рішення:**
> Ви можете створити власний клас, що реалізує інтерфейс `ArgumentConverter`, і вказати його за допомогою анотації `@ConvertWith`.
>
> **Приклад:**
> Створимо конвертер, який перетворює рядок "yyyy-MM-dd" в `LocalDate`.
>
> ```java
> public class ToLocalDateConverter extends SimpleArgumentConverter {
>     @Override
>     protected Object convert(Object source, Class<?> targetType) {
>         if (source instanceof String && LocalDate.class.isAssignableFrom(targetType)) {
>             return LocalDate.parse((String) source);
>         }
>         // ...
>     }
> }
>
> // Використання в тесті:
> @ParameterizedTest
> @ValueSource(strings = "2023-10-27")
> void testWithDate(@ConvertWith(ToLocalDateConverter.class) LocalDate date) {
>     assertEquals(DayOfWeek.FRIDAY, date.getDayOfWeek());
> }
> ```

#### **📌 Що перевіряють:**

*Експертне знання API JUnit 5. Це глибока тема, знання якої свідчить про серйозний досвід роботи з параметризованими тестами.*

* * *

### **15 ❓ Питання:**

Як протестувати метод, результат якого залежить від випадкових значень (наприклад, використовує `java.util.Random`)? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Код, що напряму залежить від `new Random()`, є **важким для тестування**, оскільки його результати непередбачувані. Тести для такого коду будуть нестабільними ("flaky").
>
> **Правильний підхід** — це зробити випадковість **зовнішньою залежністю**, яку можна контролювати в тестах.
>
> **Кроки:**
>
> 1. **Використання абстракції:** Замість прямого створення `new Random()`, ваш клас повинен приймати екземпляр `java.util.Random` (або `java.util.function.IntSupplier` тощо) через конструктор.
>
>     ```java
>     // Хороший, тестований код
>     public class DiceRoller {
>         private final Random randomGenerator;
>         public DiceRoller(Random randomGenerator) { this.randomGenerator = randomGenerator; }
>     
>         public int roll() {
>             return randomGenerator.nextInt(6) + 1;
>         }
>     }
>     ```
>
> 2. **Контроль випадковості в тесті:**
>     У unit-тесті ви можете передати в конструктор екземпляр `Random` з **фіксованим початковим значенням (seed)**. Це гарантує, що послідовність "випадкових" чисел буде **однаковою при кожному запуску тесту**, роблячи результат передбачуваним.
>     Або, що ще краще, ви можете використати **мок (mock)**.
>
> **Приклад тесту з Mockito:**
>
> ```java
> @ExtendWith(MockitoExtension.class)
> class DiceRollerTest {
>     @Mock
>     private Random mockRandom;
> 
>     @Test
>     void testRoll() {
>         // "Навчаємо" мок повертати конкретне значення
>         // nextInt(6) поверне 4, тому кінцевий результат буде 4 + 1 = 5
>         when(mockRandom.nextInt(6)).thenReturn(4);
> 
>         DiceRoller roller = new DiceRoller(mockRandom);
>         
>         assertEquals(5, roller.roll());
>     }
> }
> ```
>
> Таким чином, ви тестуєте не саму випадковість, а **логіку, яка використовує результат** випадкової події, що робить тест стабільним і детермінованим.

#### **📌 Що перевіряють:**

*Вміння писати тестований код та застосовувати патерн "ін'єкція залежностей" для вирішення проблем з непередбачуваними залежностями. Це ознака високого рівня інженерної культури.*

* * *
