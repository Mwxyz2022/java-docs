---
layout: default
title: "Інкапсуляція"
parent: "Об'єктно-орієнтоване програмування (ООП)"
grand_parent: "Java Core"
nav_order: 3
---

# Інкапсуляція

* короткий опис: Принцип ООП, що об'єднує дані (поля) та методи (поведінку) в одному класі, обмежуючи прямий доступ до внутрішніх полів. Доступ здійснюється через публічні геттери та сеттери.

* поняття: Інкапсуляція, `private` (модифікатор доступу), `public`, геттери, сеттери.

* приклади: `private String name;`, `public String getName();`, `public void setName(String name);`.

* ключові моменти: Захист даних від некоректного використання, контроль доступу, можливість валідації вхідних даних.

* що важливо знати на співбесіді: Визначення, як реалізується, навіщо потрібна.

### **✅ Офіційне визначення:**

Інкапсуляція — це принцип ООП, який об’єднує дані (стан) і методи (поведінку) в одному класі, обмежуючи прямий доступ до внутрішніх полів. Доступ здійснюється через публічні геттери і сеттери.

### **🧠 Простими словами:**

Інкапсуляція — це як сейф: дані заховані всередині, а ключі (методи) контролюють, хто і як їх може використовувати. Це захищає об’єкт від неправильного використання і дає контроль над змінами.

---

## **📊 Модифікатори доступу в Java:**

| Модифікатор | Доступ в межах класу | Доступ в інших класах (пакет) | Доступ в інших пакетах |
| :---: | :---: | :---: | :---: |
| **private** | ✅ | ❌ | ❌ |
| **default** | ✅ | ✅ (в межах пакету) | ❌ |
| **protected** | ✅ | ✅ (через наслідування) | ✅ (через наслідування) |
| **public** | ✅ | ✅ | ✅ |

---

## **Пояснення на пальцях (💡)**

Дані в об’єкті — це наче начинка в бургері, а інкапсуляція — обгортка, яка не дає бургеру розсипатись.

Якщо поле зробити **`private`**, доступ напряму заборонений. Але через методи, наприклад **`setAge()`**, можна перевірити правильність введення віку перед збереженням.

Це дає:

* Захист від некоректних значень
* Контроль доступу
* Можливість змінити внутрішню реалізацію без впливу на зовнішній код

---

## **Корисні приклади (🧪)**

```java
public class Person {
    private String name;    // приховані дані
    private int age;

    public String getName() {     // геттер
        return name;
    }

    public void setName(String name) {   // сетер
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if (age >= 0) {
            this.age = age;
        } else {
            System.out.println("Invalid age");
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        p.setName("Anna");
        p.setAge(25);

        System.out.println(p.getName()); // Anna
        System.out.println(p.getAge());  // 25
    }
}
```

---

## **Порівняння (⚖️)**

| Варіант | Результат |
| :---: | :---: |
| **`public int age;`** | Дані відкриті — небезпечно |
| **`private int age + setAge()`** | Дані захищені, є можливість валідації |

---

## **🧠 Мнемоніка для запам’ятовування:**

**📦 “Сейф із кнопками”**

* Дані (всередині) — private
* Доступ — через “кнопки” -> get...() / set...()

---

## **🟩 Підсумок:**

Інкапсуляція — це спосіб захисту даних в об’єкті від зовнішніх помилок і неконтрольованих змін. Оголошення полів як `private` та доступ через публічні геттери і сеттери забезпечує безпечний, гнучкий і керований доступ до стану об’єкта. Це один з основних принципів чистого і професійного коду.

---

**🔗 Корисні посилання для глибшого розуміння:**

* [**Oracle Java Tutorials: Encapsulation**](https://docs.oracle.com/javase/tutorial/java/javaOO/encapsulation.html)
* [**Wikipedia: Encapsulation (computer programming)**](https://en.wikipedia.org/wiki/Encapsulation_\(computer_programming\))

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке інкапсуляція і які дві основні ідеї вона в себе включає?

> #### **💬 Відповідь:**
>
> **Інкапсуляція** — це один з чотирьох основних принципів ООП. Вона реалізує дві ключові ідеї:
>
> 1. **Об'єднання даних та поведінки:** Вона об'єднує дані (поля) та методи, що працюють з цими даними, всередині одного логічного блоку — **класу**. Це створює самодостатні об'єкти, де дані та логіка їх обробки нерозривно пов'язані.
>
> 2. **Приховування даних (Data Hiding):** Вона обмежує прямий доступ до внутрішнього стану (полів) об'єкта ззовні. Доступ до цих даних надається лише через спеціальні публічні методи (зазвичай, геттери та сеттери), які виступають у ролі контрольованого "інтерфейсу".
>
> Простими словами, інкапсуляція — це створення "чорного ящика", який ховає свою складну внутрішню реалізацію і надає простий та безпечний спосіб взаємодії з ним.

#### **📝 Аналогія:**

Інкапсуляція — це як капсула з ліками. Усередині неї знаходиться активна речовина (дані), захищена оболонкою (класом). Ви не взаємодієте з речовиною напряму, а просто приймаєте капсулу (викликаєте публічний метод), і вона робить свою роботу всередині, не дозволяючи вам випадково щось зіпсувати.

#### **📌 Що перевіряють:**

*Розуміння того, що інкапсуляція — це і про об'єднання, і про приховування, а не тільки про щось одне.*

* * *

### **2 ❓ Питання:**

Як інкапсуляція реалізується в Java? Назвіть ключові інструменти.

> #### **💬 Відповідь:**
>
> В Java інкапсуляція реалізується за допомогою двох основних мовних механізмів:
>
> 1. **Модифікатори доступу (`access modifiers`):**
>     * Це ключові слова, які визначають рівень видимості полів, методів та класів.
>     * Для приховування даних найчастіше використовується модифікатор **`private`**, який робить поле доступним лише всередині самого класу.
>
> 2. **Публічні методи доступу (Accessors) — геттери та сеттери:**
>     * **Геттер (`getter`):** Публічний метод для отримання значення `private` поля (наприклад, `public String getName()`).
>     * **Сеттер (`setter`):** Публічний метод для зміни значення `private` поля (наприклад, `public void setName(String name)`). Сеттери дозволяють додати логіку **валідації** або **контролю** перед тим, як змінити стан об'єкта.
>
> **Приклад повної реалізації:**
>
> ```java
> public class User {
>     private String email; // Поле приховане
>
>     // Публічний геттер для читання
>     public String getEmail() {
>         return email;
>     }
>
>     // Публічний сеттер для контрольованого запису
>     public void setEmail(String email) {
>         // Валідація даних перед присвоєнням
>         if (email != null && email.contains("@")) {
>             this.email = email;
>         }
>     }
> }
> ```

#### **📌 Що перевіряють:**

*Знання конкретних інструментів мови Java, які використовуються для імплементації принципу інкапсуляції.*

* * *

### **3 ❓ Питання:**

Які переваги надає інкапсуляція?

> #### **💬 Відповідь:**
>
> Інкапсуляція надає низку важливих переваг, які роблять код більш надійним, гнучким та легким у підтримці.
>
> 1. **Контроль та захист даних:** Це головна перевага. Ви можете додати логіку валідації в сеттери, щоб запобігти присвоєнню некоректних значень (наприклад, від'ємного віку). Це гарантує, що об'єкт завжди знаходиться в узгодженому (валідному) стані.
>
> 2. **Гнучкість та легкість рефакторингу:** Ви можете змінити внутрішню реалізацію класу (наприклад, змінити тип поля, перейменувати його, змінити спосіб зберігання), і це не вплине на зовнішній код, який використовує ваш клас, доки публічний інтерфейс (методи) залишається незмінним.
>
> 3. **Приховування складності:** Клас може приховувати складні внутрішні процеси. Наприклад, метод `car.start()` може виконувати десятки внутрішніх операцій, але для користувача це виглядає як один простий виклик.
>
> 4. **Покращена тестованість:** Оскільки стан об'єкта контролюється, його легше тестувати. Ви точно знаєте, як можна змінити його стан, і можете перевіряти це через публічні методи.
>
> 5. **Надання доступу "тільки для читання" або "тільки для запису":** Ви можете надати для поля лише геттер (створивши read-only властивість) або лише сеттер, що дає тонкий контроль над доступом.

#### **📌 Що перевіряють:**

*Розуміння практичної користі інкапсуляції. Кандидат повинен пояснити, як цей принцип допомагає вирішувати реальні проблеми розробки.*

* * *

### **4 ❓ Питання:**

Які є модифікатори доступу в Java і який з них використовується для інкапсуляції за замовчуванням?

> #### **💬 Відповідь:**
>
> У Java існує чотири модифікатори доступу:
>
> 1. **`public`:**
>     * **Найбільш відкритий.** Доступний з будь-якого місця: з цього ж класу, з інших класів у тому ж пакеті, зі спадкоємців, і з будь-якого іншого пакета.
>
> 2. **`protected`:**
>     * Доступний всередині свого класу, всередині інших класів того ж пакета, а також у **класах-спадкоємцях**, навіть якщо вони знаходяться в інших пакетах.
>
> 3. **`default` (package-private):**
>     * **Це модифікатор за замовчуванням** (якщо нічого не вказано).
>     * Доступний лише всередині **того самого пакета**. Він невидимий для класів з інших пакетів, навіть для спадкоємців.
>
> 4. **`private`:**
>     * **Найбільш закритий.** Доступний **лише всередині того самого класу**, в якому він оголошений.
>
> Для **інкапсуляції стану об'єкта** (його полів) зазвичай використовується модифікатор **`private`**.

#### **📌 Що перевіряють:**

*Чітке знання всіх чотирьох модифікаторів доступу та їхніх областей видимості. Це базове питання для оцінки знань ООП.*

* * *

### **5 ❓ Питання:**

Чому бездумне створення геттерів і сеттерів для всіх полів може порушити інкапсуляцію?

> #### **💬 Відповідь:**
>
> Автоматичне генерування публічних геттерів і сеттерів для кожного `private` поля є поширеним **антипатерном**, який фактично **руйнує переваги інкапсуляції**.
>
> **Чому це погано:**
>
> 1. **Порушення приховування даних:** Це робить `private` поля "квазі-публічними". Ви надаєте неконтрольований доступ на читання і запис до внутрішнього стану об'єкта. Клас перестає керувати своїм станом і стає просто "тупим" контейнером для даних.
>
> 2. **Втрата гнучкості:** Якщо зовнішній код напряму залежить від кожного геттера/сеттера, ви більше не можете легко змінити внутрішнє представлення, не зламавши цей код.
>
> 3. **Небезпека для змінних (mutable) об'єктів:** Якщо геттер повертає посилання на змінюваний об'єкт (наприклад, `List` або `Date`), зовнішній код може отримати це посилання і змінити внутрішній стан об'єкта в обхід його логіки.
>
> **Приклад небезпечного геттера:**
>
> ```java
> class Order {
>     private List<Item> items = new ArrayList<>();
>     public List<Item> getItems() {
>         return items; // Повертає пряме посилання на внутрішній список!
>     }
> }
> // Зовнішній код:
> List<Item> orderItems = order.getItems();
> orderItems.clear(); // Ми щойно видалили всі товари із замовлення ззовні!
> ```
>
> **Як правильно:** Слід створювати геттери та сеттери тільки тоді, коли це дійсно необхідно за бізнес-логікою. Для колекцій потрібно повертати або незмінну обгортку (`Collections.unmodifiableList(items)`), або копію.

#### **📌 Що перевіряють:**

*Глибоке розуміння принципу. Кандидат повинен знати, що інкапсуляція — це не сліпе слідування правилу "зроби все private, а потім додай геттери/сеттери".*

* * *

### **6 ❓ Питання:**

Що таке незмінний об'єкт (immutable object)? Як інкапсуляція допомагає в його створенні? ⭐️

> #### **💬 Відповідь:**
>
> **Незмінний об'єкт** — це об'єкт, внутрішній стан якого **неможливо змінити** після його створення. Класичним прикладом у Java є `String`.
>
> **Інкапсуляція відіграє ключову роль** у створенні незмінних об'єктів, надаючи для цього необхідні інструменти.
>
> **Правила створення незмінного класу:**
>
> 1. **Оголосити клас як `final`**, щоб заборонити його розширення.
> 2. **Зробити всі поля `private` і `final`**. Це гарантує, що їхні значення присвоюються лише один раз у конструкторі.
> 3. **Не надавати сеттерів** або будь-яких інших методів, що змінюють поля.
> 4. Ініціалізувати всі поля в конструкторі.
> 5. Якщо клас містить посилання на **змінні об'єкти** (наприклад, `List`, `Date`), потрібно:
>     * У конструкторі створювати **копії** переданих об'єктів.
>     * У геттерах повертати **копії** внутрішніх об'єктів.
>
> **Роль інкапсуляції:**
>
> * `private final` поля **приховують і захищають** стан.
> * Відсутність публічних сеттерів **забороняє** пряму зміну стану.
> * Публічні геттери, що повертають копії, **контролюють доступ**, не даючи "витікти" посиланням на внутрішні змінні об'єкти.
>
> Таким чином, інкапсуляція є основою, на якій будується незмінність.

#### **📌 Що перевіряють:**

*Знання патерну Immutable Object та здатність пояснити, як кожен з принципів інкапсуляції допомагає його реалізувати.*

* * *

### **7 ❓ Питання:**

Як інкапсуляція пов'язана з абстракцією?

> #### **💬 Відповідь:**
>
> Інкапсуляція та абстракція — це два тісно пов'язані, але різні принципи. Вони працюють разом, щоб створювати добре спроектовані об'єкти.
>
> * **Абстракція** фокусується на **зовнішньому вигляді** об'єкта. Вона визначає, **"ЩО"** об'єкт робить, надаючи простий інтерфейс і приховуючи непотрібні деталі. Це про спрощення моделі.
> * **Інкапсуляція** фокусується на **внутрішній реалізації**. Вона реалізує приховування даних, тобто, **"ЯК"** об'єкт досягає результату, і захищає його стан. Це про контроль та безпеку.
>
> **Як вони пов'язані:**
>
> **Інкапсуляція є механізмом для досягнення абстракції.**
>
> Ми використовуємо інкапсуляцію (наприклад, робимо поля `private`, а методи — `public`), щоб реалізувати абстракцію. Ми показуємо користувачеві лише потрібні `public` методи (це наша абстракція) і ховаємо всі `private` поля та допоміжні `private` методи (це приховування даних, частина інкапсуляції).
>
> **Простий приклад:**
>
> * **Абстракція:** У класа `Car` є метод `drive()`.
> * **Інкапсуляція:** "Під капотом" методу `drive()` може бути складна логіка взаємодії з `private` полями `engine`, `transmission`, `fuelSystem`. Ця складна логіка прихована від користувача, якому потрібно лише "їхати".

#### **📌 Що перевіряють:**

*Здатність розрізняти ці два схожі поняття та пояснити їх взаємозв'язок.*

* * *

### **8 ❓ Питання:**

Що таке JavaBean і як він пов'язаний з інкапсуляцією? ⭐️

> #### **💬 Відповідь:**
>
> **JavaBean** — це стандарт або угода про іменування та проектування для Java класів, які призначені для повторного використання у різних середовищах (наприклад, у фреймворках типу Spring, Hibernate, або в інструментах візуального програмування).
>
> **Основні правила JavaBean:**
>
> 1. Клас повинен бути **публічним**.
> 2. Він повинен мати **публічний конструктор без аргументів**.
> 3. Його властивості повинні бути доступні через **публічні геттери та сеттери**, які дотримуються стандартного іменування (наприклад, `getPropertyName()`, `setPropertyName()`).
> 4. Клас повинен реалізовувати інтерфейс `java.io.Serializable`.
>
> **Зв'язок з інкапсуляцією:**
>
> Угода про JavaBean є **формалізованим застосуванням принципу інкапсуляції**. Вона вимагає, щоб поля були приховані (зазвичай `private`), а доступ до них здійснювався виключно через геттери та сеттери.
>
> Однак, якщо слідувати цьому стандарту сліпо (генеруючи геттери/сеттери для всього), це може призвести до **"анемічної моделі даних"** — класів, що є просто контейнерами даних без логіки, що, як було сказано раніше, може порушити дух інкапсуляції.

#### **📌 Що перевіряють:**

*Знання поширених стандартів і угод у Java-екосистемі.*

* * *

### **9 ❓ Питання:**

Які недоліки можуть виникнути, якщо зробити всі поля класу публічними (`public`)? ⭐️

> #### **💬 Відповідь:**
>
> Робити поля класу публічними — це **повна відмова від інкапсуляції** і одна з найгірших практик в ООП. Це призводить до низки серйозних проблем:
>
> 1. **Втрата контролю над станом:** Будь-яка частина коду може змінити значення поля напряму, присвоївши йому будь-яке, навіть некоректне, значення. Немає жодної можливості для валідації.
>     `user.age = -99;`
>
> 2. **Пряма залежність від реалізації (жорстка зв'язність):** Зовнішній код стає жорстко прив'язаним до імені та типу поля. Якщо ви захочете перейменувати поле або змінити його тип (наприклад, `int` на `long`), вам доведеться змінювати код у **всіх місцях**, де це поле використовувалося. Це робить рефакторинг майже неможливим.
>
> 3. **Непослідовний стан:** Оскільки кілька частин коду можуть змінювати поля незалежно, стає дуже важко гарантувати, що об'єкт завжди знаходиться в узгодженому стані.
>
> 4. **Проблеми з багатопотоковістю:** Якщо об'єкт використовується у кількох потоках, прямий доступ до полів без синхронізації (яка могла б бути в сеттерах) майже гарантовано призведе до стану гонитви (race condition).
>
> По суті, такий клас перестає бути об'єктом в сенсі ООП, а перетворюється на звичайну структуру даних, як у мові C.

#### **📌 Що перевіряють:**

*Розуміння негативних наслідків порушення інкапсуляції. Це питання на розуміння "як не треба робити".*

* * *

### **10 ❓ Питання:**

Що таке POJO (Plain Old Java Object)? Чим він відрізняється від JavaBean? ⭐️

> #### **💬 Відповідь:**
>
> **POJO (Plain Old Java Object)** — це термін, який використовується для опису простого Java об'єкта, який **не обтяжений** успадкуванням від специфічних класів фреймворків, реалізацією "маркерних" інтерфейсів чи використанням анотацій, що нав'язуються фреймворком (як-от EJB).
>
> **Ключова ідея POJO:** це об'єкт, який фокусується на **бізнес-логіці**, а не на технологічних деталях інфраструктури.
>
> **Чим він відрізняється від JavaBean:**
>
> | Характеристика | JavaBean | POJO |
> | :---: | :---: | :---: |
> | **Призначення** | Повторно використовуваний компонент, стандарт для інструментів. | Простий об'єкт даних/бізнес-логіки. |
> | **Правила** | **Строгі.** Повинен мати публічний конструктор без аргументів, геттери/сеттери, бути серіалізованим. | **Ніяких строгих правил.** Може мати будь-які конструктори, поля можуть бути `public` або `final`. Не зобов'язаний мати геттери/сеттери. |
> | **Зв'язок** | Будь-який JavaBean є POJO, але **не кожен POJO є JavaBean**. | POJO — це більш загальне і менш формальне поняття. |
>
> Наприклад, незмінний об'єкт з `private final` полями та конструктором, що приймає аргументи, є POJO, але не є JavaBean.
>
> **POJO реалізує інкапсуляцію** тоді, коли це має сенс для бізнес-логіки, а не тому, що цього вимагає стандарт.

#### **📌 Що перевіряють:**

*Знання поширеної термінології та здатність розрізняти схожі, але не тотожні концепції в екосистемі Java.*

* * *

### **11 ❓ Питання:**

Чи можна реалізувати інкапсуляцію для `static` полів? Як? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, можна і потрібно.** Принципи інкапсуляції застосовуються і до статичних членів класу.
>
> Якщо `static` поле представляє спільний для всіх об'єктів стан, який може змінюватися, його слід робити **`private`** і надавати доступ до нього через **`public static` методи**.
>
> **Приклад: лічильник створених об'єктів.**
>
> * **Неправильно (без інкапсуляції):**
>
>     ```java
>     public class Counter {
>         public static int count = 0; // Будь-хто може змінити ззовні
>         public Counter() { count++; }
>     }
>     // Зовнішній код: Counter.count = -100; // Порушили логіку
>     ```
>
>
> * **Правильно (з інкапсуляцією):**
>
>     ```java
>     public class Counter {
>         private static int count = 0; // Поле приховане
>
>         public Counter() {
>             count++;
>         }
>
>         // Публічний статичний "геттер" для отримання значення
>         public static int getCount() {
>             return count;
>         }
>         // Немає публічного сеттера, бо логіка інкременту контролюється конструктором
>     }
>     ```
>
>
> Тут ми приховали статичне поле `count` і надали лише метод для його читання. Це гарантує, що значення `count` буде змінюватися лише тоді, коли створюється новий об'єкт, як і передбачено логікою.

#### **📌 Що перевіряють:**

*Розуміння того, що принципи ООП застосовуються не тільки до об'єктів, але і до класів як таких.*

* * *

### **12 ❓ Питання:**

Уявіть, що поле класу має тип `List`. Як правильно реалізувати для нього геттер і сеттер, щоб не порушити інкапсуляцію? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Це класичний випадок, коли повернення прямого посилання на змінюваний об'єкт (`List`) може зруйнувати інкапсуляцію.
>
> **Правильна реалізація:**
>
> 1. **Геттер (`get`):** Повинен повертати або **захищену копію** списку, або його **незмінну обгортку (unmodifiable view)**. Це запобігає зміні внутрішнього стану об'єкта ззовні.
> 2. **Сеттер (`set`):** Повинен також приймати список, але всередині створювати **копію** переданого списку. Це захищає від ситуації, коли зовнішній код передає список, а потім змінює його, що несподівано вплинуло б на стан нашого об'єкта.
>
> **Приклад коду:**
>
> ```java
> import java.util.ArrayList;
> import java.util.Collections;
> import java.util.List;
>
> public class UserProfile {
>     private List<String> permissions;
>
>     public UserProfile() {
>         this.permissions = new ArrayList<>();
>     }
>
>     // ПРАВИЛЬНИЙ ГЕТТЕР: повертає незмінну обгортку
>     public List<String> getPermissions() {
>         return Collections.unmodifiableList(this.permissions);
>     }
>
>     // ПРАВИЛЬНИЙ СЕТТЕР: створює копію
>     public void setPermissions(List<String> permissions) {
>         // Перевірка на null для надійності
>         this.permissions = (permissions == null) ?
>             new ArrayList<>() :
>             new ArrayList<>(permissions);
>     }
>
>     // Методи для контрольованої зміни
>     public void addPermission(String permission) {
>         this.permissions.add(permission);
>     }
> }
> ```
>
> Таким чином, будь-яка зміна списку `permissions` відбувається лише через спеціалізовані методи (`addPermission`, `setPermissions`), які контролюються класом.

#### **📌 Що перевіряють:**

*Практичні навички написання "захищеного" (defensive) коду. Це питання для перевірки досвіду роботи зі змінюваними об'єктами.*

* * *

### **13 ❓ Питання:**

Як інкапсуляція реалізована в Java `record`'ах, введених в Java 16? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **`record`'и** в Java є спеціальним типом класів, призначених для створення **незмінних (immutable) носіїв даних**. Вони реалізують інкапсуляцію "за замовчуванням", але трохи інакше, ніж традиційні класи.
>
> **Як реалізована інкапсуляція в `record`'ах:**
>
> 1. **Поля є `private` і `final`:** Коли ви оголошуєте `record Person(String name, int age)`, компілятор автоматично генерує `private final String name;` та `private final int age;`. Це гарантує, що їх значення встановлюються один раз у конструкторі і не можуть бути змінені.
>
> 2. **Генеровані методи є публічними "акцесорами", а не "геттерами":** Компілятор генерує **публічні методи доступу**, але їхні імена не відповідають JavaBean конвенції. Замість `getName()` генерується метод `name()`. Ці методи повертають значення `private final` полів.
>
> 3. **Немає сеттерів:** Оскільки поля `final`, для них неможливо створити сеттери. Це підсилює незмінність.
>
> 4. **Канонічний конструктор:** Генерується публічний конструктор, який ініціалізує всі поля.
>
> **Приклад:**
> `public record Point(int x, int y) {}`
>
> Цей рядок еквівалентний (спрощено) такому класу:
>
> ```java
> public final class Point {
>     private final int x;
>     private final int y;
>
>     public Point(int x, int y) { /* ... */ }
>
>     public int x() { return this.x; }
>     public int y() { return this.y; }
>
>     // ... equals(), hashCode(), toString()
> }
> ```
>
> `record` є чудовим прикладом того, як мова може автоматично реалізувати найкращі практики інкапсуляції для створення незмінних об'єктів даних.

#### **📌 Що перевіряють:**

*Знання сучасних фіч мови Java та розуміння того, як вони спрощують реалізацію фундаментальних ООП-принципів.*

* * *

### **14 ❓ Питання:**

У чому різниця між інкапсуляцією та приховуванням інформації (information hiding)? Чи є це синонімами? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Ці терміни дуже тісно пов'язані, але вони **не є повними синонімами**. `Information Hiding` є більш загальним принципом дизайну, а `Encapsulation` — одним із способів його реалізації.
>
> * **Information Hiding (Приховування інформації):**
>   * Це **принцип проектування ПЗ** високого рівня.
>   * Його ідея полягає в тому, що **модуль (клас, пакет, сервіс) повинен приховувати свої дизайнерські рішення**, які з часом можуть змінитися. Це стосується не тільки даних, а й алгоритмів, внутрішніх структур, залежностей тощо.
>   * Мета — зменшити зв'язність між модулями.
>
> * **Encapsulation (Інкапсуляція):**
>   * Це **мовний механізм** (один з принципів ООП).
>   * Його ідея полягає в **об'єднанні даних та методів** в єдиний компонент (клас) та **обмеженні прямого доступу** до цих даних.
>
> **Як вони пов'язані:**
> **Інкапсуляція — це основний, але не єдиний, спосіб досягти приховування інформації.**
>
> Роблячи поля `private`, а методи — `public`, ми використовуємо інкапсуляцію для того, щоб приховати інформацію про внутрішнє представлення даних.
>
> Однак, приховування інформації може бути реалізовано і на інших рівнях. Наприклад, використання `package-private` доступу приховує реалізацію цілого пакета. Використання патерну `Factory` приховує логіку створення об'єктів.
>
> **Висновок:** Інкапсуляція — це про "зв'язування даних та методів в об'єкті з контролем доступу". Приховування інформації — це більш широка концепція про "приховування складних дизайнерських рішень у модулі".

#### **📌 Що перевіряють:**

*Глибоке, теоретичне розуміння принципів проектування. Здатність розрізняти концептуальні принципи та їхні конкретні реалізації в мові програмування. Це питання для рівня Senior.*

* * *

### **15 ❓ Питання:**

Поясніть на прикладі, як можна реалізувати "lazy initialization" (ліниву ініціалізацію) для поля, не порушуючи при цьому інкапсуляцію. ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Лінива ініціалізація** — це патерн, при якому створення "важкого" або рідко використовуваного ресурсу (об'єкта) відкладається до моменту, коли до нього відбувається перше звернення.
>
> **Інкапсуляція** є ключовою для реалізації цього патерну, оскільки дозволяє приховати логіку ініціалізації всередині геттера.
>
> **Приклад реалізації:**
>
> ```java
> public class UserProfile {
>     private String username;
>
>     // "Важкий" ресурс. Ми не хочемо завантажувати історію для кожного користувача,
>     // а тільки для того, у кого ми її запросимо.
>     private List<String> purchaseHistory; // Не ініціалізовано одразу
>
>     public UserProfile(String username) {
>         this.username = username;
>     }
>
>     // Геттер, який реалізує ліниву ініціалізацію
>     public List<String> getPurchaseHistory() {
>         // Перевіряємо, чи ресурс ще не було створено
>         if (this.purchaseHistory == null) {
>             // Створюємо його тільки при першому зверненні
>             System.out.println("Завантажуємо історію покупок для " + this.username);
>             this.purchaseHistory = loadHistoryFromDatabase(); // Виклик "важкого" методу
>         }
>         // Повертаємо посилання на (можливо, щойно створений) ресурс
>         return this.purchaseHistory;
>     }
>
>     private List<String> loadHistoryFromDatabase() {
>         // ... логіка звернення до БД ...
>         return new ArrayList<>(/* ... дані з БД ... */);
>     }
> }
> ```
>
> **Як інкапсуляція тут працює:**
>
> * Поле `purchaseHistory` є **`private`**. Зовнішній код не може дізнатися, чи воно `null`, чи вже ініціалізоване.
> * Логіка перевірки на `null` та виклику "важкого" методу `loadHistoryFromDatabase()` повністю **прихована всередині геттера**.
> * Для зовнішнього коду виклик `user.getPurchaseHistory()` виглядає як звичайний доступ до даних, що є чудовим прикладом приховування складності.
>
> **Примітка:** У багатопотоковому середовищі така проста реалізація не є безпечною і вимагатиме синхронізації (наприклад, з використанням double-checked locking).

#### **📌 Що перевіряють:**

*Знання поширених патернів проектування (Lazy Initialization) та здатність реалізувати їх, коректно використовуючи принципи ООП. Розуміння, як інкапсуляція дозволяє керувати життєвим циклом залежностей.*
