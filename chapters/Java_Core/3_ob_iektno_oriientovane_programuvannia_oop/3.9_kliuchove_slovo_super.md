---
layout: default
title: "Ключове слово super"
parent: "Об'єктно-орієнтоване програмування (ООП)"
grand_parent: "Java Core"
nav_order: 9
---

# Ключове слово super

* короткий опис: Спеціальне ключове слово, що дозволяє підкласу звертатися до членів (методів, полів або конструктора) батьківського класу.

* поняття: `super()`, `super.methodName()`, `super.fieldName`.

* приклади: Виклик конструктора батьківського класу (`super("name")`), виклик методу (`super.print()`), доступ до поля ( `super.value`).

* ключові моменти: `super()` має бути першим рядком у конструкторі підкласу.

* що важливо знати на співбесіді: Призначення `super`, відмінність від `this`.

### **✅ Офіційне визначення:**

**`super`** — це спеціальне ключове слово в Java, яке дозволяє отримати доступ до членів батьківського класу: методів,
полів або конструктора. Воно використовується в дочірньому класі для посилання на його суперклас.

### **🧠 Простими словами:**

**`super`
** — це як "папка вище". Якщо в підкласі ти хочеш звернутися до того, що вже є у батьківському класі — ти використовуєш **`super`**.

---

## **Основне**

|        Синтаксис         |                        Опис                        |
|:------------------------:|:--------------------------------------------------:|
|      **`super()`**       |           Виклик конструктора суперкласу           |
| **`super.methodName()`** |         Виклик методу батьківського класу          |
|  **`super.fieldName`**   | Доступ до поля батьківського класу (при конфлікті) |

---

## **Пояснення на пальцях (💡)**

У тебе є клас **`Animal`** з методом **`speak()`**, а також клас **`Dog`** `extends Animal`, де ти перевизначаєш цей
метод. Але все одно хочеш виконати логіку **`Animal`** -> тоді **`super.speak()`** — твій вибір.

У конструкторі підкласу першим рядком можна викликати конструктор суперкласу через **`super(...)`**.

Якщо поле в суперкласі має таку саму назву, як у підкласі — через **`super.field`** звертаєшся саме до нього.

---

## **Корисні приклади (🧪)**

🔹 **Виклик методу суперкласу:**

```java
class Animal {
    void speak() {
        System.out.println("Some sound");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        super.speak(); // виклик методу батьківського класу
        System.out.println("Bark");
    }
}
```

🔹 **Виклик конструктора суперкласу:**

```java
class Animal {
    Animal(String name) {
        System.out.println("Animal name: " + name);
    }
}

class Dog extends Animal {
    Dog() {
        super("Buddy"); // виклик конструктора суперкласу
        System.out.println("Dog created");
    }
}
```

🔹 **Доступ до полів суперкласу:**

```java
class Parent {
    String name = "Parent";
}

class Child extends Parent {
    String name = "Child";

    void printNames() {
        System.out.println(name);        // Child
        System.out.println(super.name);  // Parent
    }
}
```

---

## **Порівняння (⚖️)**

| Ключове слово |     Що означає      |               Доступ до               |
|:-------------:|:-------------------:|:-------------------------------------:|
|  **`this`**   |   Поточний обʼєкт   |     Поля і методи поточного класу     |
|  **`super`**  | Батьківський обʼєкт | Поля, методи, конструктори суперкласу |

---

## **🧠 Мнемоніка для запам’ятовування:**

📌 **`super`** \= звернення до “вищого рівня”

* **`super()`** — піднімаємось до конструктора
* **`super.method()`** — викликаємо метод з батьківського класу
* **`super.field`** — отримуємо поле з суперкласу

🗂 Уяви дерево наслідування як файлову систему, де **`super`** — це **`../`** до батьківської папки.

---

## **🟩 Підсумок:**

Ключове слово **`super`** допомагає дочірньому класу взаємодіяти зі своїм батьківським. Це необхідно для:

* повторного використання логіки,
* правильного ініціалізування успадкованих частин,
* уникнення конфліктів імен.

Розуміння **`super`** — це одна з основ грамотного ООП та динамічного поліморфізму.

---

### **🔗 Додаткові джерела:**

* [**Oracle Docs: Using the Keyword super**](https://docs.oracle.com/javase/tutorial/java/IandI/super.html)

Добре, я ознайомився з конспектом. На співбесідах на цю тему важливо чітко розрізняти **дві форми `super`**, знати правила їх використання (особливо для конструкторів), та розуміти, як `super` взаємодіє з **перевизначеними методами та прихованими полями**.

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке ключове слово `super` в Java? Назвіть дві основні форми його використання.

> #### **💬 Відповідь:**
>
> Ключове слово **`super`** — це спеціальне посилання, яке використовується всередині дочірнього класу для доступу до членів його **безпосереднього батьківського класу (суперкласу)**.
>
> Існують дві основні форми його використання:
>
> 1. **`super()` або `super(...)` (Виклик конструктора):**
>     * Використовується для виклику конструктора батьківського класу з конструктора дочірнього. Це дозволяє правильно ініціалізувати успадковану частину об'єкта.
>
> 2. **`super.member` (Доступ до членів):**
>     * Використовується для доступу до полів (`super.fieldName`) або методів (`super.methodName()`) батьківського класу. Це особливо корисно, коли вони були приховані або перевизначені у дочірньому класі.

#### **📝 Аналогія:**

`super` — це як звернення до вашого безпосереднього керівника на роботі. Якщо вам потрібен ресурс або дія, яка знаходиться в його компетенції (в батьківському класі), ви звертаєтеся до нього через "субординацію" (`super`), а не намагаєтеся робити його роботу самі.

#### **📌 Що перевіряють:**

*Базове розуміння призначення `super` та знання двох його основних синтаксичних форм.*

* * *

### **2 ❓ Питання:**

У чому основна різниця між `super()` та `this()`?

> #### **💬 Відповідь:**
>
> Хоча обидва виклики використовуються в конструкторах і мають схожий синтаксис, вони служать абсолютно різним цілям.
>
> | Характеристика | `super()` | `this()` |
> | :---: | :---: | :---: |
> | **Призначення** | Викликає конструктор **батьківського (супер) класу**. | Викликає **інший конструктор** того ж **самого (поточного) класу**. |
>
| **Де використовується** | У конструкторі дочірнього класу. | У перевантаженому конструкторі того ж класу. |
> | **Мета** | Ініціалізувати успадковану частину об'єкта. | Уникнути дублювання коду ініціалізації шляхом "ланцюгового" виклику конструкторів.|
>
> **Спільне правило:** І `super()`, і `this()` **повинні бути першим рядком** у тілі конструктора. Через це їх **не можна використовувати разом** в одному конструкторі.
>
> **Приклад:**
>
> ```java
> class Parent {
>     Parent(String s) { /* ... */ }
> }
> class Child extends Parent {
>     Child() { this("default"); } // Викликаємо інший конструктор Child
>
>     Child(String s) {
>         super(s); // Викликаємо конструктор Parent
>         // тут this() вже не можна
>     }
> }
> ```

#### **📌 Що перевіряють:**

*Чітке розмежування між зверненням до батьківського класу (`super()`) та зверненням до іншого конструктора в тому ж класі (`this()`).*

* * *

### **3 ❓ Питання:**

Коли і чому виклик `super()` є обов'язковим, а коли він додається неявно?

> #### **💬 Відповідь:**
>
> Правило таке: кожен об'єкт повинен бути повністю ініціалізованим, починаючи з найвищого предка в ієрархії.
>
> **Неявний виклик `super()`:**
>
> * Якщо ви **не робите явного виклику** `super(...)` або `this(...)` у конструкторі, компілятор Java **автоматично вставляє `super()`** (виклик конструктора без аргументів) як перший рядок.
>
>     ```java
>     class Child extends Parent {
>         Child() {
>             // Неявно тут стоїть super();
>             System.out.println("Конструктор Child");
>         }
>     }
>     ```
>
>
> **Обов'язковий явний виклик `super(...)`:**
>
> * Виклик `super(...)` стає обов'язковим, якщо **батьківський клас не має конструктора без аргументів (no-arg constructor)**.
> * Якщо всі конструктори батьківського класу вимагають параметри, компілятор не зможе вставити неявний `super()` і видасть **помилку компіляції**. В такому випадку ви зобов'язані явно викликати один з існуючих конструкторів батька і передати йому потрібні аргументи.
>
> ```java
> class Parent {
>     Parent(String name) { /* ... */ }
> }
> class Child extends Parent {
>     Child() {
>         // ПОМИЛКА! Немає Parent(). Потрібно явно викликати super(name).
>         super("defaultName"); // Тепер все добре
>     }
> }
> ```

#### **📌 Що перевіряють:**

*Знання правил ініціалізації та ланцюжка виклику конструкторів. Розуміння того, коли компілятор допомагає, а коли вимагає явних дій.*

* * *

### **4 ❓ Питання:**

Як викликати перевизначений метод батьківського класу з дочірнього? Наведіть приклад.

> #### **💬 Відповідь:**
>
> Для цього використовується синтаксис **`super.methodName()`**.
>
> Це необхідно, коли ви в дочірньому класі хочете не повністю замінити поведінку батьківського методу, а **розширити** її, викликавши спочатку логіку батька, а потім додавши свою.
>
> **Приклад:**
>
> ```java
> class Report {
>     public void generate() {
>         // Створює заголовок і підвал
>         System.out.println("--- HEADER ---");
>         // ...
>         System.out.println("--- FOOTER ---");
>     }
> }
>
> class HtmlReport extends Report {
>     @Override
>     public void generate() {
>         // 1. Спочатку викликаємо базову логіку батька
>         super.generate();
>
>         // 2. Потім додаємо власну, специфічну для HTML
>         System.out.println("Генеруємо HTML-тіло звіту...");
>     }
> }
> ```
>
> Таким чином, `HtmlReport` повторно використовує код генерації заголовка/підвалу з `Report` і додає лише те, що є унікальним для нього.

#### **📌 Що перевіряють:**

*Практичне розуміння, як `super` використовується для реалізації патерну розширення поведінки.*

* * *

### **5 ❓ Питання:**

Поясніть, що таке приховування полів (Field Hiding). Як за допомогою `super` можна отримати доступ до прихованого поля батька?

> #### **💬 Відповідь:**
>
> **Приховування полів** відбувається, коли дочірній клас оголошує поле з **такою ж назвою**, як і у батьківському. На відміну від методів, поля не перевизначаються, а поле дочірнього класу просто "приховує" поле батьківського.
>
> Щоб отримати доступ до значення саме **прихованого поля з батьківського класу**, використовується ключове слово `super`.
>
> **Приклад:**
>
> ```java
> class Parent {
>     String name = "Parent";
> }
>
> class Child extends Parent {
>     String name = "Child";
>
>     public void printNames() {
>         // this.name посилається на поле поточного класу (Child)
>         System.out.println("this.name: " + this.name); // Виведе "Child"
>
>         // super.name посилається на поле батьківського класу (Parent)
>         System.out.println("super.name: " + super.name); // Виведе "Parent"
>     }
> }
> ```
>
> **Чому це погана практика:**
>
> Приховування полів робить код дуже заплутаним і неінтуїтивним, оскільки доступ до поля починає залежати від того, чи використовується `this` або `super`. Загальна рекомендація — уникати однакових імен полів в ієрархії і робити поля `private`.

#### **📌 Що перевіряють:**

*Знання того, як `super` працює з полями, та розуміння, чому приховування полів є поганим стилем кодування.*

* * *

### **6 ❓ Питання:**

Чи можна використовувати `super` у `static` методі або `static` блоці? Чому?

> #### **💬 Відповідь:**
>
> **Ні, не можна.** Спроба використати `super` у статичному контексті призведе до **помилки компіляції**: `non-static variable super cannot be referenced from a static context`.
>
> **Пояснення:**
>
> * Ключове слово `super`, як і `this`, пов'язане з **конкретним екземпляром (об'єктом)**. `super` посилається на "батьківську частину" **поточного об'єкта**.
>
> * **Статичні методи та блоки**, навпаки, належать **класу**, а не об'єкту. Вони виконуються в контексті класу, коли ще може не існувати жодного екземпляра.
>
> Оскільки в статичному контексті немає поняття "поточний об'єкт" (немає `this`), то, відповідно, немає і його "батьківської частини" (немає `super`). Вони просто семантично несумісні.

#### **📌 Що перевіряють:**

*Глибоке розуміння різниці між `static` та instance-контекстами.*

* * *

### **7 ❓ Питання:**

Який конструктор буде викликано, якщо дочірній клас має кілька конструкторів, а батьківський — один? ⭐️

> #### **💬 Відповідь:**
>
> Це залежить від того, як реалізовані конструктори дочірнього класу.
>
> * Кожен конструктор дочірнього класу **повинен** (явно чи неявно) завершити свій ланцюжок викликів викликом одного з конструкторів батьківського класу.
> * Якщо в батьківському класі є **лише конструктор з параметрами** (і немає конструктора за замовчуванням), то **кожен конструктор** дочірнього класу **зобов'язаний явно викликати `super(...)`** з відповідними аргументами.
>
> **Приклад:**
>
> ```java
> class Parent {
>     public Parent(String name) { /* ... */ }
> }
>
> class Child extends Parent {
>     // Цей конструктор ПОВИНЕН викликати super(String)
>     public Child() {
>         super("Default Name"); // Явний виклик
>     }
>
>     // І цей конструктор теж ПОВИНЕН викликати super(String)
>     public Child(String name) {
>         super(name); // Явний виклик
>     }
> }
> ```
>
> Якщо прибрати хоча б один з `super(name)` у `Child`, код не скомпілюється, бо компілятор спробує вставити неіснуючий `super()` без аргументів.

#### **📌 Що перевіряють:**

*Знання ланцюжків виклику конструкторів у більш складних сценаріях.*

* * *

### **8 ❓ Питання:**

Що буде, якщо батьківський клас має лише `private` конструктор? Чи можна від нього успадкувати? ⭐️

> #### **💬 Відповідь:**
>
> **Ні, від такого класу не можна успадкувати** (за винятком вкладених класів).
>
> **Причина:**
>
> 1. Конструктор дочірнього класу зобов'язаний викликати конструктор батьківського класу.
> 2. `private` конструктор видимий лише всередині самого класу.
> 3. Тому з дочірнього класу немає ніякої можливості звернутися до `super()` або `super(...)`.
>
> Компілятор видасть помилку, що не може знайти доступний конструктор у суперкласі. Таким чином, роблячи всі конструктори класу приватними, ми фактично робимо клас **неявно `final`**.

#### **Виняток:**

* Якщо дочірній клас є вкладеним (nested) у батьківському, він має доступ до `private` членів, включаючи конструктор, і може успадкувати.
* Ця техніка використовується для заборони успадкування і часто застосовується в **утилітарних класах**, що містять лише `static` методи.

#### **📌 Що перевіряють:**

*Розуміння того, як модифікатори доступу для конструкторів впливають на можливість наслідування.*

* * *

### **9 ❓ Питання:**

Як викликати метод з "дідусевого" класу (тобто, через один рівень ієрархії)? Наприклад, `C` успадковує `B`, а `B` — `A`. Як з `C` викликати метод з `A`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Напряму — ніяк.** У Java не існує синтаксису типу `super.super.method()`.
>
> Ключове слово `super` дозволяє звернутися лише до **безпосереднього батька**.
>
> **Чому так зроблено:**
> Це зроблено для підтримки **принципу інкапсуляції** та зменшення зв'язності. Клас `C` не повинен знати про деталі реалізації класу `A` (свого "дідуся"). Він залежить лише від свого батька — класу `B`. Якби `C` міг "перестрибувати" через `B`, це б створило жорсткий зв'язок між `C` та `A` і зробило б ієрархію крихкою.
>
> **Як це можна зробити опосередковано:**
>
> Якщо вам дійсно потрібно викликати логіку з `A`, то клас `B` повинен надати таку можливість:
>
> ```java
> class A { public void doWork() { System.out.println("A"); } }
>
> class B extends A {
>     @Override
>     public void doWork() {
>         System.out.println("B");
>     }
>     // Надаємо доступ до логіки з A
>     public void doWorkFromA() {
>         super.doWork();
>     }
> }
>
> class C extends B {
>     @Override
>     public void doWork() {
>         // Тепер C може викликати метод з B, який викликає метод з A
>         super.doWorkFromA();
>     }
> }
> ```
>
> Але такий дизайн часто свідчить про проблеми в архітектурі.

#### **📌 Що перевіряють:**

*Глибоке розуміння того, як працює `super`, та принципів, що лежать в основі його обмежень. Знання, що ієрархія взаємодій є суворою.*

* * *

### **10 ❓ Питання:**

Що таке "ланцюжок конструкторів" (constructor chaining)? Яку роль у ньому відіграє `super()`? ⭐️

> #### **💬 Відповідь:**
>
> **Ланцюжок конструкторів** — це процес послідовного виклику конструкторів в ієрархії наслідування, починаючи з найвищого суперкласу (`Object`) і закінчуючи конструктором класу, об'єкт якого створюється.
>
> **Роль `super()`:**
>
> `super()` є **ланкою, що з'єднує** конструктор дочірнього класу з конструктором батьківського.
>
> **Процес:**
>
> 1. Коли ви створюєте `new Child()`, викликається конструктор `Child`.
> 2. Першим рядком у ньому (явно чи неявно) є `super()`, який викликає конструктор `Parent`.
> 3. Першим рядком у конструкторі `Parent` є `super()`, який викликає конструктор `Object`.
> 4. Конструктор `Object` виконується першим.
> 5. Потім виконується решта коду конструктора `Parent`.
> 6. І лише після цього виконується решта коду конструктора `Child`.
>
> Цей механізм гарантує, що об'єкт ініціалізується "зверху вниз", тобто всі успадковані частини об'єкта будуть готові до моменту, коли дочірній клас почне ініціалізувати свої власні поля.

#### **📌 Що перевіряють:**

*Знання процесу створення об'єкта та ініціалізації. Це фундаментальний аспект життєвого циклу об'єкта.*

* * *

### **11 ❓ Питання:**

Розгляньте цей код. Чому виникне помилка компіляції?

```java
class Parent {
    Parent() {
        System.out.println(this.hashCode());
    }
}
class Child extends Parent {
    private int value = initializeValue();
    Child() {
        super();
        System.out.println("Value: " + value);
    }
    private int initializeValue() {
        return 10;
    }
}
```

⭐️⭐️

> #### **💬 Відповідь:**
>
> В цьому коді помилки компіляції **не буде**. Він скомпілюється і виконається. Але цей приклад є чудовою ілюстрацією проблеми виклику не-фінальних методів з конструктора.
>
> Якщо змінити код трохи:
>
> `class Parent { public void doSomething() {} }`
> `class Child extends Parent { @Override public void doSomething() {} Child() { super.doSomething(); } }`
> Тут все коректно.
>
> **Якщо виклик відбувається з конструктора `Parent`**:
>
> ```java
> class Parent {
>     Parent() { doSomething(); }
>     public void doSomething() { System.out.println("Parent doSomething");}
> }
> class Child extends Parent {
>     private int value = 10;
>     @Override
>     public void doSomething() {
>         // На цей момент поле `value` ще не ініціалізовано!
>         System.out.println("Child doSomething, value = " + this.value);
>     }
> }
> new Child();
> ```
>
> **Результат:** `Child doSomething, value = 0`
>
> **Помилка логіки (а не компіляції):**
>
> 1. Викликається конструктор `Child`.
> 2. Він неявно викликає `super()` → конструктор `Parent`.
> 3. Конструктор `Parent` викликає метод `doSomething()`.
> 4. **Через поліморфізм**, викликається **перевизначена** версія `doSomething()` з класу `Child`.
> 5. **Але** на цей момент конструктор `Child` ще **не почав виконуватися**, і ініціалізація полів `Child` (як `value = 10`) **ще не відбулася**.
> 6. Тому `this.value` всередині `doSomething()` буде мати своє значення за замовчуванням (`0`), а не `10`.
>
> Це призводить до роботи з **не повністю ініціалізованим об'єктом**, що є небезпечним. Саме тому **не рекомендується викликати не-`final` і не-`private` методи з конструкторів**.

#### **📌 Що перевіряють:**

*Дуже глибоке розуміння порядку ініціалізації об'єкта та небезпек, пов'язаних з викликом поліморфних методів з конструкторів.*

* * *

### **12 ❓ Питання:**

Чи можна використовувати `super` та `this` для доступу до статичних методів? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Технічно так, але це вкрай погана практика.**
>
> Компілятор дозволяє писати такий код:
>
> ```java
> public class Test {
>     public static void staticMethod() {}
>     public void instanceMethod() {
>         this.staticMethod(); // Працює
>         super.toString();   // Якщо ми в підкласі, можна, але безглуздо
>         super.staticMethod(); // Не працює, бо super стосується екземпляра
>     }
> }
> ```
>
> Давайте виправимо.
>
> ```java
> public void instanceMethod() {
>     this.staticMethod(); // 1
>     super.staticMethod(); // 2
> }
> ```
>
> **Як це працює і чому це погано:**
>
> 1. **`this.staticMethod()` та `super.staticMethod()`:**
>     * Статичні методи належать класу, а не об'єкту. Коли компілятор бачить такий виклик, він **ігнорує** `this` або `super` і просто перетворює його на **прямий виклик через ім'я класу**.
>     * `this.staticMethod()` → `Test.staticMethod()`
>     * `super.staticMethod()` → `ParentClass.staticMethod()`
>
> **Проблема:**
> Такий код є **дуже заплутаним**. Він створює хибне враження, що викликається метод екземпляра, або що `super` працює зі статичним контекстом. Це порушує семантику `this` та `super` і ускладнює розуміння коду.
>
> **Правильний підхід:**
>
> Статичні методи **завжди** слід викликати **через ім'я класу**:
> `ClassName.staticMethod()`
> `ParentClassName.staticMethod()`
>
> Сучасні IDE завжди підкреслюють `this.staticMethod()` як "Static member accessed via instance reference".

#### **📌 Що перевіряють:**

*Розуміння того, як компілятор обробляє звернення до статичних членів. Знання найкращих практик для написання чистого коду.*

* * *

### **13 ❓ Питання:**

Як за допомогою `super` можна реалізувати захищену копію (defensive copy) для змінюваного поля при наслідуванні? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Розглянемо сценарій, коли і батьківський, і дочірній класи мають змінювані поля. `super` тут використовується для правильної ініціалізації батьківської частини.
>
> **Ідея:**
> Кожен клас у ієрархії відповідає за створення захищених копій **своїх власних** полів.
>
> **Приклад:**
>
> ```java
> import java.util.Date;
>
> class BaseEvent {
>     private final Date eventDate;
>
>     public BaseEvent(Date date) {
>         // 1. Створюємо захищену копію в конструкторі батька
>         this.eventDate = new Date(date.getTime());
>     }
>
>     public Date getEventDate() {
>         // 2. Повертаємо захищену копію
>         return new Date(this.eventDate.getTime());
>     }
> }
>
> class UserLoginEvent extends BaseEvent {
>     private final String username;
>
>     public UserLoginEvent(Date date, String username) {
>         // 3. Використовуємо super() для делегування створення
>         //    захищеної копії 'date' батьківському класу
>         super(date);
>         this.username = username;
>     }
> }
> ```
>
> **Як `super` допомагає:**
>
> 1. Конструктор `UserLoginEvent` приймає змінюваний об'єкт `Date`.
> 2. Він не копіює `Date` сам, а **делегує** цю відповідальність батьківському конструктору через `super(date)`.
> 3. Батьківський конструктор отримує `date` і створює власну внутрішню, захищену копію (`new Date(date.getTime())`), забезпечуючи, що його інваріанти не будуть порушені ззовні.
>
> Таким чином, `super()` використовується для правильного ланцюжка ініціалізації та інкапсуляції в ієрархії.

#### **📌 Що перевіряють:**

*Здатність застосовувати принципи проектування (defensive copying) у складних сценаріях з наслідуванням. Це питання на глибоке розуміння безпеки та незмінності.*

* * *

### **14 ❓ Питання:**

Чи можна використовувати `super()` поза конструктором? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, категорично не можна.**
>
> Виклик `super()` (з дужками) є **спеціальною синтаксичною конструкцією**, яка дозволена **виключно як перший рядок у тілі конструктора**.
>
> **Причина:**
>
> * `super()` — це не виклик звичайного методу. Це **механізм ініціалізації батьківської частини об'єкта**.
> * Ініціалізація об'єкта — це процес, що відбувається лише під час роботи конструктора. Він має чіткий порядок (від батька до нащадка).
>
> Спроба викликати `super()` з будь-якого іншого методу призведе до **помилки компіляції**. Компілятор просто не розпізнає такий синтаксис поза конструктором.
>
> ```java
> public void someMethod() {
>     super(); // ПОМИЛКА КОМПІЛЯЦІЇ: Call to 'super()' must be first statement in constructor body
> }
> ```
>
> Не слід плутати `super()` з `super.methodName()`, який є викликом методу і може використовуватися в будь-якому не-статичному методі дочірнього класу.

#### **📌 Що перевіряють:**

*Дуже точне знання синтаксичних правил мови. Це перевірка на уважність до деталей та розуміння різниці між ініціалізацією та звичайними викликами.*

* * *

### **15 ❓ Питання:**

Як працює `super` з `default` методами в інтерфейсах? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> З введенням `default` методів у Java 8 з'явився новий, особливий синтаксис для `super`, який дозволяє вирішувати конфлікти або викликати конкретну реалізацію з інтерфейсу.
>
> **Проблема ("Проблема ромба"):**
> Якщо клас реалізує два інтерфейси, `A` і `B`, і обидва мають `default` метод з однаковою сигнатурою, компілятор вимагає від класу явно вирішити конфлікт.
>
> **Вирішення за допомогою `super`:**
>
> Клас повинен перевизначити цей метод і може явно викликати реалізацію з одного з інтерфейсів, використовуючи такий синтаксис:
> **`InterfaceName.super.methodName()`**
>
> **Приклад:**
>
> ```java
> interface Speaker {
>     default void speak() { System.out.println("Говорить!"); }
> }
>
> interface Singer {
>     default void speak() { System.out.println("Співає!"); }
> }
>
> class Performer implements Speaker, Singer {
>     @Override
>     public void speak() {
>         // Явно обираємо, яку реалізацію викликати.
>         // Наприклад, реалізацію з Singer.
>         Singer.super.speak();
>     }
> }
> ```
>
> Цей синтаксис `InterfaceName.super` є унікальним для роботи з `default` методами і не схожий на звичайний `super`, який посилається на батьківський клас. Він дозволяє точно вказати, яку саме з успадкованих "поведінок" слід використати.

#### **📌 Що перевіряють:**

*Експертне знання сучасних можливостей Java. Розуміння того, як мова вирішує проблеми, що виникають з множинним "наслідуванням" поведінки через `default` методи.*
