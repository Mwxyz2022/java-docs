---
layout: default
title: "Статичні блоки ініціалізації (static {})"
parent: "Абстракція та Інтерфейси (поглиблено)"
grand_parent: "Java Core"
nav_order: 8
---

# Статичні блоки ініціалізації (static {})

* короткий опис: Блок коду, позначений `static`, що виконується один раз при першому завантаженні класу JVM. Використовується для ініціалізації статичних полів або складних одноразових налаштувань класу.

* поняття: `static {}`, ініціалізація класу.

* приклади: Ініціалізація статичних полів, завантаження конфігурацій.

* ключові моменти: Виконується один раз, до створення будь-яких об'єктів класу, не має доступу до `this`.

* що важливо знати на співбесіді: Порядок ініціалізації в Java.

### **✅ Офіційне визначення:**

Статичний блок ініціалізації — це блок коду, позначений **`static`**, який виконується **один раз** при першому завантаженні класу JVM. Його застосовують для ініціалізації статичних полів або виконання складних налаштувань, які не можна зробити в декларації.

🔗 [JLS §8.7 Static Initializers](https://docs.oracle.com/javase/specs/jls/se17/html/jls-8.html#jls-8.7)

### **🧠 Простими словами:**

**`static {}`** — це як твій один-єдиний ранковий ритуал, що виконується при запуску класу: один раз, без повторів.

---

## **Основне**

| Ознака | Значення |
| :---: | :---: |
| **Коли виконується** | При першому завантаженні класу JVM |
| **Скільки разів виконується** | Один раз, незалежно від кількості об’єктів |
| **Призначення** | Ініціалізація складних статичних полів, налаштування |
| **Має доступ до `static`** | ✅ Так |
| **Має доступ до `this`** | ❌ Ні — бо це не об'єкт |

---

## **Пояснення на пальцях (💡)**

### **Для чого це?**

Якщо треба один раз налаштувати клас: завантажити конфіг, відкрити ресурси, обчислити складні значення статичних змінних.

🔸 **Плюси:**  
Автоматичне виконання, без зайвих методів і викликів.

🔸 **Підводні камені:**  
Немає доступу до **`this`**, тому в блоці не можна звертатися до нестатичних полів чи методів

---

## **Корисні приклади (🧪)**

```java
public class Config {
    public static String CONFIG_PATH;

    static {
        System.out.println("Static block executed");
        CONFIG_PATH = System.getenv("CONFIG_PATH");
        if (CONFIG_PATH == null) {
            CONFIG_PATH = "/default/path/config.yml";
        }
    }

    public static void printPath() {
        System.out.println("Path: " + CONFIG_PATH);
    }
}

public class Main {
    public static void main(String[] args) {
        // Статичний блок виконається тут -- при першому зверненні до Config
        Config.printPath();
    }
}
```

**Вивід:**

```java
Static block executed
Path: /default/path/config.yml
```

---

## **Порівняння (⚖️)**

| Параметр | `static {}` | Конструктор |
| :---: | :---: | :---: |
| **Коли виконується** | Один раз — при завантаженні класу | Кожного разу — при створенні об’єкта |
| **Для кого** | Для класу | Для об’єкта |
| **Має доступ до `this`** | ❌ Ні | ✅ Так |
| **Часто використовується для** | Ініціалізації static полів | Ініціалізації стану об’єкта |

---

## **🧠 Мнемоніка для запам’ятовування:**

📌 **"static {} — один раз і назавжди"**

* **`static`** — належить класу
* **`{}`** — блок коду
* Виконується один раз, як і твій найулюбленіший ранковий ритуал ☕️

---

## **🟩 Підсумок:**

**`static {}`** — це зручний блок ініціалізації, що виконується один раз при завантаженні класу. Ідеально підходить для складної і одноразової ініціалізації статичних полів або налаштувань класу. Цей блок — наче майстер-перемикач, який готує клас до роботи, поки всі інші ще прокидаються.

---

### **🔗 Додаткові джерела:**

**🔗 [Oracle Java Tutorial: Static Initializers](https://docs.oracle.com/javase/tutorial/java/javaOO/initial.html)**

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке статичний блок ініціалізації (`static {}`) і яка його головна мета?

> #### **💬 Відповідь:**
>
> **Статичний блок ініціалізації** — це спеціальний блок коду всередині класу, позначений ключовим словом `static`, який виконується **один раз**, коли клас **вперше завантажується** Java Virtual Machine (JVM).
>
> **Головна мета:**
> Виконати **складну, одноразову ініціалізацію** статичних полів класу. Це необхідно, коли просте присвоєння при оголошенні поля є недостатнім.
>
> **Типові сценарії використання:**
>
> * Ініціалізація статичних колекцій (наприклад, `Map` або `Set`).
> * Обчислення значень для статичних констант, що вимагає кількох кроків.
> * Завантаження конфігураційних файлів або змінних середовища.
> * Завантаження нативних бібліотек (`System.loadLibrary()`).
> * Реєстрація драйверів (наприклад, JDBC).
>
> **Приклад:**
>
> ```java
> public class Constants {
>     public static final Map<String, Integer> MONTHS;
>
>     static {
>         MONTHS = new HashMap<>();
>         MONTHS.put("JANUARY", 1);
>         MONTHS.put("FEBRUARY", 2);
>         // ...
>     }
> }
> ```

#### **📌 Що перевіряють:**

*Базове розуміння того, що статичний блок — це інструмент для одноразової, складної ініціалізації на рівні класу.*

* * *

### **2 ❓ Питання:**

Коли саме виконується статичний блок?

> #### **💬 Відповідь:**
>
> Статичний блок виконується **рівно один раз** — у момент **ініціалізації класу** JVM.
>
> **Ініціалізація класу** відбувається **при першому активному використанні** цього класу. Активним використанням вважається:
>
> 1. Створення екземпляра класу (`new MyClass()`).
> 2. Виклик його **статичного методу**.
> 3. Звернення до його **статичного поля** (читання або запис), якщо воно не є константою часу компіляції.
> 4. Якщо цей клас є стартовим класом програми (має метод `main`).
> 5. Через рефлексію, якщо це явно вимагається.
>
> **Важливо:** просте оголошення змінної типу класу (`MyClass obj;`) не призводить до його завантаження чи ініціалізації.
>
> **Приклад:**
>
> ```java
> class MyClass {
>     static { System.out.println("MyClass initialized!"); }
> }
> // ...
> System.out.println("До");
> MyClass obj; // нічого не виведе
> System.out.println("Середина");
> obj = new MyClass(); // тут виведеться "MyClass initialized!"
> System.out.println("Після");
> ```

#### **📌 Що перевіряють:**

*Знання життєвого циклу класу в JVM та тригерів, що запускають його ініціалізацію.*

* * *

### **3 ❓ Питання:**

У якому порядку виконуються статичні блоки, блоки ініціалізації екземпляра та конструктори?

> #### **💬 Відповідь:**
>
> Порядок є чітко визначеним і відбувається у два етапи:
>
> **Етап 1: Ініціалізація класу (один раз)**
>
> 1. **Спочатку виконуються всі статичні ініціалізатори** (поля та `static {}` блоки) в тому порядку, в якому вони написані в коді. Це відбувається лише при першому завантаженні класу.
>
> **Етап 2: Ініціалізація екземпляра (при кожному `new`)**
> 2.  **Потім виконуються всі не-статичні (instance) ініціалізатори** (поля та блоки `{}`) у порядку їх оголошення.
> 3.  **В останню чергу виконується конструктор**.
>
> **Приклад:**
>
> ```java
> class Test {
>     static { System.out.println("Static block"); }
>     { System.out.println("Instance block"); }
>     Test() { System.out.println("Constructor"); }
> }
> new Test();
> new Test();
> ```
>
> **Вивід:**
>
> ```
>
> Static block
> Instance block
> Constructor
> Instance block
> Constructor
>
> ```
>
> Статичний блок виконав_ся_ лише один раз.

#### **📌 Що перевіряють:**

*Дуже детальне знання процесу створення об'єктів. Це одне з класичних питань на порядок ініціалізації.*

* * *

### **4 ❓ Питання:**

Як статичні блоки працюють в ієрархії наслідування? Що виконається раніше: статичний блок батька чи нащадка?

> #### **💬 Відповідь:**
>
> В ієрархії наслідування статична ініціалізація відбувається **"згори вниз"** — від найвищого суперкласу до самого дочірнього класу.
>
> **Правило:**
> Перед тим, як клас може бути ініціалізовано, **повинен бути ініціалізований його батьківський клас**.
>
> **Приклад:**
>
> ```java
> class Parent {
>     static { System.out.println("Parent static block"); }
> }
>
> class Child extends Parent {
>     static { System.out.println("Child static block"); }
> }
>
> public class Main {
>     public static void main(String[] args) {
>         new Child();
>     }
> }
> ```
>
> **Вивід:**
>
> ```
> Parent static block
> Child static block
> ```
>
> Коли JVM потрібно ініціалізувати `Child`, вона бачить, що його батько `Parent` ще не ініціалізований. Тому вона спочатку ініціалізує `Parent` (виконує його статичний блок), і лише після цього — `Child`.

#### **📌 Що перевіряють:**

*Розуміння ланцюжка ініціалізації в ієрархаті наслідування.*

* * *

### **5 ❓ Питання:**

Чи може статичний блок кинути виняток? Якщо так, то що станеться? ⭐️

> #### **💬 Відповідь:**
>
> **Так, може.**
>
> Якщо під час виконання статичного блоку виникає **неперехоплений виняток**, процес ініціалізації класу **завершується аварійно**.
>
> JVM перехоплює цей виняток і "загортає" його в **`ExceptionInInitializerError`**.
>
> **Наслідки є фатальними для класу:**
>
> 1. Клас переходить у **"зламаний" (uninitialized) стан**.
> 2. Будь-яка наступна спроба використати цей клас (створити об'єкт, викликати статичний метод) буде негайно призводити до **`NoClassDefFoundError`**. Повторної спроби ініціалізації не буде.
>
> **Приклад:**
>
> ```java
> public class BadInit {
>     static {
>         if (true) {
>             throw new RuntimeException("Помилка ініціалізації!");
>         }
>     }
> }
>
> try { new BadInit(); } catch (Throwable t) { t.printStackTrace(); } // -> ExceptionInInitializerError
> try { new BadInit(); } catch (Throwable t) { t.printStackTrace(); } // -> NoClassDefFoundError
> ```
>
> Тому будь-яка логіка в статичних блоках повинна бути надзвичайно надійною або мати коректну обробку винятків (наприклад, з перетворенням `checked` в `ExceptionInInitializerError`).

#### **📌 Що перевіряють:**

*Знання механізмів обробки помилок на рівні завантаження класів та розуміння наслідків `ExceptionInInitializerError`.*

* * *

### **6 ❓ Питання:**

Чому цей код не скомпілюється? `static { int x = value; } int value = 10;` ⭐️

> #### **💬 Відповідь:**
>
> Цей код не скомпілюється через **незаконне пряме посилання (illegal forward reference)**.
>
> **Правило:**
> Статичні члени ініціалізуються в тому порядку, в якому вони оголошені в класі. Ви **не можете звертатися до статичного поля напряму** у статичному блоці, який стоїть **перед** оголошенням цього поля.
>
> У даному прикладі:
>
> 1. Спочатку йде статичний блок `static { int x = value; }`.
> 2. На цей момент JVM починає обробляти цей блок, але оголошення `int value = 10;` ще не було виконано.
> 3. Спроба прочитати `value` є **"забіганням наперед"**.
>
> Компілятор виявляє цю проблему і видає помилку.
>
> **Як виправити:**
> Потрібно просто змінити порядок — спочатку оголосити поле, а потім використовувати його.
>
> ```java
> static int value = 10;
> static { int x = value; } // Тепер все добре
> ```

#### **📌 Що перевіряють:**

*Глибокі знання про строгі правила порядку ініціалізації в Java.*

* * *

### **7 ❓ Питання:**

Чи може статичний блок отримати доступ до не-статичних (instance) полів класу? Чому? ⭐️

> #### **💬 Відповідь:**
>
> **Ні, не може.** Це призведе до **помилки компіляції**.
>
> **Причина:**
>
> * Статичний блок виконується в **контексті класу**. Він запускається один раз при завантаженні класу, коли ще **не існує жодного екземпляра (об'єкта)** цього класу.
> * Не-статичні поля належать **конкретному екземпляру**. Вони існують, тільки коли об'єкт створено.
>
> Оскільки на момент виконання статичного блоку не існує об'єкта, то немає і його не-статичних полів, до яких можна було б звернутися. В статичному контексті також **немає посилання `this`**.
>
> Таким чином, `static` блок може працювати лише з іншими **`static` членами** класу.

#### **📌 Що перевіряють:**

*Розуміння різниці між `static` та `instance` контекстами та їхніми обмеженнями.*

* * *

### **8 ❓ Питання:**

Наведіть приклад, де статичний блок використовується для завантаження нативної бібліотеки.

> #### **💬 Відповідь:**
>
> Статичний блок є стандартним ідіоматичним місцем для завантаження нативних бібліотек (`.dll` на Windows, `.so` на Linux) за допомогою методу `System.loadLibrary()`.
>
> **Чому саме тут:**
>
> * Бібліотеку потрібно завантажити **лише один раз** на всю JVM.
> * Це потрібно зробити **до першого виклику** будь-якого `native` методу.
>
> Статичний блок ідеально відповідає цим вимогам, оскільки він виконується один раз при завантаженні класу.
>
> **Приклад:**
>
> ```java
> public class JniWrapper {
>
>     // Статичний блок для завантаження бібліотеки
>     static {
>         try {
>             // Завантажує бібліотеку "my_native_lib.so" або "my_native_lib.dll"
>             System.loadLibrary("my_native_lib");
>             System.out.println("Нативна бібліотека успішно завантажена.");
>         } catch (UnsatisfiedLinkError e) {
>             System.err.println("Не вдалося завантажити нативну бібліотеку.\n" + e);
>             // Часто тут програму завершують, бо без бібліотеки вона не може працювати
>             System.exit(1);
>         }
>     }
>
>     // Оголошення нативного методу, реалізація якого знаходиться в бібліотеці
>     public native void nativeMethod();
> }
> ```

#### **📌 Що перевіряють:**

*Практичні знання про Java Native Interface (JNI) та те, як `static` блок використовується для інтеграції з нативним кодом.*

* * *

### **9 ❓ Питання:**

Як порядок доступу до статичних полів може вплинути на порядок виконання статичних блоків у різних класах? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Порядок ініціалізації класів є **лінивим** і визначається тим, **коли до них відбувається перше активне звернення**. Порядок звернення до статичних полів може повністю змінити порядок виконання статичних блоків.
>
> **Приклад:**
>
> ```java
> class A {
>     static { System.out.println("Static A"); }
> }
> class B {
>     static { System.out.println("Static B"); }
> }
>
> // Сценарій 1
> public static void main(String[] args) {
>     new A();
>     new B();
> }
> // Вивід 1: Static A, Static B
>
> // Сценарій 2
> public static void main(String[] args) {
>     new B();
>     new A();
> }
> // Вивід 2: Static B, Static A
> ```
>
> **Складніший випадок із залежностями:**
>
> ```java
> class A {
>     static { System.out.println("A init"); }
> }
> class B {
>     public static final int VALUE = A.hashCode(); // Звернення до класу A
>     static { System.out.println("B init"); }
> }
>
> // main: new B();
> ```
>
> **Вивід буде:**
>
> ```
>
> A init
> B init
>
> ```
>
> Оскільки для ініціалізації `B.VALUE` потрібно звернутися до `A`, клас `A` буде ініціалізований **першим**, хоча в `main` ми звертаємось лише до `B`.
> Це демонструє, як залежності між статичними членами визначають порядок ініціалізації.

#### **📌 Що перевіряють:**

*Глибоке розуміння того, що ініціалізація класів є динамічним процесом, керованим потоком виконання програми.*

* * *

### **10 ❓ Питання:**

Чим `static` блок відрізняється від блоку ініціалізації екземпляра (`{}`)? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Вони схожі синтаксично, але кардинально відрізняються за своїм призначенням та життєвим циклом.
>
> | Характеристика | Статичний блок (`static {}`) | Блок екземпляра (`{}`) |
> | :---: | :---: | :---: |
> | **Коли виконується**| **Один раз**, при завантаженні класу. | **Кожного разу**, при створенні нового об'єкта. |
>
| **Призначення** | Ініціалізація **`static` полів**. | Ініціалізація **полів екземпляра**. |
> | **Контекст** | **Статичний**. Немає доступу до `this`. | **Екземпляра**. Є доступ до `this`. |
| **Порядок** | Виконується **до** створення будь-якого об'єкта.| Виконується **після** виклику `super()`, але **до** виконання коду конструктора. |
>
> По суті, `static` блок — це "конструктор для класу", а блок екземпляра — це спільний код, який буде неявно скопійовано на початок кожного конструктора. На практиці блок екземпляра використовується дуже рідко, оскільки ту саму логіку зазвичай краще розмістити в конструкторах або методах.

#### **📌 Що перевіряють:**

*Чітке розмежування двох типів ініціалізаційних блоків.*

* * *

### **11 ❓ Питання:**

Чи може клас мати декілька статичних блоків? Якщо так, що це означає? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, може.** Клас може мати будь-яку кількість статичних блоків.
>
> **Що це означає:**
>
> * Компілятор та JVM розглядають їх як **єдиний логічний блок**.
> * Вони будуть виконані **в тому порядку, в якому вони оголошені** у вихідному коді, зверху вниз.
>
> **Приклад:**
>
> ```java
> public class MultipleStaticBlocks {
>     static { System.out.println("First"); }
>     public static int a = 1;
>     static { System.out.println("Second, a = " + a); }
>     public static int b = 2;
>     static { System.out.println("Third, b = " + b); }
> }
> ```
>
> **Вивід при завантаженні класу:**
>
> ```
>
> First
> Second, a = 1
> Third, b = 2
>
> ```
>
> Хоча це синтаксично можливо, зазвичай **кращою практикою є об'єднання** всієї статичної логіки ініціалізації в один блок для кращої читабельності. Декілька блоків можуть бути виправдані, якщо вони логічно розділяють ініціалізацію різних груп статичних полів.

#### **📌 Що перевіряють:**

*Знання того, що декілька статичних блоків є валідним синтаксисом, та правил їхнього послідовного виконання.*

* * *

### **12 ❓ Питання:**

Що таке **циклічна залежність при ініціалізації класів**, і як статичні блоки можуть до неї призвести? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Циклічна залежність (Circular dependency)** виникає, коли для ініціалізації класу `A` потрібно ініціалізувати клас `B`, а для ініціалізації класу `B`, у свою чергу, потрібно ініціалізувати клас `A`.
>
> Це може призвести до **"зависання" (deadlock)** або до того, що один з класів буде використовуватися в **не повністю ініціалізованому стані**.
>
> **Як статичні блоки можуть це спричинити:**
>
> ```java
> public class A {
>     // Звернення до B, що тригерить його ініціалізацію
>     public static final B B_INSTANCE = new B();
>     static { System.out.println("A initialized"); }
> }
>
> public class B {
>     // Звернення до A, що тригерить його ініціалізацію
>     public static final A A_INSTANCE = new A();
>     static { System.out.println("B initialized"); }
> }
> ```
>
> **Сценарій, що призводить до проблеми:**
>
> 1. В `main` викликається `new A()`.
> 2. Починається ініціалізація `A`.
> 3. Статичний ініціалізатор `A` намагається створити `new B()`.
> 4. Починається ініціалізація `B`. JVM бачить, що клас `A` вже **в процесі ініціалізації** поточним потоком, і "чекає" на його завершення, але...
> 5. Статичний ініціалізатор `B` намагається створити `new A()`.
> 6. Тут і виникає проблема. Зазвичай, це призводить до `StackOverflowError`, якщо рекурсія проста, або до тонкого `deadlock`-у у складніших багатопотокових сценаріях. JVM може "зависнути" або кинути `ExceptionInInitializerError`.
>
> Це є серйозною архітектурною проблемою, якої слід уникати, проектуючи однонаправлені залежності.

#### **📌 Що перевіряють:**

*Розуміння складних проблем, що виникають при ініціалізації класів. Здатність аналізувати залежності між класами.*

* * *

### **13 ❓ Питання:**

Поясніть, чому статичний блок ініціалізації є кращим місцем для реєстрації JDBC-драйвера (`Class.forName("...")`) порівняно з іншими місцями. ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Історично (до JDBC 4.0), реєстрація JDBC-драйвера вимагала явного завантаження його класу в JVM. Для цього використовували `Class.forName("com.mysql.cj.jdbc.Driver")`.
>
> **Статичний блок ідеально підходить для цього з кількох причин:**
>
> 1. **Гарантоване одноразове виконання:** Драйвер потрібно зареєструвати в `DriverManager` **лише один раз** на всю програму. Статичний блок гарантує, що цей код виконається рівно один раз при першому зверненні до класу (наприклад, класу-репозиторію, що працює з БД).
>
> 2. **Виконання в потрібний момент:** Код виконається "ліниво", саме тоді, коли програма почне працювати з базою даних, а не одразу при старті всього додатку.
>
> 3. **Обробка винятків:** `Class.forName()` може кинути `ClassNotFoundException` (це `checked` виняток). Статичний блок дозволяє обернути цей виклик у `try-catch` і коректно обробити помилку (наприклад, кинути `ExceptionInInitializerError`, якщо драйвер відсутній, що призведе до "падіння" програми).
>
> **Приклад:**
>
> ```java
> public class DatabaseConnection {
>     static {
>         try {
>             Class.forName("com.mysql.cj.jdbc.Driver");
>         } catch (ClassNotFoundException e) {
>             throw new RuntimeException("Не знайдено JDBC драйвер!", e);
>         }
>     }
>     // ...
> }
> ```
>
> **Сучасний підхід (JDBC 4.0+):**
> Зараз це вже не є обов'язковим. Сучасні JDBC-драйвери використовують механізм `ServiceLoader`, який автоматично знаходить та реєструє драйвери, що знаходяться в classpath.

#### **📌 Що перевіряють:**

*Знання історичних патернів та того, як вони були реалізовані за допомогою базових конструкцій мови. Розуміння `Class.forName`.*

* * *

### **14 ❓ Питання:**

Як можна "протестувати" логіку, яка знаходиться всередині статичного блоку? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Тестування статичних блоків є **дуже складним**, і це одна з причин, чому слід **уникати розміщення в них складної бізнес-логіки**.
>
> **Проблеми тестування:**
>
> * Статичний блок виконується лише один раз, коли клас завантажується в JVM. У стандартному життєвому циклі юніт-тестів (наприклад, JUnit) ви **не можете "перезапустити"** ініціалізацію класу для кожного тесту.
> * Логіка тісно прив'язана до класу і її не можна "підмінити" за допомогою mock-об'єктів.
>
> **Підходи до тестування:**
>
> 1. **Рефакторинг (найкращий варіант):**
>     * Винести **всю логіку** зі статичного блоку в окремий **`public static` метод**.
>     * У статичному блоці залишити лише виклик цього методу.
>     * Тепер ви можете **тестувати цей `public static` метод безпосередньо**, ізольовано від процесу завантаження класу. Це також полегшує тестування за допомогою таких інструментів, як PowerMock, якщо потрібно мокати інші статичні виклики.
>
> 2. **Використання окремого `ClassLoader`'а:**
>     * Це дуже просунута техніка. У кожному тесті ви можете створити новий `ClassLoader`, завантажити клас заново і тим самим змусити статичний блок виконатися ще раз. Це дуже складно і крихко.
>
> 3. **Використання інструментів типу PowerMock:**
>     * PowerMock дозволяє "мокати" статичні методи, приватні методи та конструктори. З його допомогою можна "придушити" виконання статичного блоку за допомогою анотації `@SuppressStaticInitializationFor`.
>
> **Висновок:** Найкращий спосіб — це виносити логіку з статичних блоків у тестовані статичні методи.

#### **📌 Що перевіряють:**

*Розуміння проблем тестованості статичного коду та знання просунутих технік та інструментів для його тестування.*

* * *

### **15 ❓ Питання:**

Поясніть, що станеться, якщо кілька потоків одночасно спробують ініціалізувати клас зі статичним блоком. Чи є цей процес потокобезпечним? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, цей процес є повністю потокобезпечним.**
>
> **JVM гарантує**, що ініціалізація класу (включаючи виконання статичних блоків) виконується **атомарно та лише один раз**.
>
> **Як це працює "під капотом":**
>
> 1. Коли перший потік намагається ініціалізувати клас, він отримує **внутрішнє блокування (lock)** на об'єкті, що представляє цей клас (`java.lang.Class`).
> 2. Він починає виконувати статичні ініціалізатори.
> 3. Якщо в цей же час інші потоки намагаються ініціалізувати той самий клас, вони **блокуються** і змушені **чекати**, доки перший потік не завершить ініціалізацію.
> 4. Після того, як перший потік завершив ініціалізацію (успішно чи з помилкою), він звільняє блокування.
> 5. Інші потоки "прокидаються" і бачать, що клас вже ініціалізований, тому вони просто продовжують свою роботу, не виконуючи статичні блоки повторно.
>
> Саме ця гарантія потокобезпечності від JVM робить патерн **Initialization-on-demand holder idiom** для Singleton'ів таким надійним. Він повністю покладається на те, що JVM коректно обробить одночасну ініціалізацію статичного вкладеного класу.

#### **📌 Що перевіряють:**

*Експертне розуміння механізмів багатопотоковості на рівні JVM та життєвого циклу класів. Це дуже глибоке питання, що стосується специфікації мови.*
