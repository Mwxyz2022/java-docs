---
layout: default
title: "Константи (final static)"
parent: "Абстракція та Інтерфейси (поглиблено)"
grand_parent: "Java Core"
nav_order: 11
---

# Константи (final static)

* короткий опис: Комбінація модифікаторів `static` та `final`, що створює константу – змінну, яка належить класу і не може бути змінена після її ініціалізації.

* поняття: `static final`, константа.

* приклади: `public static final int MAX_VALUE = 100;`, `public static final String APP_NAME = "My App";`.

* ключові моменти: Універсальне та незмінне значення, доступне через ім'я класу. Зазвичай іменуються великими літерами з підкресленнями.

* що важливо знати на співбесіді: Призначення констант, правила іменування.

### **✅ Офіційне визначення:**

**`final`** — модифікатор, який забороняє змінювати змінну після її ініціалізації. У парі з **`static`** (тобто **`static`** `final`) це дає нам константу — значення, яке належить класу і не змінюється.

**🔗 [JLS §4.12.4 Final Variables](https://docs.oracle.com/javase/specs/jls/se17/html/jls-4.html#jls-4.12.4)**

### **🧠 Простими словами:**

**`static final`** — це змінна, яка:

* є одна на весь клас (**`static`**),
* і при цьому незмінна (**`final`**).  s
  Іншими словами, константа. 😄

---

## **Основне**

| Компонент | Пояснення |
| :---: | :---: |
| **`static`** | Одна спільна копія для всіх об’єктів |
| **`final`** | Значення не можна змінити після ініціалізації |
| **`static final`** | Константа — спільне і незмінне значення |
| **Іменування** | Великі літери з підкресленнями (**`MAX_USERS`**) — щоб не загубити в коді |

---

## **Пояснення на пальцях (💡)**

### 🔸 **Навіщо це потрібно?**  

Щоб мати фіксовані значення, які не повинні змінюватися, наприклад: кількість днів у тижні, константу π, пороги тощо.

🔸 **Де зручно використовувати?**  
У утилітарних класах (**`Math.PI`**), для фіксованих налаштувань (**`MAX_USERS`**, **`MIN_AGE`**), щоб уникнути «магічних чисел» в коді.

### 🔸 **Типова помилка:**  

Спроба змінити **`final`** змінну — це помилка компіляції. Комп’ютер не дасть спокою\

---

## **Корисні приклади (🧪)**

```java
public class Constants {
    public static final int MAX_USERS = 100;
    public static final String APP_NAME = "SuperApp";
    public static final double PI = 3.1415926535;

    // Приватний конструктор, щоб уникнути створення об'єктів класу
    private Constants() {}
}

public class Main {
    public static void main(String[] args) {
        System.out.println(Constants.MAX_USERS);  // 100
        System.out.println(Constants.APP_NAME);   // SuperApp
        System.out.println(Constants.PI);         // 3.1415926535
    }
}
```

---

## **Порівняння: `final`, `static`, `static final` (⚖️)**

| Модифікатор | Пояснення | Приклад |
| :---: | :---: | :---: |
| **`final`** | Змінна незмінна | **`final int x = 10;`** |
| **`static`** | Спільна для всіх об’єктів | **`static int count = 0;`** |
| **`static final`** | Константа — спільна та незмінна | **`static final int MAX = 50;`** |

---

## **🧠 Мнемоніка для запам’ятовування:**

📌 **"static final \= ЗАВЖДИ ОДНА, І ЗАВЖДИ ТАКА САМА"**

* 🧠 **`static`** -> одна на клас
* 🧠 **`final`** -> незмінна
* 🧠 разом **`static`** `final` -> константа

---

## **🟩 Підсумок:**

**`static final`** — це константа, яка є незмінною і спільною для всіх екземплярів класу. Ідеально підходить для фіксованих значень, які ніколи не змінюються. Використання таких констант покращує читабельність, гнучкість і підтримуваність коду — і твій код стає сильнішим за будь-які хакерські атаки (ну майже).

---

### **🔗 Додаткові джерела:**

**🔗 [Oracle Java Tutorial: Constants with static final](https://docs.oracle.com/javase/tutorial/java/nutsandbolts/variables.html#final)**

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке константа в Java і як її правильно оголосити?

> #### **💬 Відповідь:**
>
> **Константа** — це поле, значення якого **не можна змінити** після першої ініціалізації, і яке є **спільним для всього класу**.
>
> Для створення константи використовується комбінація двох ключових слів:
>
> 1. **`static`**: Робить поле **членом класу**, а не екземпляра. Це гарантує, що константа існує в **єдиному екземплярі**.
> 2. **`final`**: Гарантує, що значення поля може бути присвоєне **лише один раз**.
>
> **Правильне оголошення (іменна конвенція):**
>
> * Назва пишеться **великими літерами**, а слова розділяються **підкресленням** (`SNAKE_CASE`).
> * Зазвичай, константи роблять `public`, щоб вони були доступні з будь-якого місця.
>
> **Приклад:**
>
> ```java
> public class AppConfig {
>     public static final int MAX_CONNECTION_POOL_SIZE = 50;
>     public static final String DEFAULT_GREETING = "Hello, World!";
> }
> ```
>
> Використання констант дозволяє уникнути "магічних чисел" і рядків у коді, роблячи його більш читабельним і легким у підтримці.

#### **📌 Що перевіряють:**

*Знання стандартного способу оголошення констант та конвенції їхнього іменування.*

* * *

### **2 ❓ Питання:**

Яка різниця між `final` полем та `static final` полем?

> #### **💬 Відповідь:**
>
> Різниця полягає в тому, чи є константа **властивістю об'єкта** чи **властивістю всього класу**.
>
> **`final` поле (не-`static`):**
>
> * **Що це:** Це **константа екземпляра**.
> * **Кількість:** Кожен об'єкт має **свою власну копію** цієї константи.
> * **Ініціалізація:** Її значення зазвичай встановлюється в конструкторі і є унікальним для кожного об'єкта.
> * **Приклад:**
>     `class User { private final long creationTimestamp; }`
>     Кожен користувач матиме свій власний, незмінний час створення.
>
> **`static final` поле:**
>
> * **Що це:** Це **константа класу**.
> * **Кількість:** Існує в **єдиному екземплярі**, спільному для всіх об'єктів цього класу.
> * **Ініціалізація:** Ініціалізується один раз при завантаженні класу.
> * **Приклад:**
>     `class MathConstants { public static final double PI = 3.14159; }`
>     Значення `PI` одне для всіх.
>
> **Коротко:** `final` — константа для **об'єкта**, `static final` — константа для **класу**.

#### **📌 Що перевіряють:**

*Чітке розмежування між рівнем класу та об'єкта при застосуванні `final`.*

* * *

### **3 ❓ Питання:**

Що таке **константа часу компіляції (compile-time constant)**? Як `static final` пов'язаний з нею?

> #### **💬 Відповідь:**
>
> **Константа часу компіляції** — це `static final` змінна, значення якої є **відомим на етапі компіляції**.
>
> **Вимоги:**
>
> * Поле повинно бути оголошене як `static final`.
> * Воно має бути ініціалізоване **виразом, що складається лише з літералів або інших констант часу компіляції**.
>
> **Приклади:**
>
> ```java
> // ЦЕ є константою часу компіляції
> public static final int SECONDS_IN_MINUTE = 60;
> public static final String GREETING = "Hello";
>
> // ЦЕ НЕ є константою часу компіляції
> // Хоча вона static final, її значення визначається в runtime
> public static final long START_TIME = System.currentTimeMillis();
> ```
>
> **Чому це важливо:**
>
> **Оптимізація компілятора:** Якщо змінна є константою часу компіляції, компілятор може **"вбудувати" (inline)** її значення безпосередньо в байткод, де вона використовується.
>
> **Наприклад:**
> `int totalSeconds = minutes * SECONDS_IN_MINUTE;`
>
> може бути перетворено компілятором на:
> `int totalSeconds = minutes * 60;`
>
> Це робить код більш продуктивним.

#### **📌 Що перевіряють:**

*Розуміння того, як `static final` впливає на процес компіляції та як це використовується для оптимізації.*

* * *

### **4 ❓ Питання:**

Де можна ініціалізувати `static final` поле?

> #### **💬 Відповідь:**
>
> Оскільки `static final` поле має бути ініціалізоване **рівно один раз** при завантаженні класу, існують лише **два** можливих місця для його ініціалізації:
>
> **1. Безпосередньо при оголошенні:**
>
> * Це найпростіший і найпоширеніший спосіб для простих констант.
>
> ```java
> public static final int MAX_ATTEMPTS = 3;
> ```
>
> **2. У статичному блоці ініціалізації (`static {}`):**
>
> * Цей підхід використовується, коли для обчислення значення константи потрібна **складна логіка**, яка не вміщується в один рядок (наприклад, заповнення колекції, обробка винятків).
>
> ```java
> public static final Map<Integer, String> ERROR_CODES;
>
> static {
>     ERROR_CODES = new HashMap<>();
>     ERROR_CODES.put(404, "Not Found");
>     ERROR_CODES.put(500, "Internal Server Error");
> }
> ```
>
> Спроба ініціалізувати `static final` поле в будь-якому іншому місці (наприклад, у конструкторі) призведе до помилки компіляції.

#### **📌 Що перевіряють:**

*Знання правил ініціалізації для статичних членів класу.*

* * *

### **5 ❓ Питання:**

Чому константи прийнято іменувати у верхньому регістрі, використовуючи `SNAKE_CASE`?

> #### **💬 Відповідь:**
>
> Це є сталою **конвенцією іменування (naming convention)** у Java та багатьох інших мовах.
>
> **Причини:**
>
> 1. **Читабельність:** Такий стиль **візуально виділяє** константи в коді. Коли розробник бачить змінну `MAX_USERS`, він одразу розуміє, що це константа, її значення є фіксованим і її не можна змінити. Це зменшує когнітивне навантаження.
>
> 2. **Запобігання помилкам:** Оскільки візуально легко відрізнити константу від звичайної змінної, це зменшує ризик випадково спробувати її змінити.
>
> 3. **Історична традиція:** Ця конвенція прийшла з мови C, де `UPPER_SNAKE_CASE` використовувався для макросів препроцесора, які поводилися як константи. Цю практику було перейнято в Java для `static final` полів.
>
> Хоча компілятор не вимагає такого стилю, його дотримання є ознакою професіоналізму та полегшує командну роботу.

#### **📌 Що перевіряють:**

*Знання стандартних конвенцій кодування в Java.*

* * *

### **6 ❓ Питання:**

Яка небезпека пов'язана з `public static final` полем, якщо його тип є змінюваним (mutable)? Наведіть приклад. ⭐️

> #### **💬 Відповідь:**
>
> Це дуже поширена помилка. Ключове слово `final` для посилальних типів робить **незмінним лише посилання**, а **не сам об'єкт**, на який воно вказує.
>
> **Небезпека:**
>
> Якщо `static final` поле є посиланням на **змінний об'єкт** (наприклад, `ArrayList`, `HashMap` або кастомний `POJO` зі сеттерами), то будь-яка частина коду може отримати це посилання і **змінити внутрішній стан** цього об'єкта.
>
> **Приклад проблеми:**
>
> ```java
> public final class AppConfig {
>     public static final List<String> ADMIN_EMAILS = new ArrayList<>();
>
>     static {
>         ADMIN_EMAILS.add("admin@example.com");
>     }
> }
>
> //... десь в іншому коді:
> AppConfig.ADMIN_EMAILS.add("hacker@example.com"); // Ми щойно додали хакера!
> AppConfig.ADMIN_EMAILS.clear(); // Або взагалі видалили всіх адмінів!
> ```
>
> `final` захищає лише від `AppConfig.ADMIN_EMAILS = new ArrayList<>();`, але не від зміни вмісту списку.
>
> **Як правильно створити незмінну константну колекцію:**
>
> Слід використовувати **незмінні обгортки** з класу `Collections` або методи `List.of()`/`Map.of()` (з Java 9).
>
> ```java
> // Правильний підхід
> public static final List<String> ADMIN_EMAILS =
>     Collections.unmodifiableList(Arrays.asList("admin@example.com"));
> ```

#### **📌 Що перевіряють:**

*Глибоке розуміння того, як `final` працює з посилальними типами. Кандидат повинен знати, як створювати справді незмінні колекції.*

* * *

### **7 ❓ Питання:**

Чи можна використовувати інтерфейси для зберігання констант? Чому це вважається антипатерном? ⭐️

> #### **💬 Відповідь:**
>
> **Технічно так, можна.** Будь-яке поле, оголошене в інтерфейсі, є неявно `public static final`, що робить його константою.
>
> **Чому це вважається антипатерном (Constant Interface Antipattern):**
>
> 1. **Неправильне використання інтерфейсу:** Інтерфейси призначені для визначення **контракту поведінки** ("що клас вміє робити"), а не для зберігання даних. Використання їх як контейнерів для констант є зловживанням цим механізмом.
>
> 2. **Забруднення простору імен:** Якщо клас реалізує такий інтерфейс (`class MyClass implements Constants`), він **успадковує** всі ці константи у свій власний простір імен. Це може призвести до конфліктів і робить незрозумілим, звідки ці константи взялися.
>
> 3. **Погана інкапсуляція:** Це є деталлю реалізації, яка "просочується" в публічний API класу.
>
> **Як правильно:**
>
> 1. Для констант слід створювати **утилітарний `final` клас** з `private` конструктором.
>
>     ```java
>     public final class AppConstants {
>         private AppConstants() {} // Забороняємо створення екземплярів
>         public static final int TIMEOUT = 5000;
>     }
>     ```
>
> 2. Потім використовувати ці константи через **статичний імпорт**.
>     `import static com.example.AppConstants.TIMEOUT;`
>
> Це робить код чистішим, а наміри — яснішими.

#### **📌 Що перевіряють:**

*Знання поширених антипатернів та найкращих практик проектування.*

* * *

### **8 ❓ Питання:**

Навіщо в утилітарному класі з константами робити приватний конструктор? ⭐️

> #### **💬 Відповідь:**
>
> Приватний конструктор в утилітарному класі, що містить лише `public static final` константи (або `static` методи), є **захисним механізмом**.
>
> **Його мета — заборонити створення екземплярів цього класу.**
>
> * Оскільки всі члени класу статичні, немає жодного сенсу створювати його об'єкт (`new MyConstants()`).
> * Якщо не оголосити жодного конструктора, компілятор автоматично згенерує **публічний конструктор за замовчуванням**.
> * Це дозволить іншим розробникам створювати безглузді об'єкти цього класу, що може ввести в оману.
>
> Створюючи **`private` конструктор**, ви робите неможливим інстанціювання цього класу ззовні і **явно виражаєте намір**, що цей клас призначений лише для статичного доступу.
>
> ```java
> public final class AppConfig {
>     // Цей конструктор робить клас неінстанційованим
>     private AppConfig() {
>         throw new AssertionError("Цей клас не можна інстанціювати");
>     }
>     public static final int TIMEOUT = 1000;
> }
> ```
>
> Кидання `AssertionError` є додатковою практикою, яка захищає від виклику конструктора навіть зсередини самого класу.

#### **📌 Що перевіряють:**

*Розуміння патерну Utility Class та способів його коректної реалізації.*

* * *

### **9 ❓ Питання:**

Як впливає ініціалізація `static final` константи часу компіляції на залежність між класами? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Це дуже цікавий аспект оптимізації. Якщо константа є **константою часу компіляції**, компілятор може **вбудувати (inline)** її значення, що може **усунути залежність між класами на рівні байткоду**.
>
> **Приклад:**
>
> ```java
> // В бібліотеці:
> public class LibConstants {
>     public static final int VERSION = 1;
> }
>
> // У вашому коді:
> public class MyApp {
>     public void checkVersion() {
>         if (someVar == LibConstants.VERSION) { ... }
>     }
> }
> ```
>
> На етапі компіляції, компілятор бачить, що `LibConstants.VERSION` є константою часу компіляції зі значенням `1`. Він замінює `LibConstants.VERSION` на `1` безпосередньо в байткоді `MyApp.class`.
>
> **Наслідок:**
>
> * **Проблема:** Якщо ви оновите бібліотеку, і `VERSION` стане `2`, ваш `MyApp` **продовжить працювати зі старим значенням `1`**, оскільки воно "зашито" в його `.class` файлі. Ви не отримаєте помилку, але логіка буде неправильною. Вам доведеться **перекомпілювати** `MyApp` з новою версією бібліотеки.
> * **Перевага:** Якщо клас `LibConstants` видалити, `MyApp` продовжить працювати (доки його не перекомпілюють), бо він більше від нього не залежить.
>
> Це не стосується `static final` змінних, які не є compile-time constants. У такому випадку залежність залишається.

#### **📌 Що перевіряють:**

*Глибоке розуміння того, як працюють компілятор та завантажувач класів, та які неочевидні проблеми можуть виникнути з константами.*

* * *

### **10 ❓ Питання:**

Розглянемо `enum`. Чи можна сказати, що кожна його константа є `public static final`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, по суті, саме так.**
>
> Коли ви оголошуєте `enum`:
> `public enum Status { NEW, DONE; }`
>
> Компілятор "під капотом" перетворює це на клас, де кожна константа є **`public static final` полем**, тип якого — сам клас `Status`.
>
> Спрощена трансформація:
>
> ```java
> public final class Status extends Enum<Status> {
>     public static final Status NEW = new Status("NEW", 0);
>     public static final Status DONE = new Status("DONE", 1);
>
>     private static final Status[] $VALUES = { NEW, DONE };
>     // ... private конструктор, методи values(), valueOf() ...
> }
> ```
>
> **Чому це важливо:**
>
> * **`public`:** Константа доступна глобально.
> * **`static`:** Вона належить класу `Status`, а не його екземпляру (хоча сама і є екземпляром).
> * **`final`:** Посилання на екземпляр (`NEW`) не може бути змінено.
>
> Це гарантує, що `Status.NEW` — це **синглтон**, унікальний на всю JVM, що і є однією з головних переваг `enum` над `static final int` константами.

#### **📌 Що перевіряють:**

*Розуміння того, як `enum` реалізований на низькому рівні, та його зв'язок з `public static final` полями.*

* * *

### **11 ❓ Питання:**

Що виведе цей код і чому?

```java
public class A {
    public static final B b_instance = new B();
}

public class B {
    public static final int VALUE = 10;
    static { System.out.println("B Initialized"); }
}
//... main: System.out.println(A.b_instance.VALUE);
```

> #### **💬 Відповідь:**
>
> Цей код виведе **`B Initialized`**, а потім **`10`**.
>
> Це хитрий приклад з "пасткою" для констант.
>
> 1. `VALUE` не є *compile-time* константою для класу А.

Давайте проаналізуємо.
Ні, VALUE є константою часу компіляції. Я помилився. Давайте виправлю логіку.

* * *

#### **Змінена відповідь на питання №11:**

> #### **💬 Відповідь:**
>
> Цей код **скомпілюється**, але **не виведе "B Initialized"**. Він виведе лише **`10`**.
>
> **Пояснення:**
>
> 1. Звернення відбувається до `A.b_instance.VALUE`. Здається, що для доступу до `VALUE` потрібно ініціалізувати об'єкт `b_instance`, що, у свою чергу, вимагає ініціалізації класу `A` та `B`.
>
> 2. **Але** `B.VALUE` (`public static final int VALUE = 10`) є **константою часу компіляції (compile-time constant)**.
>
> 3. Через оптимізацію, компілятор **вбудовує (inlines)** значення цієї константи. Він бачить, що `A.b_instance` має тип `B`, і що поле `VALUE` в `B` є константою зі значенням 10.
>
> 4. Тому весь вираз `A.b_instance.VALUE` **на етапі компіляції замінюється** просто на літерал `10`.
>
> 5. В результаті, **під час виконання (runtime)**, код еквівалентний `System.out.println(10);`.
>
> **Жодного звернення до класу `A` або `B` під час виконання не відбувається**, і, відповідно, їхні статичні блоки не виконуються.
>
> **Якби `B.VALUE` не була compile-time constant** (наприклад, ініціалізувалася б у статичному блоці), то класи `A` і `B` були б ініціалізовані, і "B Initialized" було б виведено.

#### **📌 Що перевіряють:**

*Експертне розуміння оптимізацій компілятора для `static final` полів та їхнього впливу на життєвий цикл класів.*

* * *

### **12 ❓ Питання:**

Чи можна ініціалізувати `static final` поле в конструкторі? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, не можна.** Це призведе до **помилки компіляції**.
>
> **Пояснення:**
>
> * **`static final` поле** належить **класу** і повинно бути ініціалізоване **один раз** при завантаженні цього класу. Його життєвий цикл пов'язаний з класом.
> * **Конструктор** викликається **кожного разу** при створенні **нового об'єкта**. Його життєвий цикл пов'язаний з екземпляром.
>
> Якби було дозволено ініціалізувати статичне поле в конструкторі, виникало б кілька проблем:
>
> 1. Його значення перезаписувалося б при кожному створенні об'єкта, що суперечить ідеї `final`.
> 2. Його значення було б `null` або `0` до створення першого об'єкта, що порушує контракт константи.
>
> Правильні місця для ініціалізації `static final` поля — **при оголошенні** або у **`static` блоці**.
> Правильні місця для ініціалізації не-статичного `final` поля — **при оголошенні**, у **блоці ініціалізації екземпляра (`{}`)** або в **конструкторі**.

#### **📌 Що перевіряють:**

*Чітке розуміння різниці між ініціалізацією на рівні класу та на рівні об'єкта.*

* * *

### **13 ❓ Питання:**

Розглянемо константу `public static final int[] NUMBERS = {1, 2, 3};`. Чи є ця константа повністю незмінною? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, вона не є повністю незмінною.** Це класична пастка.
>
> * `final` гарантує, що змінна `NUMBERS` **завжди буде посилатися на один і той самий об'єкт масиву**. Ви не можете зробити `NUMBERS = new int[]{4, 5, 6};`.
>
> * **Однак, масиви в Java є змінюваними (mutable) об'єктами.**
>
> Це означає, що **вміст масиву можна змінити**.
>
> ```java
> public class MyConstants {
>     public static final int[] NUMBERS = {1, 2, 3};
> }
>
> //... десь в коді:
> System.out.println(MyConstants.NUMBERS[0]); // Виведе 1
>
> MyConstants.NUMBERS[0] = 99; // Змінюємо вміст масиву!
>
> System.out.println(MyConstants.NUMBERS[0]); // Виведе 99
> ```
>
> **Як створити справжню незмінну константу-колекцію:**
>
> 1. Зробити масив `private`, а назовні надавати лише копію або незмінну обгортку.
>
>     ```java
>     private static final int[] NUMBERS = {1, 2, 3};
>     public static final List<Integer> UNMODIFIABLE_NUMBERS =
>         Collections.unmodifiableList(Arrays.asList(1, 2, 3));
>     ```
>
> 2. Використовувати `List.of()` (з Java 9).
>     `public static final List<Integer> NUMBERS = List.of(1, 2, 3);`

#### **📌 Що перевіряють:**

*Розуміння того, як `final` працює зі змінюваними посилальними типами. Це поглиблена версія питання про `final List`.*

* * *

### **14 ❓ Питання:**

Як `static final` поля впливають на процес серіалізації? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ніяк. `static` поля не серіалізуються.**
>
> **Пояснення:**
>
> * **Серіалізація** — це процес збереження **стану об'єкта**.
> * **`static` поля** є частиною **стану класу**, а не об'єкта. Вони існують незалежно від будь-яких екземплярів.
>
> Коли об'єкт серіалізується, механізм записує значення лише його **не-статичних** та **не-`transient`** полів. Статичні поля повністю ігноруються.
>
> **Що відбувається при десеріалізації:**
>
> Коли об'єкт відновлюється з потоку байтів, його поля екземпляра заповнюються. Якщо в його коді є звернення до `static` поля, він отримає **поточне значення цього поля в тій JVM, де він був відновлений**, а не те значення, яке було в JVM, де його серіалізували.
>
> Це логічно, оскільки `static` поля представляють глобальний для класу стан.

#### **📌 Що перевіряють:**

*Знання механізму серіалізації та того, які дані входять у серіалізоване представлення об'єкта.*

* * *

### **15 ❓ Питання:**

Припустимо, у нас є два класи в різних пакетах. Один з них містить `public static final` поле. Як зміна цього поля вплине на другий клас після перекомпіляції лише першого? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Це залежить від того, чи є `static final` поле **константою часу компіляції**.
>
> **Сценарій 1: Це константа часу компіляції.**
>
> ```java
> // Library.java
> public class Library { public static final int VERSION = 1; }
>
> // MyApp.java
> public class MyApp { public static void main(String[] args) { System.out.println(Library.VERSION); } }
> ```
>
> **Що відбувається:**
>
> 1. `MyApp` компілюється. Компілятор бачить, що `Library.VERSION` — це compile-time constant, і **вбудовує (inlines) її значення `1`** безпосередньо в байткод `MyApp.class`.
> 2. Тепер ми змінюємо `Library.java`: `public static final int VERSION = 2;` і **перекомпілюємо лише `Library.java`**.
> 3. Запускаємо `MyApp` (який не перекомпілювали) з новою бібліотекою.
> 4. **Результат:** програма виведе **`1`**! Вона продовжує використовувати старе, "зашите" значення.
>
> **Сценарій 2: Це НЕ константа часу компіляції.**
>
> ```java
> // Library.java
> public class Library { public static final int VERSION = new Random().nextInt(); }
> ```
>
> **Що відбувається:**
>
> 1. Значення не може бути заінлайнено. В байткоді `MyApp` залишається **символічне посилання** на поле `Library.VERSION`.
> 2. Ми змінюємо `Library.java` і перекомпілюємо його.
> 3. При запуску `MyApp`, завантажувач класів завантажить новий `Library.class`, і `MyApp` звернеться до поля, отримавши вже нову логіку.
>
> **Висновок:** Для констант часу компіляції зміна значення в бібліотеці вимагає **перекомпіляції всього коду, що її використовує**. Це важливий нюанс при управлінні залежностями.

#### **📌 Що перевіряють:**

*Експертне розуміння процесу компіляції, зв'язування та завантаження класів. Це питання на розуміння тонких аспектів залежностей у Java.*
