---
layout: default
title: "Ієрархія винятків"
parent: "Обробка винятків (Exceptions)"
grand_parent: "Java Core"
nav_order: 2
---

# Ієрархія винятків

* короткий опис: Усі винятки в Java є нащадками класу `Throwable`, який поділяється на дві основні гілки: `Error` (серйозні, необроблювані збої JVM) та `Exception` (програмні помилки, які можна обробляти).

* поняття: `Throwable`, `Error`, `Exception`, `RuntimeException` (підклас `Exception`).

* приклади: `OutOfMemoryError`, `StackOverflowError` (Errors); `IOException`, `SQLException` (Checked Exceptions); `NullPointerException`, `ArithmeticException` (Unchecked Exceptions/RuntimeExceptions).

* ключові моменти: `Error` – фатальні, `Exception` – оброблювані. Розуміння ієрархії допомагає правильно писати `catch`-блоки (від специфічного до загального).

* що важливо знати на співбесіді: Розрізнення `Error`, Checked/Unchecked `Exception`.

### **✅ Офіційне визначення:**

Усі винятки в Java є нащадками класу **`Throwable`**.  
Цей клас має дві основні гілки:

* **Error** — серйозні помилки JVM, які не потрібно (і не можна) обробляти
* **Exception** — типові програмні помилки, які можна і потрібно обробляти

### **🧠 Простими словами:**

Java має ієрархію помилок, як родинне дерево. Всі "проблеми" — це нащадки **`Throwable`**.

Деякі з них — критичні (Error), інші — звичайні програмні баги (Exception)

---

## **Ієрархія винятків (спрощена діаграма):**

```java
                    Object
                      │
                  Throwable
                      │
                ┌────┴────┐
              Error        Exception
               │              │
               │              ├─ IOException  (checked)
               │              │    │
               │              │    ├─ FileNotFoundException
               │              │    ├─ EOFException
               │              │    ├─ SocketException
               │              │    └─ InterruptedIOException
               │              │
               │              │
               │              │
               │              ├─ SQLException       (checked)
               │              ├─ ClassNotFoundException (checked)
               │              ├─ ParseException     (checked)
               │              │
               │              │
               │              │
               │              └─ RuntimeException   (unchecked)
               │                   ├─ NullPointerException
               │                   ├─ IllegalArgumentException
               │                   ├─ ArithmeticException
               │                   ├─ NumberFormatException
               │                   │ 
               │                   ├─ IndexOutOfBoundsException
               │                   │    │
               │                   │    ├─ ArrayIndexOutOfBoundsException
               │                   │    └─ StringIndexOutOfBoundsException
               │                   │
               │                   └─ UnsupportedOperationException
               │
               ├─ OutOfMemoryError
               ├─ StackOverflowError
               ├─ InternalError
               └─ AssertionError

```

---

## **Пояснення на пальцях (💡)**

* **Error** — це проблеми з JVM: пам’ять скінчилась, рекурсія зашла у нескінченність. Ловити такі помилки не має сенсу, бо це не твоя вина.
* **Exception** — помилки у твоєму коді: неправильний ввід, робота з файлами, неправильні аргументи. Ці помилки потрібно ловити, щоб програма не "падала".

---

## **Корисні приклади (🧪)**

```java
// Checked Exception -- обов'язково обробляти або кидати далі
try {
    FileInputStream file = new FileInputStream("notfound.txt"); // IOException
} catch (IOException e) {
    e.printStackTrace();
}

// Unchecked Exception -- компілятор не змушує обробляти
int a = 10 / 0; // ArithmeticException

String s = null;
s.length(); // NullPointerException
```

---

## **Порівняння (⚖️)**

| Тип винятку | Обробка | Приклад | Коли виникає |
| :---: | :---: | :---: | :---: |
| **Error** | ❌ Не обробляється | **OutOfMemoryError, StackOverflowError** | Проблеми JVM |
| **Checked Exception** | ✅ Обов’язкова | **IOException, SQLException** | Помилки, які можна передбачити |
| **Unchecked Exception** | 🟢 Не обов’язкова | **NullPointerException, ArithmeticException** | Логічні помилки в коді |

---

## **🧠 Мнемоніка для запам’ятовування:**

```java
Throwable -> корінь всього, що ламає код
│
├─ Error     -> ❌ НЕ ловимо (фатальні системні проблеми JVM)
│   │
│   ├─ OutOfMemoryError
│   ├─ StackOverflowError
│   └─ InternalError, AssertionError
│  
└─ Exception -> ✅ ЛОВИМО (програмні помилки)
    ├─ Checked     -> 🟨 Обробляти (try/catch або throws)
    └─ Unchecked   -> 🟩 Можна не обробляти (RuntimeException та підкласи)
```

---

## **🟩 Підсумок:**

* Всі винятки в Java — це підкласи **`Throwable`**.
* **Error** — системні помилки, що не обробляються.
* **Exception** — помилки коду, які треба ловити й обробляти.
* Розуміння ієрархії допомагає писати правильні блоки **`try-catch`** і робити код стабільним.

---

### **🔗 Додаткові джерела:**

* [**Java Exceptions Tutorial (Oracle Docs)**](https://docs.oracle.com/javase/tutorial/essential/exceptions/)

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Який клас є базовим для всіх помилок та винятків у Java? Опишіть його дві основні гілки.

> #### **💬 Відповідь:**
>
> Базовим класом для всього, що може бути "кинуто" в Java, є **`java.lang.Throwable`**.
>
> Він має дві основні гілки (два прямі нащадки), які представляють дві фундаментально різні категорії проблем:
>
> 1. **`java.lang.Error`:**
>     * **Що це:** Представляє **серйозні, фатальні проблеми** в роботі **середовища виконання Java (JVM)**, від яких програма зазвичай не може оговтатися.
>     * **Приклади:** `OutOfMemoryError` (закінчилася пам'ять), `StackOverflowError` (переповнення стека).
>     * **Обробка:** Ці помилки **не слід ловити**, оскільки додаток вже знаходиться в нестабільному стані. Їх виникнення сигналізує про проблеми з конфігурацією, архітектурою або апаратним забезпеченням.
>
> 2. **`java.lang.Exception`:**
>     * **Що це:** Представляє **програмні помилки**, які виникають у коді додатку і від яких, як правило, можна оговтатися.
>     * **Приклади:** `IOException` (помилка вводу/виводу), `SQLException` (помилка при роботі з БД), `NullPointerException`.
>     * Ця гілка, у свою чергу, поділяється на `checked` та `unchecked` винятки.

#### **📝 Аналогія:**

* **`Error`:** Це як землетрус, що зруйнував фундамент вашого будинку. Намагатися зачинити вікно в цей момент безглуздо.
* **`Exception`:** Це як зламаний замок на дверях. Неприємно, але ви можете це виправити або викликати майстра.

#### **📌 Що перевіряють:**

*Розуміння ієрархаті `Throwable` та принципової різниці між помилками JVM та помилками програми.*

* * *

### **2 ❓ Питання:**

Поясніть ключову різницю між `checked` та `unchecked` винятками. Наведіть по два приклади кожного.

> #### **💬 Відповідь:**
>
> Різниця полягає в тому, **чи змушує компілятор обробляти** цей тип винятку.
>
> **Checked Exceptions (Перевірювані винятки):**
>
> * **Визначення:** Це всі нащадки класу `Exception`, які **не є** нащадками `RuntimeException`.
> * **Правило компілятора:** Компілятор **вимагає**, щоб ви обробили такий виняток. Ви повинні або:
>     1. Обернути виклик у блок **`try-catch`**.
>     2. Або **оголосити** цей виняток у сигнатурі вашого методу за допомогою **`throws`**.
> * **Призначення:** Сигналізують про помилки, які є очікуваними при роботі з зовнішніми ресурсами, і від яких клієнтський код повинен вміти відновлюватися.
> * **Приклади:** `IOException`, `SQLException`.
>
> **Unchecked Exceptions (Неперевірювані винятки):**
>
> * **Визначення:** Це всі нащадки класу **`RuntimeException`** (а також `Error`).
> * **Правило компілятора:** Компілятор **не вимагає** їхньої обробки.
> * **Призначення:** Зазвичай сигналізують про **програмні помилки (баги)**, такі як неправильне використання API або логічні помилки. Виправляти потрібно сам код, а не ловити ці винятки.
> * **Приклади:** `NullPointerException`, `ArrayIndexOutOfBoundsException`.

#### **📌 Що перевіряють:**

*Це одне з найважливіших питань по темі. Кандидат повинен чітко розмежувати ці дві категорії, їхнє призначення та правила обробки.*

* * *

### **3 ❓ Питання:**

Чому `RuntimeException` є підкласом `Exception`, хоча їхня поведінка щодо перевірки компілятором різна?

> #### **💬 Відповідь:**
>
> `RuntimeException` є підкласом `Exception`, тому що він також представляє **програмну помилку, яка виникає під час виконання**, а не проблему JVM, як `Error`.
>
> Специфічна поведінка `unchecked` винятків (відсутність перевірки компілятором) — це **особливе правило, реалізоване в компіляторі Java**. Компілятор просто має інструкцію: "якщо виняток є `RuntimeException` або його нащадком, не вимагати його обробки".
>
> Така ієрархія має сенс:
>
> * **Логічно:** Всі `RuntimeException` є винятковими ситуаціями. `NullPointerException` — це, безперечно, `Exception`.
> * **Поліморфно:** Це дозволяє при бажанні перехоплювати всі програмні помилки разом за допомогою одного блоку `catch (Exception e)`. Якби `RuntimeException` не був нащадком `Exception`, цей блок не перехопив би `NullPointerException`.
>
> Таким чином, успадкування відображає логічний зв'язок "is-a", а відсутність перевірки — це спеціальний виняток із правил компілятора, введений для зручності.

#### **📌 Що перевіряють:**

*Розуміння того, що поведінка `unchecked` — це спеціальне правило компілятора, а не властивість, успадкована з ієрархії.*

* * *

### **4 ❓ Питання:**

Чому ловити `Throwable` (`catch (Throwable t)`) вважається поганою практикою?

> #### **💬 Відповідь:**
>
> Перехоплення `Throwable` є поганою практикою, оскільки цей блок **ловить не тільки `Exception`, але й `Error`**.
>
> **Проблеми:**
>
> 1. **Приховування фатальних помилок:** Помилки типу `Error` (наприклад, `OutOfMemoryError`, `StackOverflowError`) сигналізують про те, що JVM знаходиться в нестабільному, "вмираючому" стані. Намагатися "обробити" таку помилку і продовжити роботу програми — це як намагатися їхати на автомобілі, у якого відвалилося колесо. Це, швидше за все, призведе до ще гірших проблем і пошкодження даних.
>
> 2. **Ви не можете коректно відновитися:** Ваша програма не може нічого зробити з `OutOfMemoryError`, крім як завершити роботу. Спроба створити нові об'єкти в `catch` блоці лише погіршить ситуацію.
>
> 3. **Порушення логіки:** `Error` не є частиною звичайної логіки програми. Їх перехоплення змішує обробку програмних помилок з обробкою збоїв віртуальної машини.
>
> **Коли це може бути виправдано:**
> Лише на **найвищому рівні** додатку (наприклад, у головному `main` потоці або у фреймворку), щоб гарантовано залогувати **будь-яку**, навіть найфатальнішу помилку перед тим, як програма завершить роботу. Але після цього додаток повинен бути негайно зупинений.

#### **📌 Що перевіряють:**

*Розуміння того, чому не слід втручатися в процес завершення програми при критичних збоях JVM.*

* * *

### **5 ❓ Питання:**

У якому порядку слід розташовувати `catch` блоки при обробці кількох типів винятків? Що буде, якщо порушити цей порядок?

> #### **💬 Відповідь:**
>
> `catch` блоки повинні бути розташовані в порядку **від більш специфічного (дочірнього) до більш загального (батьківського) типу** винятку.
>
> **Причина:**
> `catch` блоки перевіряються послідовно. Перший `catch` блок, тип якого сумісний з типом кинутого винятку, буде виконаний.
>
> **Приклад правильного порядку:**
>
> ```java
> try {
>     // ...
> } catch (FileNotFoundException e) { // Нащадок IOException
>     // Обробка конкретної помилки
> } catch (IOException e) { // Батько
>     // Обробка всіх інших помилок вводу/виводу
> }
> ```
>
> **Що буде, якщо порушити порядок:**
>
> Це призведе до **помилки компіляції**. Компілятор побачить, що більш специфічний `catch` блок ніколи не буде досягнутий, оскільки його виняток завжди буде перехоплений більш загальним батьківським блоком, що стоїть раніше.
>
> **Приклад помилки:**
>
> ```java
> try {
>     // ...
> } catch (IOException e) {
>     // ...
> } catch (FileNotFoundException e) {
>     // ПОМИЛКА КОМПІЛЯЦІЇ: Exception 'FileNotFoundException' has already been caught
> }
> ```

#### **📌 Що перевіряють:**

*Знання правил обробки винятків та того, як компілятор забезпечує досяжність коду.*

* * *

### **6 ❓ Питання:**

Коли варто створювати власні `checked` винятки, а коли — `unchecked`? ⭐️

> #### **💬 Відповідь:**
>
> Це важливе дизайнерське рішення, яке залежить від того, чи може **клієнтський код розумно відреагувати** на помилку.
>
> **Створюйте `checked` виняток, коли:**
>
> 1. Помилка є **очікуваною** і не залежить від програміста. Зазвичай, це стосується взаємодії із зовнішніми системами (файли, мережа, БД).
> 2. **Клієнтський код може і повинен щось зробити**, щоб оговтатися від цієї помилки.
>     * **Приклад:** `InsufficientFundsException`. Клієнтський код може обробити цей виняток і запропонувати користувачеві поповнити рахунок або обрати інший спосіб оплати.
>
> **Створюйте `unchecked` (нащадок `RuntimeException`), коли:**
>
> 1. Помилка сигналізує про **баг у програмі** або **неправильне використання API**.
> 2. **Клієнтський код не може нічого зробити** для виправлення ситуації, окрім як залогувати помилку і дати програмі "впасти". Виправляти потрібно сам код.
>     * **Приклад:** `IllegalArgumentException`, якщо в метод передали невалідний аргумент (наприклад, `null`). Ловити цей виняток зазвичай безглуздо — потрібно виправити код, що його викликає. `UserNotFoundException` для внутрішнього сервісу також може бути `unchecked`, бо якщо сервіс вищого рівня очікує, що юзер існує, то його відсутність — це помилка в логіці.

#### **📌 Що перевіряють:**

*Архітектурне мислення та вміння проектувати API, який чітко комунікує типи помилок, що можуть виникнути.*

* * *

### **7 ❓ Питання:**

Що таке патерн "загортання винятків" (Exception Wrapping)? Навіщо він потрібен? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Загортання винятків** — це патерн, при якому низькорівневий виняток перехоплюється, і натомість кидається новий, більш високорівневий, який містить оригінальний виняток як свою "причину" (cause).
>
> **Навіщо він потрібен:**
>
> 1. **Абстрагування від деталей реалізації:** Він дозволяє приховати низькорівневі деталі. Наприклад, сервісний шар не повинен знати, що шар даних використовує JDBC і кидає `SQLException`. Замість цього репозиторій ловить `SQLException` і кидає більш загальний `DataAccessException`. Це підтримує **слабку зв'язність** між шарами.
>
> 2. **Додавання контексту:** Ви можете додати до нового винятку додаткову бізнес-інформацію (наприклад, ID замовлення, яке не вдалося обробити).
>
> 3. **Перетворення `checked` на `unchecked`:** Це найпоширеніший випадок використання. Дозволяє уникнути "прокидання" `checked` винятків (як `SQLException`) через усі шари додатка, що робить код чистішим.
>
> **Приклад:**
>
> ```java
> public User findById(long id) {
>     try {
>         // ... код, що кидає SQLException ...
>     } catch (SQLException e) {
>         // Загортаємо низькорівневий виняток у свій власний, unchecked
>         throw new DataAccessException("Помилка при пошуку юзера з id=" + id, e);
>     }
> }
> ```
>
> Передача оригінального винятку `e` у конструктор нового є дуже важливою, бо це зберігає повний стек-трейс і не втрачає інформацію про першопричину помилки.

#### **📌 Що перевіряють:**

*Знання архітектурних патернів для роботи з помилками у багатошарових додатках.*

* * *

### **8 ❓ Питання:**

Що виведе цей код? Який виняток буде кинуто з методу?

```java
public static void test() {
    try {
        throw new RuntimeException("A");
    } finally {
        throw new IllegalStateException("B");
    }
}
```

⭐️⭐️

> #### **💬 Відповідь:**
>
> З методу буде кинуто **`IllegalStateException("B")`**.
>
> **Пояснення:**
>
> Якщо виняток кидається всередині `finally` блоку, він **"перекриває" або "пригнічує"** будь-який виняток, що міг виникнути раніше в `try` або `catch` блоці.
>
> **Послідовність подій:**
>
> 1. `try` блок кидає `RuntimeException("A")`.
> 2. Потік виконання готується передати цей виняток далі.
> 3. **Перед тим, як вийти з методу**, JVM виконує блок `finally`.
> 4. Всередині `finally` кидається **новий виняток** — `IllegalStateException("B")`.
> 5. Цей новий виняток перериває будь-яку попередню обробку. **Оригінальний `RuntimeException` буде втрачено**, і він не буде ні оброблений, ні прокинутий далі.
>
> Таким чином, `finally` є останнім словом. Це є причиною, чому кидати винятки з `finally` блоку є **дуже поганою практикою**. Ви ризикуєте втратити інформацію про першопричину проблеми.

#### **📌 Що перевіряють:**

*Розуміння того, як `finally` взаємодіє з потоком обробки винятків. Це класичне питання-пастка.*

* * *

### **9 ❓ Питання:**

Що таке придушені винятки (Suppressed Exceptions), і як вони пов'язані з `try-with-resources`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Придушені винятки** — це механізм, введений у Java 7 разом з `try-with-resources`, який дозволяє **не втрачати інформацію** про винятки, що виникають під час закриття ресурсів.
>
> **Проблема, яку він вирішує:**
>
> * Уявімо, що в `try` блоці виник виняток `A`.
> * При автоматичному закритті ресурсу в `try-with-resources` метод `close()` також може кинути виняток `B`.
> * У класичній конструкції `finally`, виняток `B` "перекрив" би виняток `A`, і ми б втратили інформацію про першопричину.
>
> **Як працює механізм придушення:**
>
> * `try-with-resources` зберігає **перший виняток (основний)**, що виник у `try` блоці.
> * Якщо при закритті ресурсу виникає другий виняток, він **не перекриває** основний, а **додається до нього** як "придушений".
>
> **Приклад:**
>
> ```java
> try (MyResource r = new MyResource()) { // close() може кинути виняток
>     throw new RuntimeException("Основний виняток");
> } catch (Exception e) {
>     System.out.println(e.getMessage()); // "Основний виняток"
>     for (Throwable suppressed : e.getSuppressed()) {
>         // Тут буде виняток з close()
>         System.out.println("Придушений: " + suppressed.getMessage());
>     }
> }
> ```
>
> Цей механізм робить `try-with-resources` набагато надійнішим за ручну реалізацію в `finally`.

#### **📌 Що перевіряють:**

*Глибокі знання про сучасні можливості обробки винятків та механізм придушених винятків.*

* * *

### **10 ❓ Питання:**

Яка вартість обробки винятків з точки зору продуктивності?

> #### **💬 Відповідь:**
>
> Існує поширена думка, що `try-catch` є дуже повільним. Це і правда, і міф одночасно. Вартість залежить від того, чи **виникає виняток**.
>
> **1. Вартість "щасливого шляху" (happy path):**
>
> * Коли ви входите в `try` блок, і **жодного винятку не виникає**, накладні витрати є **дуже низькими або практично нульовими**. Сучасні JIT-компілятори дуже добре оптимізують цей сценарій. Тому не варто боятися використовувати `try-catch` для коду, де винятки є рідкісними.
>
> **2. Вартість "шляху помилки" (exceptional path):**
>
> * Коли виняток **фактично кидається (`throw`) і перехоплюється (`catch`)**, це **дуже "дорога" операція**.
> * **Чому:** JVM повинна виконати кілька складних дій:
>     1. **Створити об'єкт винятку**, що вимагає виділення пам'яті в купі.
>     2. **Заповнити стек-трейс (stack trace)**. Це найдорожча частина. JVM повинна "пройтися" по всьому стеку викликів, щоб зібрати інформацію про те, який метод викликав який.
>     3. **Розкрутити стек викликів** у пошуку відповідного `catch` блоку.
>
> **Висновок:**
> **Не використовуйте винятки для звичайної логіки керування потоком (control flow)**. `try-catch` призначений для **виняткових** ситуацій, а не для `if-else`. Для рідкісних помилкових сценаріїв їхня вартість є виправданою, але для частої логіки це призведе до серйозної деградації продуктивності.

#### **📌 Що перевіряють:**

*Розуміння того, як обробка винятків працює "під капотом" та її вплив на продуктивність. Здатність розрізняти "щасливий" та "винятковий" шляхи.*

* * *

### **11 ❓ Питання:**

Чи можна мати блок `try` з `finally` без `catch`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, можна.** Конструкція `try-finally` є абсолютно валідною в Java.
>
> **Навіщо вона потрібна:**
>
> Вона використовується, коли вам потрібно **гарантовано виконати якусь дію по очищенню**, але ви **не хочете обробляти виняток** на цьому рівні, а хочете **прокинути його далі** вгору по стеку викликів.
>
> **Приклад:**
>
> ```java
> public void processResource() throws SomeException {
>     Resource resource = acquireResource();
>     try {
>         // Робота з ресурсом, яка може кинути SomeException
>         resource.doWork();
>     } finally {
>         // Цей код виконається завжди, щоб звільнити ресурс,
>         // але SomeException не буде перехоплено і полетить далі.
>         resource.release();
>     }
> }
> ```
>
> Ця ідіома була поширена до Java 7. Сьогодні для таких задач **краще використовувати `try-with-resources`**, який робить те ж саме, але більш коротко та безпечно. Однак, `try-finally` все ще може бути корисним для очищення ресурсів, які не реалізують `AutoCloseable`.

#### **📌 Що перевіряють:**

*Знання всіх можливих комбінацій блоків `try-catch-finally`.*

* * *

### **12 ❓ Питання:**

Що станеться, якщо і `try`, і `catch`, і `finally` блоки кинуть винятки? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Це складний сценарій, який показує, як винятки можуть "перекривати" один одного.
>
> **Порядок:**
>
> 1. У `try` блоці кидається виняток (назвемо його `ExceptionFromTry`).
> 2. Виконання переходить до відповідного `catch` блоку.
> 3. Усередині `catch` кидається новий виняток (`ExceptionFromCatch`).
> 4. Попередній `ExceptionFromTry` втрачається. Тепер програма готується прокинути `ExceptionFromCatch`.
> 5. **Перед тим**, як вийти з методу, **виконується блок `finally`**.
> 6. У `finally` кидається ще один, третій виняток (`ExceptionFromFinally`).
> 7. Цей останній виняток **перекриває** `ExceptionFromCatch`.
>
> **Результат:** З методу буде кинуто **лише останній виняток — той, що виник у `finally` блоці**. Вся інформація про попередні два винятки буде **втрачено**.
>
> Це ще раз підкреслює, що **кидати винятки з `finally` — вкрай небезпечна практика**.

#### **📌 Що перевіряють:**

*Експертне розуміння правил обробки винятків у найскладніших граничних випадках.*

* * *

### **13 ❓ Питання:**

Яка різниця між `NoClassDefFoundError` та `ClassNotFoundException`? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Це два різних типи помилок, пов'язаних із завантаженням класів, які часто плутають.
>
> **`ClassNotFoundException`:**
>
> * **Тип:** `checked Exception`.
> * **Коли виникає:** Коли ви намагаєтеся **динамічно завантажити клас під час виконання**, використовуючи `Class.forName()`, `ClassLoader.loadClass()` або `Class.forTemplate()`, але клас з такою назвою **не може бути знайдений** у `classpath`.
> * **Причина:** Зазвичай, це проблема з конфігурацією — відсутній потрібний `.jar` файл або неправильно налаштований `classpath`. Це проблема, яку програма може спробувати обробити.
>
> **`NoClassDefFoundError`:**
>
> * **Тип:** `Error`.
> * **Коли виникає:** Коли клас **був успішно знайдений** під час компіляції, але під час виконання JVM **не може знайти його визначення** у пам'яті. Або, що набагато частіше, клас **був знайдений**, але сталася **помилка під час його статичної ініціалізації** (наприклад, `static` блок кинув виняток).
> * **Причина:** Клас був у `classpath` під час компіляції, але зник з нього в рантаймі. Або, найчастіше, **`static` блок цього класу (або одного з його батьків) впав з помилкою**. JVM позначає цей клас як "зламаний", і будь-яка подальша спроба до нього звернутися призводить до `NoClassDefFoundError`.
>
> **Коротко:**
>
> * `ClassNotFoundException`: Я намагався завантажити клас за назвою, але не знайшов файл.
> * `NoClassDefFoundError`: Я знайшов файл, але не можу використати його визначення, бо сталася помилка раніше.

#### **📌 Що перевіряють:**

*Глибоке знання механізмів завантаження класів та помилок, пов'язаних з цим процесом.*

* * *

### **14 ❓ Питання:**

Поясніть, що таке **cause** (причина) винятку. ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Причина (`cause`)** винятку — це механізм, який дозволяє "ланцюжково" пов'язувати винятки, зберігаючи інформацію про початкову проблему. Це є основою патерну **"загортання винятків" (exception wrapping)**.
>
> * Коли ви ловите низькорівневий виняток (наприклад, `SQLException`), ви можете створити і кинути свій власний, більш високорівневий виняток (наприклад, `DataAccessException`).
> * Щоб не втратити інформацію про початкову помилку, ви передаєте оригінальний `SQLException` як **причину** в конструктор нового винятку.
>
> ```java
> catch (SQLException e) {
>     throw new DataAccessException("Помилка доступу до даних", e); // 'e' передається як причина
> }
> ```
>
> **Навіщо це потрібно:**
>
> * **Зберігання повного контексту:** При аналізі логів або стек-трейсу ви бачите не тільки високорівневу помилку, але й повний ланцюжок причин, який до неї призвів, аж до початкового `SQLException`. Це надзвичайно важливо для налагодження.
> * **Абстракція без втрати інформації:** Ви можете абстрагувати деталі реалізації, але при цьому зберігаєте повний діагностичний слід.
>
> Методи для роботи з причиною (`getCause()` та `initCause()`) знаходяться в класі `Throwable`.

#### **📌 Що перевіряють:**

*Знання найкращих практик обробки винятків та того, як коректно створювати ланцюжки винятків.*

* * *

### **15 ❓ Питання:**

Як можна ігнорувати `checked` виняток, і чому це дуже погано? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Існує кілька способів "обійти" перевірку компілятора, але всі вони є **антипатернами** та хаками.
>
> **1. "Проковтування" в порожньому `catch` блоці:**
>
> Це найпоширеніший і найгірший спосіб.
>
> ```java
> try {
>     Files.readString(path);
> } catch (IOException e) {
>     // Нічого не робити. Проблема ігнорується.
> }
> ```
>
> **2. "Загортання" у `RuntimeException` без причини:**
> `throw new RuntimeException();`
> Ви уникаєте оголошення `throws`, але втрачаєте всю інформацію про початкову помилку.
>
> **3. Використання "Lombok's `@SneakyThrows`":**
> Анотація `@SneakyThrows` від Lombok "обманює" компілятор. Вона генерує байткод, який кидає `checked` виняток так, ніби він є `unchecked`, позбавляючи від необхідності його обробляти.
>
> **Чому це все погано:**
>
> **`Checked` винятки існують не просто так.** Вони сигналізують про **очікувані проблеми**, з якими ваш код **повинен вміти працювати**. Наприклад, файл може бути відсутнім, або мережеве з'єднання може розірватися.
>
> Ігноруючи їх, ви:
>
> * **Створюєте "тихі" помилки:** Ваша програма буде "падати" непередбачувано або поводитися некоректно.
> * **Втрачаєте інформацію:** Немає логів, немає стек-трейсів.
> * **Робите код крихким і ненадійним.**
>
> `Checked` винятки — це частина контракту методу. Їх потрібно або обробляти осмислено, або прокидати далі (можливо, загорнувши у свій власний, більш специфічний виняток). Ігнорування — це завжди шлях до проблем у майбутньому.

#### **📌 Що перевіряють:**

*Професійну зрілість. Кандидат повинен розуміти філософію, що стоїть за `checked` винятками, і чому намагання "обійти" компілятор є ознакою поганого програмування.*
