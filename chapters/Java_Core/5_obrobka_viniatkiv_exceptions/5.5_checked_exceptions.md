---
layout: default
title: "Checked Exceptions"
parent: "Обробка винятків (Exceptions)"
grand_parent: "Java Core"
nav_order: 5
---

# Checked Exceptions

* короткий опис: `Checked Exceptions` – це винятки, які компілятор змушує програміста обробляти (за допомогою `try-catch`) або оголошувати в сигнатурі методу (за допомогою `throws`).

* поняття: Checked Exception, `IOException`, `FileNotFoundException`, `SQLException`.

* приклади: Робота з файлами (`FileNotFoundException`, `IOException`), базами даних (`SQLException`).

* ключові моменти: Очікувані ризики, пов'язані з зовнішнім світом. Компіляторний контроль забезпечує надійність.

* що важливо знати на співбесіді: Навіщо Java змушує їх обробляти, як обробляти.

### **✅ Офіційне визначення:**

**`Checked Exceptions`** — це винятки, які перевіряються компілятором, і програма не скомпілюється, якщо ти:

❌ не обгорнеш їх у **`try-catch`**

❌ або не вкажеш їх у сигнатурі методу через **`throws`**

### **🧠 Простими словами:**

Java каже: “Це ризиковано — або оброби, або попередь\!”

Такі винятки виникають під час зовнішніх дій: читання файлів, з'єднання з базою, мережа тощо

---

## **Приклади Checked Exceptions (🧪)**

| Клас | Коли виникає |
| :---: | :---: |
| **IOException** | Файл не знайдено, помилка введення/виводу |
| **FileNotFoundException** | Конкретна форма **`IOException`** |
| **SQLException** | Проблеми з базою даних (запити, з'єднання) |
| **ParseException** | Неможливо розпарсити дату/рядок |
| **ClassNotFoundException** | Клас не знайдено при завантаженні |

---

## **Як обробляти: try-catch або throws (🧪)**

### **✔️ Варіант 1: `try-catch`**

```java
import java.io.*;

public class ReadFileExample {
    public static void main(String[] args) {
        try {
            FileReader reader = new FileReader("test.txt");
            int data = reader.read();
            while (data != -1) {
                System.out.print((char) data);
                data = reader.read();
            }
            reader.close();
        } catch (IOException e) {
            System.out.println("Помилка при читанні файлу: " + e.getMessage());
        }
    }
}
```

### **✔️ Варіант 2: `throws`**

```java
import java.io.*;

public class FileLoader {
    public void loadFile() throws IOException {
        FileReader reader = new FileReader("test.txt");
        reader.close();
    }
}
```

📌 **`throws`** означає: “Я не обробляю — передаю далі тому, хто викликає метод”

---

## **Коли обирати try-catch vs throws? (💡)**

| Ситуація | Що краще? | Чому |
| :---: | :---: | :---: |
| Код запускається в **`main`**/entry | **`try-catch`** | Краще обробити на місці |
| Метод в бібліотеці/сервісі | **`throws`** | Нехай обробку вирішує клієнт |
| Тестування або демонстрація | **`throws`** | Щоб не писати зайвий catch |

---

## **🧠 Мнемоніка для запам’ятовування:**

**`Checked`** \= Чекати ризик -> **`try`** або **`throws`**

Або:

**`Checked`** \= зовнішній світ -> ти маєш на це зреагувати

---

## **🟩 Підсумок:**

* **Checked Exceptions** — це помилки, які можуть виникнути при роботі з файлами, мережею, базою.
* Вони мають бути або оброблені, або прокинуті через **`throws`**.
* Це робиться для надійності програми і передбачення помилок.

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке `checked` (перевірювані) винятки і яка їхня основна мета?

> #### **💬 Відповідь:**
>
> **`Checked` винятки** — це підкласи класу `Exception` (за винятком `RuntimeException`), які підлягають **обов'язковій перевірці на етапі компіляції**.
>
> **Основна мета:**
>
> Змусити розробника **свідомо обробити потенційно очікувані помилкові ситуації**, які можуть виникнути при взаємодії із зовнішніми ресурсами і від яких програма може (і повинна) оговтатися.
>
> **Правило компілятора:**
>
> Якщо метод викликає інший метод, що може кинути `checked` виняток, він зобов'язаний:
>
> 1. Або обробити цей виняток за допомогою блоку **`try-catch`**.
> 2. Або оголосити, що він також може кинути цей виняток, додавши його до своєї сигнатури за допомогою ключового слова **`throws`**.
>
> Це робить API більш надійним, оскільки контракт методу явно вказує на можливі помилки, які клієнтський код повинен врахувати.

#### **📝 Аналогія:**

Це як отримання візи для поїздки за кордон. Ви не можете просто сісти в літак. Система (компілятор) змушує вас або **отримати візу (`try-catch`)**, або мати паспорт, який дозволяє безвізовий режим (аналог **прокидання відповідальності** на вищий рівень, який має цю можливість). Ви не можете проігнорувати цю вимогу.

#### **📌 Що перевіряють:**

*Базове розуміння того, що `checked` винятки — це про обов'язкову обробку помилок, пов'язаних із зовнішніми системами.*

* * *

### **2 ❓ Питання:**

Наведіть приклади найпоширеніших `checked` винятків з JDK.

> #### **💬 Відповідь:**
>
> Більшість `checked` винятків пов'язані з операціями вводу/виводу, мережевою взаємодією та доступом до ресурсів.
>
> **Найпоширеніші приклади:**
>
> * **`java.io.IOException`:**
>   * Це базовий клас для всіх помилок, пов'язаних із вводом/виводом.
>   * Його підкласи, як-от **`FileNotFoundException`** (файл не знайдено) та **`SocketException`** (проблема з мережевим сокетом), є одними з найчастіших.
>
> * **`java.sql.SQLException`:**
>   * Кидається при будь-яких помилках під час роботи з базами даних через JDBC (неправильний SQL-запит, проблеми зі з'єднанням, порушення обмежень).
>
> * **`java.lang.ClassNotFoundException`:**
>   * Виникає, коли програма намагається динамічно завантажити клас за його назвою (через `Class.forName()`), але файл `.class` не може бути знайдений у classpath.
>
> * **`java.text.ParseException`:**
>   * Кидається при спробі розпарсити рядок у певний формат (наприклад, дату), якщо рядок не відповідає цьому формату.
>
> * **`java.lang.InterruptedException`:**
>   * Кидається, коли потік, що перебуває в очікуванні (`sleep`, `wait`, `join`), переривається іншим потоком.

#### **📌 Що перевіряють:**

*Знання стандартної бібліотеки та розуміння, в яких ситуаціях можуть виникати `checked` винятки.*

* * *

### **3 ❓ Питання:**

Поясніть на прикладі два способи обробки `checked` винятку.

> #### **💬 Відповідь:**
>
> Уявімо, що ми хочемо прочитати рядок з файлу. Метод `readLine()` з `BufferedReader` кидає `IOException`.
>
> **Спосіб 1: Обробка за допомогою `try-catch`**
>
> Ми "ловимо" виняток і самі вирішуємо, що робити з помилкою на цьому рівні.
>
> ```java
> public void printFirstLine() {
>     try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
>         String firstLine = reader.readLine();
>         System.out.println(firstLine);
>     } catch (IOException e) {
>         // Обробляємо помилку: логуємо її і/або виводимо повідомлення
>         System.err.println("Не вдалося прочитати файл: " + e.getMessage());
>     }
> }
> ```
>
> Тут ми обробили помилку локально, і метод `printFirstLine` нічого не "кидає" далі.
>
> **Спосіб 2: Прокидання за допомогою `throws`**
>
> Ми не обробляємо виняток самі, а **делегуємо відповідальність** за його обробку коду, що викликає наш метод.
>
> ```java
> // Оголошуємо, що наш метод може кинути IOException
> public String readFirstLine() throws IOException {
>     try (BufferedReader reader = new BufferedReader(new FileReader("file.txt"))) {
>         return reader.readLine();
>     }
> }
> ```
>
> Тепер будь-який код, що викликає `readFirstLine()`, буде змушений або обробити `IOException` у `try-catch`, або також оголосити його у своєму `throws`.

#### **📌 Що перевіряють:**

*Практичні навички роботи з винятками. Кандидат повинен вміти написати код для обох сценаріїв.*

* * *

### **4 ❓ Питання:**

У яких випадках краще використовувати `try-catch`, а в яких — `throws`?

> #### **💬 Відповідь:**
>
> Вибір залежить від того, на якому рівні архітектури знаходиться ваш код і чи є у нього достатньо контексту для коректної обробки помилки.
>
> **Коли краще використовувати `try-catch`:**
>
> * **Коли ви можете розумно відреагувати на помилку.** Якщо ви можете виконати якусь альтернативну дію, повернути значення за замовчуванням або показати користувачеві повідомлення про помилку, то обробка на місці є правильним рішенням.
> * **На високих рівнях архітектури.** Наприклад, у контролері веб-додатку ви повинні перехопити винятки і повернути клієнту відповідний HTTP-статус.
> * **У `main` методі або у `run()` методі потоку.** Це кінцеві точки, і неперехоплений виняток призведе до "падіння" потоку або програми.
>
> **Коли краще використовувати `throws`:**
>
> * **Коли ваш метод не має достатньо контексту для обробки помилки.** Наприклад, низькорівневий метод, що читає з файлу, не знає, що робити, якщо файл не знайдено, — показати діалогове вікно, залогувати помилку чи спробувати інший файл? Це має вирішувати код вищого рівня.
> * **При розробці бібліотек та API.** Надайте клієнтам вашого API можливість самим вирішувати, як обробляти помилки.
>
> **Коротка настанова:** "Ловіть" виняток лише тоді, коли ви знаєте, що з ним робити. В іншому випадку, "прокидайте" його далі.

#### **📌 Що перевіряють:**

*Архітектурне мислення та вміння проектувати стратегію обробки помилок у додатку.*

* * *

### **5 ❓ Питання:**

Чому існує сильна критика концепції `checked` винятків?

> #### **💬 Відповідь:**
>
> Хоча ідея `checked` винятків була благородною — змусити писати більш надійний код, — на практиці вона часто призводить до низки проблем, через які її сильно критикують:
>
> 1. **"Вірусність" (Verbosity and Boilerplate):** `Checked` винятки "заражають" весь стек викликів. Якщо низькорівневий метод додає `throws MyCheckedException`, вам, можливо, доведеться змінити сигнатури десятків методів вище по ієрархії, що робить рефакторинг болісним.
>
> 2. **Забруднення сигнатур:** Сигнатури методів стають громіздкими (`throws IOException, SQLException, ...`) і прив'язують високорівневий код до низькорівневих деталей реалізації (порушення абстракції).
>
> 3. **Провокування поганих практик:** Щоб уникнути багатослів'я, розробники часто вдаються до антипатернів:
>     * **"Ковтання" винятків:** `catch (Exception e) { /* нічого не робити */ }`.
>     * **Кидання `throws Exception`:** Це вбиває всю користь типізованих винятків.
>     * **Загортання у `RuntimeException`:** Це по суті спосіб обійти механізм `checked` винятків.
>
> 4. **Проблеми з функціональним стилем:** Стандартні функціональні інтерфейси не оголошують `checked` винятків, що робить їхнє використання в лямбдах та стрімах громіздким.
>
> Багато сучасних мов (Kotlin, Scala) та фреймворків (Spring) відмовилися від `checked` винятків на користь `unchecked`, вважаючи, що розробник сам повинен вирішувати, які помилки обробляти.

#### **📌 Що перевіряють:**

*Критичне мислення та розуміння архітектурних дебатів навколо дизайну мови.*

* * *

### **6 ❓ Питання:**

Поясніть, що таке "загортання винятків" (exception wrapping) і як воно допомагає уникнути "checked exception hell". ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Загортання винятків** — це патерн, при якому низькорівневий `checked` виняток перехоплюється, і замість нього кидається новий, зазвичай `unchecked` (`RuntimeException`), який містить оригінальний виняток як свою **причину (`cause`)**.
>
> **Це є основною стратегією для боротьби з "checked exception hell".**
>
> **Як це працює:**
>
> 1. На межі архітектурного шару (наприклад, у Repository, що працює з БД), ви ловите специфічний `checked` виняток (`SQLException`).
> 2. Ви створюєте свій власний, більш семантичний `unchecked` виняток (наприклад, `DataAccessException`).
> 3. Ви кидаєте цей новий виняток, передавши оригінальний у конструктор.
>
> **Приклад:**
>
> ```java
> public class DataAccessException extends RuntimeException {
>     public DataAccessException(String message, Throwable cause) {
>         super(message, cause);
>     }
> }
>
> public class UserRepository {
>     public User findById(long id) {
>         try {
>             // ... код, що кидає SQLException ...
>         } catch (SQLException e) {
>             throw new DataAccessException("Помилка доступу до юзера " + id, e);
>         }
>     }
> }
> ```
>
> **Переваги:**
>
> * Сервісний шар, що викликає `findById`, тепер **не зобов'язаний** обробляти `SQLException`.
> * Сигнатури методів залишаються чистими.
> * Інформація про першопричину **не втрачається** і буде доступна у стек-трейсі.

#### **📌 Що перевіряють:**

*Знання архітектурних патернів для проектування надійних систем обробки помилок.*

* * *

### **7 ❓ Питання:**

Які `Throwable`-класи не є `checked`?

> #### **💬 Відповідь:**
>
> `checked` винятки — це, по суті, все, що не є `unchecked`. Тому простіше визначити `unchecked`.
>
> `unchecked` (неперевірюваними) є:
>
> 1. Клас **`java.lang.RuntimeException`** та **всі його нащадки**.
>     * Приклади: `NullPointerException`, `IllegalArgumentException`, `IllegalStateException`, `IndexOutOfBoundsException`.
>
> 2. Клас **`java.lang.Error`** та **всі його нащадки**.
>     * Приклади: `OutOfMemoryError`, `StackOverflowError`, `AssertionError`.
>
> Будь-який інший нащадок `Throwable`, що не належить до цих двох ієрархій, є **`checked`**.
> Наприклад, `IOException` успадковується напряму від `Exception` і тому є `checked`.

#### **📌 Що перевіряють:**

*Точне знання ієрархії винятків. Кандидат повинен чітко знати, що `Error` також є `unchecked`.*

* * *

### **8 ❓ Питання:**

Уявіть, що ви перевизначаєте метод. Які правила діють щодо `throws` клаузи для `checked` винятків у дочірньому класі? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Існує строге правило: **перевизначений метод не може розширювати контракт винятків**.
>
> Це означає, що `throws` клауза дочірнього методу **не може оголошувати `checked` виняток, який є ширшим (є суперкласом) або абсолютно новим**, порівняно з тим, що оголошено в батьківському методі.
>
> **Дочірній метод може:**
>
> * **Не кидати** жодних `checked` винятків.
> * Кидати **той самий** `checked` виняток.
> * Кидати **підклас** `checked` винятку.
>
> **Приклад:**
>
> ```java
> class Parent {
>     public void process() throws java.io.IOException {}
> }
> class Child extends Parent {
>     // OK: звужуємо до підкласу
>     @Override public void process() throws java.io.FileNotFoundException {}
> }
> class AnotherChild extends Parent {
>     // ПОМИЛКА: Exception ширший, ніж IOException
>     // @Override public void process() throws Exception {}
> }
> ```
>
> **Чому так:** Це підтримує **принцип підстановки Лісков (LSP)**. Клієнт, написаний для роботи з `Parent`, готовий обробляти лише `IOException`. Він не повинен "ламатися", якщо йому підставити об'єкт `Child`, що кидає щось нове і несподіване.

#### **📌 Що перевіряють:**

*Знання правил перевизначення, пов'язаних з винятками.*

* * *

### **9 ❓ Питання:**

Як обробляти `checked` винятки всередині лямбда-виразів у Stream API? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Це поширена проблема, оскільки стандартні функціональні інтерфейси (`Function`, `Predicate` тощо) не оголошують `checked` винятків.
>
> **Рішення:**
>
> **1. Обгортання в `try-catch` всередині лямбди (найпоширеніше):**
> Ви ловите `checked` виняток і кидаєте замість нього `unchecked` виняток.
>
> ```java
> list.stream()
>     .map(item -> {
>         try {
>             return item.processWhichThrowsIOException();
>         } catch (IOException e) {
>             throw new RuntimeException(e);
>         }
>     })
>     .collect(Collectors.toList());
>    ```
>
> **2. Винесення логіки в окремий метод:**
> Щоб не засмічувати лямбду, можна створити приватний метод, який містить `try-catch`, і викликати його.
>
> ```java
> private Result processItem(Item item) { /* ... try-catch тут ... */ }
> //...
> list.stream().map(this::processItem);
> ```
>
> **3. Використання власної "кидаючої" обгортки (просунутий варіант):**
> Можна створити утилітарний метод, який приймає лямбду, що кидає `checked` виняток, і повертає звичайний `Function`, що загортає виняток.
>
> ```java
> // Використання
> list.stream()
>     .map(unchecked(item -> item.process()))
>     .collect(Collectors.toList());
> ```
>
> `unchecked()` — це ваш утилітарний метод.

#### **📌 Що перевіряють:**

*Практичні навички роботи зі Stream API та вміння вирішувати поширені проблеми, пов'язані з винятками.*

* * *

### **10 ❓ Питання:**

Чи можна зловити кілька винятків в одному `catch` блоці? Якщо так, то як і з якої версії Java? ⭐️

> #### **💬 Відповідь:**
>
> **Так, можна.** Ця можливість, відома як **multi-catch**, була додана в **Java 7**.
>
> **Синтаксис:**
> Типи винятків перераховуються через вертикальну риску (`|`).
>
> **Приклад:**
>
> **До Java 7:**
>
> ```java
> try {
>     // ...
> } catch (IOException e) {
>     logAndHandle(e);
> } catch (SQLException e) {
>     logAndHandle(e);
> }
> ```
>
> **З Java 7 (multi-catch):**
>
> ```java
> try {
>     // ...
> } catch (IOException | SQLException e) {
>     // Обробляємо обидва типи винятків в одному блоці
>     logAndHandle(e);
> }
> ```
>
> **Правила:**
>
> * Змінна `e` у такому блоці є неявно **`final`**, і їй не можна присвоювати нове значення.
> * Типи винятків не повинні бути в ієрархії один одного (наприклад, `IOException | FileNotFoundException` буде помилкою, бо `catch(IOException)` вже ловить і `FileNotFoundException`).
>
> Ця фіча значно зменшує дублювання коду, якщо логіка обробки для кількох винятків однакова.

#### **📌 Що перевіряють:**

*Знання сучасних (починаючи з Java 7) можливостей обробки винятків.*

* * *

### **11 ❓ Питання:**

Що виведе цей код і чому?
`try { return 1; } finally { return 2; }` ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Цей код виведе **`2`**.
>
> **Пояснення:**
>
> * `finally` блок виконується **завжди** перед тим, як метод фактично поверне значення.
> * Якщо `finally` блок сам містить інструкцію `return`, він **"перекриває"** будь-який попередній `return` з `try` або `catch` блоку.
>
> **Послідовність:**
>
> 1. Код у `try` готується повернути `1`.
> 2. Виконується `finally`.
> 3. `finally` виконує `return 2;` і негайно завершує метод.
>
> Початкове значення `1` втрачається.
>
> **Важливо:** Це є **дуже поганою практикою**, оскільки робить логіку методу непередбачуваною і може "проковтнути" винятки.

#### **📌 Що перевіряють:**

*Розуміння взаємодії `finally` та `return`. Це класичне питання-пастка.*

* * *

### **12 ❓ Питання:**

Назвіть приклад з JDK, де `RuntimeException` використовується для сигналізації про порушення контракту, а не про баг. ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Хоча `RuntimeException` зазвичай сигналізує про баги, є випадки, коли він використовується для повідомлення про **порушення контракту**, який неможливо перевірити на етапі компіляції.
>
> **Класичний приклад — ітератори та `ConcurrentModificationException`**.
>
> * Інтерфейс `Iterator` має контракт: "не змінюйте колекцію, по якій ви ітеруєте, безпосередньо через її методи".
> * Компілятор не може перевірити, чи дотримуєтеся ви цього контракту.
> * Тому ітератор реалізує логіку перевірки **під час виконання**. Якщо він виявляє, що колекція була змінена "збоку", він кидає **`ConcurrentModificationException`**.
>
> Це `RuntimeException`, бо:
>
> 1. Це **програмна помилка**. Викликаючий код не дотримався правил використання ітератора.
> 2. Змушувати обробляти його як `checked` зробило б кожен `for-each` цикл надзвичайно громіздким.
>
> Інший приклад — `IllegalMonitorStateException`, який кидається при спробі викликати `wait()` або `notify()` на об'єкті, монітор якого не захоплено. Це теж порушення контракту API.

#### **📌 Що перевіряють:**

*Глибоке розуміння того, що поділ на `checked`/`unchecked` не є абсолютно чорно-білим, і іноді `RuntimeException` використовується для сигналізації про помилки API.*

* * *

### **13 ❓ Питання:**

Як `try-with-resources` обробляє винятки, що виникають і в `try` блоці, і при закритті ресурсу? Що таке "придушений виняток"? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> `try-with-resources` вирішує проблему **втрати інформації про початкову помилку** за допомогою механізму **придушених винятків (suppressed exceptions)**.
>
> **Сценарій:**
>
> 1. Всередині `try` блоку кидається виняток `A`.
> 2. Після цього `try-with-resources` автоматично намагається закрити ресурс, викликаючи його метод `close()`.
> 3. Під час `close()` кидається інший виняток `B`.
>
> **Що відбувається:**
>
> * **`A`** стає **основним винятком**, який буде передано в `catch` блок або прокинуто далі.
> * **`B` не втрачається**. Він **додається** до `A` як "придушений".
>
> Обробивши основний виняток `A`, ви можете отримати список усіх придушених винятків за допомогою методу **`getSuppressed()`**, який є у класу `Throwable`.
>
> Цей механізм гарантує, що ви не втратите інформацію про помилки, які виникли при очищенні ресурсів, що робить `try-with-resources` набагато надійнішим за ручну реалізацію в `finally`.

#### **📌 Що перевіряють:**

*Глибокі знання про `try-with-resources` та його переваги порівняно зі старою конструкцією.*

* * *

### **14 ❓ Питання:**

Що таке `Error` в ієрархії винятків, і чи є сенс їх коли-небудь ловити? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **`Error`** та його нащадки представляють **серйозні, невідворотні помилки**, які зазвичай виникають у **JVM**, а не в коді додатка. Вони сигналізують, що система знаходиться в нестабільному, "вмираючому" стані.
>
> **Чи варто їх ловити (`catch (Error e)`)?**
>
> **Ні, практично ніколи.** Це вважається дуже поганою практикою.
>
> **Причини:**
>
> * **Ви не можете нічого виправити.** Якщо виникає `OutOfMemoryError`, спроба виділити пам'ять у `catch` блоці для логування, швидше за все, теж призведе до помилки. Якщо виникає `StackOverflowError`, стек вже переповнений, і ви не можете викликати нові методи.
> * **Маскування критичної проблеми.** Якщо вам вдасться "проковтнути" `Error`, додаток може продовжити працювати у пошкодженому стані, що може призвести до тихого псування даних.
>
> **Єдиний виняток:** можна мати `catch (Throwable t)` на **найвищому рівні програми**, щоб зробити останню спробу записати в лог повідомлення "Програма завершується через фатальну помилку" перед викликом `System.exit()`. Але це не є "обробкою", а лише спробою зафіксувати факт збою.

#### **📌 Що перевіряють:**

*Розуміння того, коли спроба обробити помилку є гіршою за саме "падіння" програми.*

* * *

### **15 ❓ Питання:**

Як би ви спроектували стратегію обробки винятків для багатошарового REST API (Controller-Service-Repository)? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Правильна стратегія базується на **розділенні відповідальності** та **абстрагуванні**.
>
> 1. **Repository Layer (Шар доступу до даних):**
>     * Цей шар взаємодіє з БД і ловить специфічні **`checked` винятки**, як-от `SQLException`.
>     * Він **загортає** їх у власні, специфічні для домену **`unchecked` винятки** (наприклад, `DataAccessException extends RuntimeException`).
>     * Він ніколи не "пропускає" `SQLException` на вищий рівень.
>
> 2. **Service Layer (Шар бізнес-логіки):**
>     * Отримує винятки типу `DataAccessException` від репозиторію. Він може їх зловити, якщо є якась логіка відновлення, але зазвичай він просто дає їм "пролетіти" далі.
>     * Цей шар кидає **власні доменні винятки**, що описують бізнес-помилки.
>         * **`Unchecked`** (наприклад, `UserNotFoundException`, якщо за логікою юзер повинен існувати).
>         * **`Checked`** (наприклад, `InsufficientFundsException`), якщо це очікувана бізнес-ситуація, яку має обробити клієнт.
>
> 3. **Controller Layer (Шар API):**
>     * Цей шар **не містить `try-catch` блоків** у своїх методах.
>     * Замість цього, він покладається на **глобальний обробник винятків (Global Exception Handler)**, реалізований за допомогою, наприклад, **`@RestControllerAdvice`** у Spring.
>
> 4. **Global Exception Handler:**
>     * Це централізоване місце, яке **ловить всі винятки**, що "долітають" до нього.
>     * Він аналізує тип винятку (`UserNotFoundException`, `DataAccessException` тощо) і перетворює його на відповідну **HTTP-відповідь** з коректним статусом (`404 Not Found`, `400 Bad Request`, `500 Internal Server Error`) та зрозумілим повідомленням у форматі JSON.
>
> Такий підхід робить код на кожному шарі чистим, слабкозв'язаним і відповідальним лише за свої власні помилки.

#### **📌 Що перевіряють:**

*Архітектурне мислення та знання найкращих практик для проектування надійних і підтримуваних веб-додатків.*
