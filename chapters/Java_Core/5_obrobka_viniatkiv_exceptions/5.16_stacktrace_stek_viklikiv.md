---
layout: default
title: "Stacktrace (стек викликів)"
parent: "Обробка винятків (Exceptions)"
grand_parent: "Java Core"
nav_order: 16
---

# Stacktrace (стек викликів)

* короткий опис: `Stacktrace` – це список викликів методів, який показує шлях виконання програми до моменту виникнення винятку. Формується JVM і є основним інструментом діагностики помилок.

* поняття: Stacktrace, `printStackTrace()`, стек викликів, `Caused by`.

* приклади: Вивід `at MyClass.methodA(MyClass.java:10)` для кожного рівня виклику.

* ключові моменти: Читається зверху вниз (від місця помилки до кореня виклику). Включає інформацію про клас, метод, файл та номер рядка.

* що важливо знати на співбесіді: Як читати stacktrace, що він містить.

### **✅ Офіційне визначення:**

**Stacktrace** — це список викликів методів, який показує шлях виконання програми до моменту помилки. Його формує JVM, коли виникає виняток (**`Exception`**, **`Error`**).

### **🧠 Простими словами:**

Це історія подій, що показує, які методи викликались до того, як програма "впала". Допомагає зрозуміти, де саме і чому сталася помилка

---

## **Типи інформації у стеку (📊)**

| Рівень | Що містить |
| :---: | :---: |
| **Верхній рядок** | Тип винятку \+ повідомлення |
| **Далі** | Метод, клас, файл, рядок помилки |
| **Кінець** | Найперше джерело (корінь виклику) |

---

## **Пояснення на пальцях (💡)**

Уяви, метод **`A`** викликає **`B`**, а **`B`** викликає **`C`**, у **`C`** трапляється помилка.

Stacktrace покаже: **`C -> B -> A`** — від останнього виклику до першого (зверху вниз).

Це дозволяє:

* Знайти точку реальної помилки
* Побачити, хто кого викликав
* Зрозуміти, чому код дійшов саме до цього місця

---

## **Корисні приклади (🧪)**

```java
public class StacktraceDemo {
    public static void main(String[] args) {
        methodA();
    }

    static void methodA() {
        methodB();
    }

    static void methodB() {
        methodC();
    }

    static void methodC() {
        String s = null;
        System.out.println(s.length()); // NullPointerException
    }
}
```

**📥 Вивід:**

```java
Exception in thread "main" java.lang.NullPointerException
 at StacktraceDemo.methodC(StacktraceDemo.java:16)
 at StacktraceDemo.methodB(StacktraceDemo.java:12)
 at StacktraceDemo.methodA(StacktraceDemo.java:8)
 at StacktraceDemo.main(StacktraceDemo.java:4)
```

###

## **Як дістати stacktrace вручну**

```java
try {
    // ризикована операція
} catch (Exception e) {
    e.printStackTrace(); // друкує стек викликів
}
```

Можна зберегти у змінну:

```java
StringWriter sw = new StringWriter();
e.printStackTrace(new PrintWriter(sw));
String trace = sw.toString();
```

---

## **Порівняння варіантів отримання інформації (⚖️)**

| Варіант | Для чого |
| :---: | :---: |
| **`e.getMessage()`** | Короткий опис винятку |
| **`e.printStackTrace()`** | Повна інформація: що і де пішло не так |
| **`getStackTrace()` (масив)** | Для програмного обходу та аналізу |

---

## **🧠 Мнемоніка для запам’ятовування:**

**Stacktrace \= "стек викликів" -> показує шлях до біди**

* Вгорі — тип помилки
* Внизу — хто її викликав

---

## **🟩 Підсумок:**

* **`Stacktrace`** — головний інструмент діагностики помилок у Java
* Показує повну послідовність методів, які привели до винятку
* Формується автоматично JVM
* Читається зверху вниз (від джерела помилки до кореня)
* Ключовий інструмент для відлагодження, логування та аналізу помилок

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке стек-трейс (stack trace) в Java і яка його головна мета?

> #### **💬 Відповідь:**
>
> **Стек-трейс (Stack Trace)** — це звіт про стан **стека викликів методів** у певний момент часу, зазвичай, у момент виникнення винятку або помилки.
>
> **Головна мета:**
>
> Надати розробнику **діагностичну інформацію**, яка дозволяє зрозуміти, **що саме пішло не так** і **де саме** це сталося. Стек-трейс — це "карта" або "маршрут", який показує послідовність викликів методів, що призвела до помилки.
>
> **Що він містить:**
>
> 1. **Тип винятку та повідомлення:** Перший рядок показує, який виняток було кинуто (наприклад, `java.lang.NullPointerException`).
> 2. **Стек викликів:** Подальші рядки (фрейми стека) перераховують методи, починаючи з того, де виник виняток, і закінчуючи початковою точкою потоку (зазвичай, `main`).
> 3. **Місце в коді:** Кожен фрейм стека містить ім'я класу, назву методу, ім'я файлу та номер рядка, де відбувся виклик.
>
> Це є **основним інструментом для налагодження (debugging)** помилок у Java.

#### **📝 Аналогія:**

Стек-трейс — це як чорна скринька в літаку. Коли сталася аварія, вона показує повний запис дій пілотів (викликів методів) аж до моменту катастрофи.

#### **📌 Що перевіряють:**

*Базове розуміння того, що таке стек-трейс і чому він є найважливішим інструментом для діагностики помилок.*

* * *

### **2 ❓ Питання:**

Як правильно читати стек-трейс?

> #### **💬 Відповідь:**
>
> Стек-трейс потрібно читати **зверху вниз**.
>
> 1. **Верхній рядок — це головне.** Він містить **тип винятку та повідомлення про помилку**. Це найважливіша інформація, яка каже, **"ЩО"** сталося.
>     `java.lang.NullPointerException: Cannot invoke "String.length()" because "s" is null`
>
> 2. **Наступний рядок — це місце, де виникла помилка.** Він вказує на точний рядок коду, який призвів до проблеми. Зазвичай, саме з цього місця варто починати аналіз коду.
>     `at com.example.MyClass.methodC(MyClass.java:20)`
>
> 3. **Подальші рядки — це стек викликів.** Вони показують **"ХТО"** викликав "зламаний" метод. Ви спускаєтеся вниз по стеку, щоб зрозуміти, звідки прийшли дані або який потік виконання призвів до помилки.
>     `at com.example.MyClass.methodB(MyClass.java:15)`
>     `at com.example.MyClass.methodA(MyClass.java:10)`
>
> 4. **Звертайте увагу на `Caused by:` секції.** Вони вказують на ланцюжок винятків і допомагають знайти **першопричину** проблеми.
>
> **Короткий алгоритм:**
>
> 1. Подивіться на тип винятку.
> 2. Знайдіть **перший рядок з вашого власного коду** (вашого пакета, наприклад, `com.example...`). Зазвичай, саме там і знаходиться помилка.
> 3. Проаналізуйте контекст викликів, щоб зрозуміти, як програма дійшла до цього стану.

#### **📌 Що перевіряють:**

*Практичні навички налагодження. Кандидат повинен продемонструвати, що він вміє ефективно аналізувати стек-трейси, а не губиться в них.*

* * *

### **3 ❓ Питання:**

Яка різниця між `e.getMessage()` та `e.printStackTrace()`?

> #### **💬 Відповідь:**
>
> Це два різних способи отримати інформацію з об'єкта винятку.
>
> * **`e.getMessage()`:**
>   * **Що повертає:** **Рядок (`String`)**.
>   * **Призначення:** Повертає лише **коротке, людськочитабельне повідомлення про помилку**, яке було передано в конструктор винятку (наприклад, `"File not found"`).
>   * Цей метод корисний для показу помилки кінцевому користувачеві або для створення коротких лог-повідомлень. **Не містить інформації про стек викликів.**
>
> * **`e.printStackTrace()`:**
>   * **Що повертає:** **`void`**.
>   * **Призначення:** **Друкує повний стек-трейс** винятку (включаючи його тип, повідомлення та весь ланцюжок викликів) у стандартний потік помилок (`System.err`), що зазвичай є консоллю.
>   * Це основний інструмент для **налагодження під час розробки**. **Не слід використовувати `e.printStackTrace()` у продакшн-коді**, оскільки він пише напряму в консоль, оминаючи стандартну систему логування, і його вивід неможливо контролювати.
>
> **Правильна практика:** У продакшн-коді слід використовувати логгер, передаючи йому весь об'єкт винятку: `log.error("Помилка обробки", e);`. Логгер сам коректно відформатує і запише повний стек-трейс у потрібне місце.

#### **📌 Що перевіряють:**

*Знання стандартного API `Throwable` та найкращих практик для логування та обробки помилок.*

* * *

### **4 ❓ Питання:**

Що означає секція `Caused by:` у стек-трейсі?

> #### **💬 Відповідь:**
>
> Секція **`Caused by:`** з'являється у стек-трейсі, коли використовується механізм **ланцюжкових винятків (chained exceptions)**. Вона показує **першопричину** поточного винятку.
>
> **Як це працює:**
> Коли ви перехоплюєте низькорівневий виняток (наприклад, `SQLException`) і "загортаєте" його у свій власний, високорівневий (наприклад, `DataAccessException`), ви зберігаєте оригінальний виняток як `cause`.
>
> При виведенні стек-трейсу:
>
> 1. Спочатку друкується стек-трейс **зовнішнього** винятку (`DataAccessException`).
> 2. Потім з'являється секція `Caused by:`, після якої друкується **повний стек-трейс внутрішнього** винятку (`SQLException`).
>
> Цей механізм є надзвичайно важливим для діагностики проблем у багатошарових додатках, оскільки дозволяє простежити шлях помилки від високорівневої бізнес-логіки до її низькорівневого джерела.

#### **📌 Що перевіряють:**

*Розуміння патерну `exception wrapping` та вміння читати складні стек-трейси з кількома рівнями "Caused by".*

* * *

### **5 ❓ Питання:**

Як програмно отримати стек-трейс у вигляді масиву `StackTraceElement`? Для чого це може бути потрібно?

> #### **💬 Відповідь:**
>
> Для цього використовується метод **`getStackTrace()`** класу `Throwable`.
>
> `StackTraceElement[] elements = e.getStackTrace();`
>
> * Метод повертає масив об'єктів `StackTraceElement`.
> * Кожен об'єкт `StackTraceElement` містить детальну інформацію про один фрейм стека: ім'я класу, назву методу, ім'я файлу та номер рядка.
>
> **Для чого це може бути потрібно:**
>
> 1. **Кастомне форматування та аналіз:** Це дозволяє вам програмно аналізувати стек-трейс, а не просто виводити його як текст. Ви можете відфільтрувати непотрібні фрейми (наприклад, від фреймворків), знайти конкретний виклик, або відформатувати вивід для спеціалізованих систем моніторингу та логування.
>
> 2. **Створення систем моніторингу та профілювання:** Інструменти типу APM (Application Performance Monitoring) використовують цей механізм для аналізу помилок та вузьких місць у продуктивності.
>
> 3. **Отримання інформації про поточний стек викликів:** Ви можете отримати стек-трейс і для поточного потоку, навіть без винятку, за допомогою `Thread.currentThread().getStackTrace()`.
>
> Це потужний інструмент для глибокого аналізу та інтроспекції.

#### **📌 Що перевіряють:**

*Знання просунутого API `Throwable` та здатність мислити про програмну обробку стек-трейсів, а не тільки про їх читання.*

* * *

### **6 ❓ Питання:**

Чому іноді в стек-трейсі можна побачити "Unknown Source" або відсутність номерів рядків? ⭐️

> #### **💬 Відповідь:**
>
> Це відбувається, коли JVM **не має доступу до налагоджувальної інформації (debug information)** для скомпільованого `.class` файлу.
>
> **Причина:**
>
> * Налагоджувальна інформація, включаючи номери рядків та імена локальних змінних, додається компілятором `javac` у `.class` файл за замовчуванням.
> * Однак, при компіляції можна використовувати спеціальні прапори, щоб **вимкнути** генерацію цієї інформації для зменшення розміру файлів.
>     `javac -g:none MyClass.java`
>
> * Також, деякі інструменти для **обфускації коду** навмисно видаляють цю інформацію, щоб ускладнити реверс-інжиніринг.
>
> Коли виняток виникає в коді, скомпільованому без цієї інформації, JVM не може визначити номер рядка або ім'я файлу, і тому пише `(Unknown Source)` або `(Native Method)`, якщо помилка сталася в нативному коді.
>
> Тому для розробки та налагодження завжди важливо компілювати код з повною налагоджувальною інформацією (`-g` прапор `javac`).

#### **📌 Що перевіряють:**

*Розуміння того, звідки JVM бере інформацію для стек-трейсу, та як на це впливають опції компіляції.*

* * *

### **7 ❓ Питання:**

Яким чином JIT-компіляція може вплинути на вигляд стек-трейсу? Що таке інлайнінг методів? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **JIT (Just-In-Time) компілятор** виконує агресивні оптимізації коду під час виконання для підвищення продуктивності. Одна з таких оптимізацій — **інлайнінг методів (method inlining)**.
>
> **Інлайнінг** — це процес, при якому JIT-компілятор замість виклику методу **вставляє тіло цього методу безпосередньо** в місце виклику.
>
> **Вплив на стек-трейс:**
>
> * Якщо метод був заінлайнений, він **зникає зі стека викликів**.
> * Це може значно **скоротити та ускладнити стек-трейс**. Якщо помилка виникає всередині заінлайненого коду, стек-трейс буде показувати на **викличний метод**, а не на той, де насправді містилася помилка.
>
> **Приклад:**
>
> Якщо метод `b()` був заінлайнений в `a()`, а помилка сталася в `b()`, стек-трейс може виглядати так:
> `... at MyClass.a(MyClass.java:10)`
>
> Замість:
> `... at MyClass.b(MyClass.java:20)`
> `... at MyClass.a(MyClass.java:10)`
>
> **Навіщо це знати:**
>
> Це може сильно ускладнити налагодження в продакшені. Існують спеціальні опції JVM (`-XX:-Inline`), щоб вимкнути інлайнінг для діагностики, але це сильно впливає на продуктивність. Сучасні JVM намагаються зберігати інформацію для більш точних стек-трейсів навіть при інлайнінгу.

#### **📌 Що перевіряють:**

*Глибокі знання про роботу JIT-компілятора та його вплив на діагностику. Це просунуте питання.*

* * *

### **8 ❓ Питання:**

Що виведе цей код? Поясніть потік виконання.

```java
try {
    throw new RuntimeException();
} finally {
    System.out.println("Finally");
}
```

> #### **💬 Відповідь:**
>
> Цей код **скомпілюється**, але при запуску виведе "Finally", а потім **завершиться з неперехопленим `RuntimeException`**.
>
> **Потік виконання:**
>
> 1. `try` блок кидає `RuntimeException`.
> 2. Виконання `try` блоку негайно припиняється.
> 3. JVM бачить, що є `finally` блок, і **перед тим, як прокинути виняток далі**, виконує його.
> 4. На консоль виводиться **"Finally"**.
> 5. Після завершення `finally`, оскільки немає `catch` блоку для обробки `RuntimeException`, виняток прокидається далі.
> 6. Оскільки це `main` потік, і виняток не оброблений, потік завершує свою роботу, і JVM друкує стек-трейс цього винятку.
>
> Отже, `finally` виконується, але це не "рятує" програму від неперехопленого винятку.

#### **📌 Що перевіряють:**

*Розуміння того, що `finally` виконується навіть при неперехоплених винятках.*

* * *

### **9 ❓ Питання:**

Як отримати поточний стек викликів, не кидаючи виняток? ⭐️

> #### **💬 Відповідь:**
>
> Це можна зробити кількома способами:
>
> **1. `Thread.currentThread().getStackTrace()`:**
>
> * Це найпростіший і найпоширеніший спосіб.
> * Він повертає масив `StackTraceElement[]` для **поточного потоку**.
> * Перший елемент масиву (`[0]`) — це сам `getStackTrace()`, другий (`[1]`) — метод, який його викликав, і так далі.
>
> ```java
> public void myMethod() {
>     StackTraceElement[] stackTrace = Thread.currentThread().getStackTrace();
>     System.out.println("Мене викликав: " + stackTrace[2].getMethodName());
> }
> ```
>
> **2. `new Throwable().getStackTrace()`:**
>
> * Можна створити екземпляр `Throwable` (або будь-якого його нащадка), але **не кидати** його.
> * Створення об'єкта `Throwable` автоматично "захоплює" поточний стек викликів.
> * Потім можна викликати на ньому `.getStackTrace()`.
>
> Цей підхід є **швидшим**, ніж `Thread.currentThread().getStackTrace()`, оскільки він не вимагає звернення до самого потоку, а працює з локальним об'єктом. Це корисно в коді, критичному до продуктивності.

#### **📌 Що перевіряють:**

*Знання інструментів для інтроспекції та профілювання.*

* * *

### **10 ❓ Питання:**

Як виглядає стек-трейс для рекурсивного виклику, що призвів до `StackOverflowError`? ⭐️

> #### **💬 Відповідь:**
>
> Стек-трейс у цьому випадку буде дуже **довгим та одноманітним**.
>
> Він буде складатися з **багатьох тисяч однакових рядків**, що повторюються, вказуючи на той самий рекурсивний метод, який викликає сам себе.
>
> **Приклад коду:**
>
> ```java
> public void recursiveCall() {
>     recursiveCall();
> }
> ```
>
> **Спрощений стек-трейс:**
>
> ```
> Exception in thread "main" java.lang.StackOverflowError
>  at com.example.MyClass.recursiveCall(MyClass.java:5)
>  at com.example.MyClass.recursiveCall(MyClass.java:5)
>  at com.example.MyClass.recursiveCall(MyClass.java:5)
>  at com.example.MyClass.recursiveCall(MyClass.java:5)
>     ... (багато-багато разів) ...
>  at com.example.MyClass.recursiveCall(MyClass.java:5)
> ```
>
> Це один з найлегших для розпізнавання стек-трейсів. Якщо ви бачите довгий ланцюжок однакових викликів, це майже гарантовано свідчить про **нескінченну або неконтрольовану рекурсію**. Потрібно шукати базовий випадок (умову виходу), якого бракує або який ніколи не досягається.

#### **📌 Що перевіряють:**

*Практичний досвід налагодження. Кандидат повинен вміти розпізнавати типові патерни помилок у стек-трейсах.*

* * *

### **11 ❓ Питання:**

У чому різниця між `Exception` та `RuntimeException` у стек-трейсі? ⭐️⭐️

> #### **💬 Відповідь:**
>
> З точки зору **самої структури та інформації** в стек-трейсі — **ніякої різниці немає**.
>
> * І для `checked`, і для `unchecked` винятків стек-трейс генерується **однаково**.
> * Він завжди містить тип винятку, повідомлення та послідовність фреймів стека.
>
> **Різниця полягає не у вигляді стек-трейсу, а в тому, ЯК програма до нього прийшла:**
>
> * Якщо ви бачите стек-трейс `checked` винятку (наприклад, `IOException`) на верхньому рівні, це означає, що **жоден з методів** у ланцюжку викликів його **не обробив**, а лише **"прокидав" далі** за допомогою `throws`.
>
> * Якщо ви бачите стек-трейс `unchecked` винятку (наприклад, `NullPointerException`), це означає, що сталася **програмна помилка**, яку компілятор **не вимагав обробляти**, і вона "спливла" наверх.
>
> Таким чином, стек-трейс є просто "знімком" помилки, а те, чи є вона `checked` чи `unchecked`, визначає лише правила її обробки, які перевіряє компілятор.

#### **📌 Що перевіряють:**

*Точне розуміння того, що різниця між `checked`/`unchecked` — це про правила компіляції, а не про те, як помилка виглядає під час виконання.*

* * *

### **12 ❓ Питання:**

Чи можна маніпулювати стек-трейсом винятку? Якщо так, то як і навіщо? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, можна.**
>
> Клас `Throwable` надає метод **`setStackTrace(StackTraceElement[] stackTrace)`**, який дозволяє **замінити** існуючий стек-трейс на новий, кастомний.
>
> **Навіщо це може бути потрібно:**
>
> 1. **Очищення стек-трейсу:** У складних фреймворках (особливо тих, що використовують багато рефлексії або проксі) стек-трейс може бути дуже "зашумленим" внутрішніми викликами фреймворку, які не є корисними для кінцевого користувача. Іноді фреймворк може "очистити" стек-трейс, залишаючи лише ті частини, що стосуються коду користувача.
>
> 2. **Створення винятків без стек-трейсу:** Створення стек-трейсу — це найдорожча частина ініціалізації винятку. У дуже високопродуктивних системах, де винятки використовуються для керування потоком (що є антипатерном, але трапляється), можна створити кастомний виняток, який не заповнює стек-трейс, щоб уникнути витрат продуктивності.
>
>     ```java
>     public class FastException extends RuntimeException {
>         @Override
>         public synchronized Throwable fillInStackTrace() {
>             return this; // Не заповнювати стек-трейс
>         }
>     }
>     ```
>
> **Однак:** Маніпуляція стек-трейсом — це дуже **просунута і небезпечна техніка**. У звичайних додатках її слід уникати, оскільки це може приховати важливу діагностичну інформацію.

#### **📌 Що перевіряють:**

*Експертні знання API `Throwable` та розуміння дуже специфічних сценаріїв оптимізації або кастомізації.*

* * *

### **13 ❓ Питання:**

Поясніть, що станеться зі стек-трейсом тут:
`catch (Exception e) { throw new RuntimeException(); }` ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> У цьому випадку **оригінальний стек-трейс буде повністю втрачено**.
>
> **Пояснення:**
>
> 1. У `catch` блоці ловиться виняток `e`.
> 2. Потім створюється і кидається **абсолютно новий об'єкт** `new RuntimeException()`.
> 3. Коли створюється цей новий виняток, його стек-трейс **генерується з поточного місця**. Тобто, він почнеться з рядка `throw new RuntimeException();` і не буде містити жодної інформації про те, що сталося до цього.
>
> Це одна з **найгірших практик обробки винятків**. Ви бачите, що щось зламалося, але втрачаєте всю інформацію про те, **де і чому** це сталося спочатку.
>
> **Правильним способом** є "загортання" винятку, щоб зберегти ланцюжок:
>
> `catch (Exception e) { throw new RuntimeException(e); }`
>
> У цьому випадку новий `RuntimeException` буде містити `e` як свою **причину (`cause`)**, і оригінальний стек-трейс буде збережено.

#### **📌 Що перевіряють:**

*Розуміння того, як важливо зберігати `cause` при загортанні винятків. Це перевірка на професійну зрілість.*

* * *

### **14 ❓ Питання:**

Чи завжди `e.printStackTrace()` друкує вивід після основного потоку виконання? Чому його не рекомендують у багатопотокових додатках? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Не завжди.** `e.printStackTrace()` друкує в потік **`System.err`**, тоді як `System.out.println()` друкує в **`System.out`**.
>
> * Ці два потоки зазвичай є одним і тим самим (консоллю), але це **не гарантовано**.
> * Що більш важливо, вони **не синхронізовані** між собою.
>
> Це означає, що вивід з `System.out` та `System.err` може **перемішуватися** у непередбачуваному порядку. Ви можете побачити спочатку вивід, що йде після `catch` блоку, а лише потім — сам стек-трейс.
>
> **Чому його не рекомендують у багатопотокових додатках:**
>
> 1. **Перемішування виводу:** Якщо кілька потоків одночасно кинуть винятки, їхні стек-трейси будуть хаотично перемішані в консолі, і розібрати, який стек-трейс до якої помилки належить, буде неможливо.
>
> 2. **Відсутність контексту:** Вивід не містить інформації про час, ім'я потоку, чи будь-який інший корисний контекст.
>
> 3. **Негнучкість:** Ви не можете перенаправити цей вивід у файл чи систему централізованого логування.
>
> Тому в будь-якому серйозному додатку для виводу інформації про помилки слід використовувати **спеціалізовані лог-фреймворки** (Log4j2, SLF4J + Logback), які вирішують всі ці проблеми.

#### **📌 Що перевіряють:**

*Розуміння недоліків `printStackTrace()` для реальних, особливо багатопотокових, систем. Знання найкращих практик логування.*

* * *

### **15 ❓ Питання:**

Що виведе цей код, і який стек-трейс ми побачимо в кінці?

```java
public static void main(String[] args) {
    try {
        System.out.println("Result: " + test());
    } catch (Exception e) {
        e.printStackTrace();
    }
}
public static int test() {
    try {
        throw new Exception("From try");
    } finally {
        return 42;
    }
}
```

⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Вивід у консоль:**
>
> ```
> Result: 42
> ```
>
> **Стек-трейсу ми не побачимо взагалі.**
>
> **Пояснення (це дуже тонка пастка):**
>
> 1. Метод `main` викликає `test()`.
> 2. У методі `test()`, `try` блок кидає `new Exception("From try")`.
> 3. Потік виконання готується прокинути цей виняток.
> 4. **Але перед цим** виконується блок `finally`.
> 5. У `finally` блоці є інструкція **`return 42;`**.
> 6. `return` у `finally` **перериває будь-яку попередню дію**, включаючи процес прокидання винятку.
> 7. Метод `test()` **нормально завершується** і повертає значення `42`.
> 8. Виняток, кинутий у `try`, **просто "проковтується"** і зникає назавжди.
> 9. Оскільки `test()` завершився нормально, а не через виняток, `catch` блок у `main` не виконується.
> 10. `System.out.println()` у `main` виводить повернутий результат — `42`.
>
> Це екстремальний приклад того, чому `return` у `finally` є абсолютною поганою практикою: він може повністю приховати той факт, що в програмі сталася помилка.

#### **📌 Що перевіряють:**

*Експертний рівень розуміння того, як `finally` і `return` взаємодіють з винятками. Кандидат повинен знати, що `return` у `finally` може "з'їсти" виняток.*
