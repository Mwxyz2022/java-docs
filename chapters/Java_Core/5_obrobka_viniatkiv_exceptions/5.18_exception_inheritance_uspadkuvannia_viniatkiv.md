---
layout: default
title: "Exception Inheritance (успадкування винятків)"
parent: "Обробка винятків (Exceptions)"
grand_parent: "Java Core"
nav_order: 18
---

# Exception Inheritance (успадкування винятків)

* короткий опис: Побудова власної ієрархії винятків шляхом наслідування від `Exception` або `RuntimeException`, що дозволяє групувати пов'язані помилки та обробляти їх на різних рівнях деталізації.

* поняття: Ієрархія винятків, базовий клас винятку.

* приклади: `ValidationException` (базовий клас) з підкласами `EmailFormatException` та `PasswordTooShortException`.

* ключові моменти: Дозволяє групову обробку винятків (наприклад, `catch (ValidationException e)`), підвищує структурованість помилок.

* що важливо знати на співбесіді: Навіщо створювати ієрархію, переваги групової обробки.

### **✅ Офіційне визначення:**

У Java всі винятки є підкласами класу **`Throwable`**. Створення власних винятків дозволяє будувати свою ієрархію помилок шляхом наслідування класів **`Exception`** або **`RuntimeException`**.

### **🧠 Простими словами:**

Це коли ти створюєш свої типи помилок, які наслідують спільного "батька", щоб їх можна було:

* ловити разом (групово),
* обробляти вибірково,
* зберігати структуру винятків, як дерево родинних класів.

---

## **📊 Приклад ієрархії винятків:**

```java
Throwable
 ├─ Exception
 │   │
 │   ├─ ValidationException
 │   │   ├─ EmailFormatException
 │   │   └─ PasswordTooShortException
 │   │
 │   └─ BusinessException
 │       │
 │       └─ InsufficientBalanceException
 │
 └─ Error (не наслідуємо)
```

* **Throwable** — корінь усіх винятків
* **Exception** — перевіряються (checked)
* **RuntimeException** — неперевіряються (unchecked)
* **Error** — системні помилки JVM (не для наслідування)

---

## **Пояснення на пальцях (💡)**

* Уяви, що ти маєш десятки винятків, пов’язаних з валідацією.  
  Щоб не ловити кожен окремо, створюєш **базовий тип `ValidationException`**, а вже під нього:
  * **`EmailFormatException`**
  * **`PasswordTooShortException`**

* Тепер у **`try-catch`** ти можеш:
  * зловити **всі** валідаційні помилки через **`ValidationException`**
  * або **вибірково** — лише **`EmailFormatException`**

Це як наслідування у класах, тільки для **помилок** — зручно, логічно, масштабовано.

---

## **Корисні приклади (🧪)**

```java
// базовий клас
public class ValidationException extends Exception {
    public ValidationException(String message) {
        super(message);
    }
}

// підкласи
public class EmailFormatException extends ValidationException {
    public EmailFormatException(String email) {
        super("Невірний формат email: " + email);
    }
}

public class PasswordTooShortException extends ValidationException {
    public PasswordTooShortException(int length) {
        super("Пароль занадто короткий: " + length + " символів");
    }
}
```

**🔸 Використання:**

```java
try {
    String email = "test@";
    if (!email.contains("@")) {
        throw new EmailFormatException(email);
    }
} catch (ValidationException e) {
    System.out.println("Помилка валідації: " + e.getMessage());
}
```

---

## **Порівняння (⚖️)**

| Варіант | Коли використовувати |
| :---: | :---: |
| **Один клас винятку** | Коли винятків небагато або всі однакові по суті |
| **Ієрархія винятків (успадкування)** | Коли потрібно групувати, деталізувати і керувати типами |

---

## **🧠 Мнемоніка для запам’ятовування:**

* **`ValidationException`** -> БАТЬКО  
  ↳ **`EmailFormatException`**  
  ↳ **`PasswordTooShortException`**

👉 Ловиш батька — ловиш усіх дітей.  
👉 Побудова винятків — як **сімейне дерево**.

---

## **🟩 Підсумок:**

* Ієрархія винятків дозволяє структуровано працювати з помилками.
* Можна **групувати**, **розділяти**, **перевикористовувати** винятки.
* Створюй власні винятки, наслідуючи **`Exception`** або **`RuntimeException`**.
* Не забувай про коректне наслідування конструкторів.

---

### **🔗 Додаткові джерела:**

* [**Oracle Docs — Creating Your Own Exception Classes**](https://docs.oracle.com/javase/tutorial/essential/exceptions/creating.html)

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке ієрархія винятків і навіщо її створювати?

> #### **💬 Відповідь:**
>
> **Ієрархія винятків** — це створення структури власних (кастомних) класів винятків за допомогою **наслідування**. Зазвичай, створюється один загальний базовий клас винятку для певного модуля або типу помилок, а від нього успадковуються більш специфічні винятки.
>
> **Навіщо це потрібно:**
>
> 1. **Групування та категоризація помилок:** Дозволяє логічно згрупувати всі помилки, що стосуються певної частини функціоналу (наприклад, всі помилки валідації успадковуються від `ValidationException`).
>
> 2. **Гнучка обробка:** Надає клієнтському коду вибір, наскільки детальною має бути обробка. Можна:
>     * Зловити **конкретну помилку** (`catch (InvalidEmailException e)`).
>     * Зловити **цілу групу помилок** одним махом, перехопивши їхнього спільного батька (`catch (ValidationException e)`).
>
> 3. **Повторне використання коду:** Спільну логіку або поля (наприклад, код помилки) можна винести в базовий клас винятку.
>
> 4. **Покращення API:** API стає чистішим, оскільки метод може оголошувати `throws BaseApiException`, а не перераховувати десятки специфічних помилок.

#### **📝 Аналогія:**

Це як теки на комп'ютері. Ви можете мати головну теку `Документи`, а всередині — підтеки `Робота`, `Особисте`, `Навчання`. Це дозволяє вам або знайти конкретний файл, або працювати з усією групою документів одразу.

#### **📌 Що перевіряють:**

*Розуміння того, що ієрархії винятків — це потужний інструмент для структурування та спрощення обробки помилок.*

* * *

### **2 ❓ Питання:**

Напишіть приклад простої ієрархії винятків для системи онлайн-платежів.

> #### **💬 Відповідь:**
>
> Звісно. Розробимо ієрархію для очікуваних бізнес-помилок.
>
> **Крок 1: Базовий `checked` виняток для всіх платіжних помилок.**
>
> ```java
> public class PaymentException extends Exception {
>     public PaymentException(String message) {
>         super(message);
>     }
>     public PaymentException(String message, Throwable cause) {
>         super(message, cause);
>     }
> }
> ```
>
> **Крок 2: Специфічні нащадки.**
>
> ```java
> public class InsufficientFundsException extends PaymentException {
>     private final double currentBalance;
>
>     public InsufficientFundsException(double balance) {
>         super("Недостатньо коштів на рахунку.");
>         this.currentBalance = balance;
>     }
>
>     public double getCurrentBalance() {
>         return currentBalance;
>     }
> }
>
> public class PaymentGatewayTimeoutException extends PaymentException {
>     public PaymentGatewayTimeoutException(String message, Throwable cause) {
>         super(message, cause);
>     }
> }
> ```
>
> **Як це використовується:**
>
> ```java
> try {
>     paymentService.processPayment(...);
> } catch (InsufficientFundsException e) {
>     // Показати користувачеві "Недостатньо коштів"
>     // Можна отримати баланс: e.getCurrentBalance()
> } catch (PaymentGatewayTimeoutException e) {
>     // Запропонувати повторити спробу
> } catch (PaymentException e) {
>     // Обробити будь-яку іншу платіжну помилку
> }
> ```

#### **📌 Що перевіряють:**

*Практичні навички проектування кастомних винятків та їх ієрархії.*

* * *

### **3 ❓ Питання:**

Як порядок `catch`-блоків пов'язаний з ієрархією винятків?

> #### **💬 Відповідь:**
>
> Порядок `catch`-блоків напряму залежить від ієрархії, і компілятор суворо це контролює.
>
> **Правило:** Винятки повинні перехоплюватися в порядку **від більш специфічного (дочірнього) до більш загального (батьківського)**.
>
> **Пояснення:**
>
> JVM перевіряє `catch`-блоки послідовно. Якщо б більш загальний виняток стояв першим, він би **перехоплював і себе, і всіх своїх нащадків**. Більш специфічні `catch`-блоки, що стоять нижче, ніколи б не виконались.
>
> **Приклад з нашої ієрархії:**
>
> **Правильно:**
>
> ```java
> try { ... }
> catch (InsufficientFundsException e) { /* ... */ } // Нащадок
> catch (PaymentException e) { /* ... */ }           // Батько
> ```
>
> **Неправильно (помилка компіляції):**
>
> ```java
> try { ... }
> catch (PaymentException e) { /* ... */ }
> // ПОМИЛКА: InsufficientFundsException вже було зловлено як PaymentException
> catch (InsufficientFundsException e) { /* ... */ }
> ```
>
> Компілятор виявить, що другий `catch` є **недосяжним кодом (unreachable code)**.

#### **📌 Що перевіряють:**

*Розуміння того, як поліморфізм працює в `catch`-блоках і чому порядок є критичним.*

* * *

### **4 ❓ Питання:**

Який зв'язок між ієрархією винятків та принципами SOLID, зокрема, LSP?

> #### **💬 Відповідь:**
>
> Ієрархія винятків тісно пов'язана з **Принципом підстановки Лісков (LSP)** та **Принципом відкритості/закритості (OCP)**.
>
> **Liskov Substitution Principle (LSP):**
>
> * `throws` клауза є частиною контракту методу. LSP вимагає, щоб дочірній клас не "ламав" контракт батька.
> * Тому, при перевизначенні методу, дочірній клас **не може кидати новий або ширший `checked` виняток**. Він може лише звузити набір винятків (кинути підклас) або не кидати їх взагалі.
> * Ієрархія винятків дозволяє це зробити елегантно: якщо батьківський метод кидає `PaymentException`, дочірній може кидати `InsufficientFundsException` (його нащадка), і LSP не буде порушено.
>
> **Open/Closed Principle (OCP):**
>
> * Принцип каже, що система має бути відкритою для розширення, але закритою для модифікації.
> * Ієрархія винятків дозволяє **додавати нові типи помилок** (нові класи-винятки), **не змінюючи існуючий клієнтський код**, який вже обробляє базовий виняток.
> * Наприклад, ви можете додати `FraudDetectionException extends PaymentException`. Існуючий `catch (PaymentException e)` продовжить його ловити, якщо специфічна обробка не потрібна.

#### **📌 Що перевіряють:**

*Архітектурне мислення. Здатність пов'язати принципи SOLID з практичними аспектами проектування системи обробки помилок.*

* * *

### **5 ❓ Питання:**

Поясніть патерн "загортання винятків" (Exception Wrapping) у контексті ієрархії. Коли він корисний? ⭐️

> #### **💬 Відповідь:**
>
> **"Загортання винятків"** — це патерн, коли ви ловите низькорівневий виняток (наприклад, з бібліотеки) і кидаєте замість нього свій власний, високорівневий виняток, передаючи оригінальний як причину (`cause`).
>
> **Користь у контексті ієрархії:**
>
> Цей патерн дозволяє **абстрагувати** вищі шари вашого додатка від деталей реалізації нижчих, приводячи різні технічні помилки до єдиної доменної ієрархії.
>
> **Сценарій:**
> У вас є `DataRepository`, який може працювати з SQL базою або з файлами.
>
> ```java
> public class UserRepository {
>     public User find() {
>         try {
>             // може кинути або SQLException, або IOException
>         } catch (SQLException | IOException e) {
>             // Ми "ховаємо" технічні деталі за нашою абстракцією
>             throw new DataAccessException("Помилка доступу до даних", e);
>         }
>     }
> }
> ```
>
> **`DataAccessException`** — це базовий виняток у нашій ієрархаті.
>
> **Переваги:**
>
> * **Сервісний шар** (що викликає `UserRepository`) більше не залежить ні від `SQLException`, ні від `IOException`. Він працює лише з одним типом помилки — `DataAccessException`.
> * Це значно **спрощує код сервісного шару** та робить його **незалежним** від того, як саме реалізовано шар даних. Ми можемо замінити базу даних на файли, і сервіс не зміниться. Це пряма підтримка слабкої зв'язності.

#### **📌 Що перевіряють:**

*Розуміння того, як exception wrapping використовується для побудови абстрактних шарів в архітектурі.*

* * *

### **6 ❓ Питання:**

Чому клас `RuntimeException` та його нащадки не підлягають перевірці компілятором, навіть якщо вони є частиною ієрархії `Exception`? ⭐️

> #### **💬 Відповідь:**
>
> Це **особливе правило, вбудоване в компілятор Java**. Він має інструкцію: "якщо виняток є `RuntimeException` або його нащадком, не вимагати його обробки у `try-catch` або оголошення у `throws`".
>
> **Чому це правило було введено:**
>
> `RuntimeException`'и призначені для сигналізації про **програмерські баги** (`NullPointerException`, `IndexOutOfBoundsException` тощо). Такі помилки можуть виникнути практично в **будь-якому рядку коду**.
>
> Якби вони були `checked`, то:
>
> * Практично кожен метод у Java повинен був би мати гігантську `throws` клаузу з переліком усіх можливих `RuntimeException`.
> * Код був би неймовірно засмічений `try-catch` блоками для обробки того, що насправді є багом.
>
> Таким чином, `RuntimeException` є частиною ієрархаті `Exception` **логічно** (бо це виняткова ситуація в програмі), але з нього "знято" вимогу перевірки компілятором з **прагматичних міркувань**, щоб не ускладнювати код.

#### **📌 Що перевіряють:**

*Глибоке розуміння філософії поділу на `checked` / `unchecked` та ролі `RuntimeException` у цьому.*

* * *

### **7 ❓ Питання:**

Чи може дочірній клас у перевизначеному методі звузити тип `checked` винятку? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, може, і це є гарною практикою.**
>
> Правило перевизначення щодо `checked` винятків стверджує, що дочірній метод **не може розширювати** список винятків, але може його **звужувати** або залишати без змін.
>
> Це означає, що перевизначений метод може:
>
> * Не кидати жодних `checked` винятків.
> * Кидати той самий виняток.
> * Кидати **підклас** цього винятку.
>
> **Приклад:**
>
> ```java
> class DataProcessor {
>     void process() throws java.io.IOException {}
> }
>
> class TextFileProcessor extends DataProcessor {
>     @Override
>     // OK: FileNotFoundException є нащадком IOException
>     void process() throws java.io.FileNotFoundException {}
> }
> ```
>
> **Чому це дозволено:**
> Це не порушує **Принцип підстановки Лісков (LSP)**. Код, який очікує і вміє обробляти `IOException` (батька), без проблем зможе обробити і його нащадка, `FileNotFoundException`.

#### **📌 Що перевіряють:**

*Знання правил перевизначення, пов'язаних з `throws` клаузою.*

* * *

### **8 ❓ Питання:**

Розробіть власну ієрархію винятків для API-клієнта, який спілкується з веб-сервісом. ⭐️⭐️

> #### **💬 Відповідь:**
>
> Гарна ієрархія повинна розділяти проблеми, пов'язані з мережею, та логічні помилки на боці сервера.
>
> **1. Базовий `checked` виняток:**
> `public class ApiClientException extends Exception`
> Він буде коренем для всіх очікуваних проблем, пов'язаних з API.
>
> **2. Ієрархія нащадків:**
>
> * **`NetworkException extends ApiClientException`:** для помилок, пов'язаних зі з'єднанням (наприклад, загортання `SocketTimeoutException`).
> * **`ServerResponseException extends ApiClientException`:** для помилок, коли сервер відповів, але зі статусом помилки (4xx, 5xx).
>   * **`AuthenticationException extends ServerResponseException`:** для помилок 401/403.
>   * **`BadRequestException extends ServerResponseException`:** для помилок 400.
>   * **`ServerErrorException extends ServerResponseException`:** для помилок 5xx.
>
> **3. `unchecked` виняток для багів:**
>
> * `public class ApiMisuseException extends RuntimeException`
> Кидається, якщо сам клієнтський код неправильно використовує API (наприклад, передає `null` туди, де це заборонено).
>
> **Як це використовується:**
>
> ```java
> try {
>     apiClient.getUser(1);
> } catch (AuthenticationException e) {
>     // оновити токен доступу
> } catch (ServerResponseException e) {
>     // показати користувачу помилку від сервера
> } catch (ApiClientException e) {
>     // обробити будь-яку іншу помилку API (наприклад, мережеву)
> }
> ```
>
> Така структура робить клієнтський код дуже гнучким і дозволяє точно реагувати на різні типи помилок.

#### **📌 Що перевіряють:**

*Навички проектування API та архітектури обробки помилок у розподілених системах.*

* * *

### **9 ❓ Питання:**

Чи може конструктор кастомного винятку бути `private`? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, може.** Це застосовується нечасто, але має сенс у певних сценаріях, зазвичай у поєднанні зі **статичними фабричними методами**.
>
> **Навіщо це може бути потрібно:**
>
> 1. **Кешування винятків:** Якщо у вас є винятки, які не містять унікального стану і можуть виникати дуже часто (наприклад, в "гарячому" циклі), ви можете створити **єдиний статичний екземпляр** цього винятку і повертати його, щоб уникнути дорогої операції створення об'єкта та заповнення стек-трейсу.
>
> **Приклад:**
>
> ```java
> public class ValidationFailedException extends RuntimeException {
>     // Створюємо єдиний екземпляр
>     public static final ValidationFailedException INSTANCE = new ValidationFailedException();
>
>     // Робимо конструктор приватним
>     private ValidationFailedException() {
>         super(null, null, false, false); // Вимикаємо стек-трейс для швидкодії
>     }
> }
> // Використання: throw ValidationFailedException.INSTANCE;
> ```
>
> 2. **Більший контроль над створенням:** Фабричний метод може додати якусь логіку перед тим, як створити виняток (наприклад, залогувати щось).
>
> Це просунута техніка оптимізації, яка виправдана лише у дуже високопродуктивних системах.

#### **📌 Що перевіряють:**

*Знання просунутих патернів та технік оптимізації.*

* * *

### **10 ❓ Питання:**

Чи може кастомний `RuntimeException` успадковувати `checked Exception`? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, це неможливо логічно і синтаксично.**
>
> Це питання з підступом, яке перевіряє розуміння ієрархії.
>
> * `RuntimeException` є **нащадком** `Exception`.
> * У Java не існує "множинного наслідування класів".
>
> Тому клас **не може одночасно** успадковувати і `RuntimeException`, і якийсь інший `checked` виняток (наприклад, `IOException`).
>
> Тип винятку (`checked` чи `unchecked`) однозначно визначається його **найближчим предком** в ієрархаті, що походить від `Exception`.
>
> * Якщо він успадковує `RuntimeException` — він `unchecked`.
> * Якщо він успадковує `Exception` напряму або інший `checked` нащадок — він `checked`.
>
> Не можна бути одночасно і тим, і іншим.

#### **📌 Що перевіряють:**

*Уважність та чітке розуміння правил наслідування в Java.*

* * *

### **11 ❓ Питання:**

Чому кажуть, що порушення контракту `equals/hashCode` не кидає виняток, але ламає ієрархію обробки в `HashSet`? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Це гарне питання про неявні контракти. Порушення контракту `equals`/`hashCode` саме по собі **не кидає виняток**, але призводить до того, що **логіка хеш-колекцій перестає працювати правильно**, що може призвести до **неправильної поведінки програми**, але не до винятку.
>
> **Що відбувається:**
> `HashSet` та `HashMap` використовують `hashCode()` для швидкого визначення "кошика" (bucket), де має зберігатися об'єкт, а `equals()` — для вирішення колізій усередині цього кошика.
>
> **Якщо контракт порушено (наприклад, `a.equals(b)` є `true`, а `a.hashCode() != b.hashCode()`):**
>
> 1. Ви додаєте об'єкт `a` в `HashSet`. Він потрапляє в кошик №1 (на основі `a.hashCode()`).
> 2. Ви намагаєтеся додати логічно рівний об'єкт `b`.
> 3. `HashSet` обчислює `b.hashCode()`, отримує інше значення, і кладе `b` в кошик №2.
>
> **Результат:** `HashSet` тепер містить два **логічних дублікати**, що порушує його основний контракт (зберігати лише унікальні елементи). **Винятку при цьому не буде**, але стан колекції стає некоректним.
>
> Ієрархія обробки помилок тут ні до чого, бо це не виняткова ситуація, а **тиха логічна помилка** через порушення контракту.

#### **📌 Що перевіряють:**

*Глибоке розуміння того, як працюють колекції та що таке "порушення контракту". Не всі помилки в коді є винятками.*

* * *

### **12 ❓ Питання:**

Як `multi-catch` працює з ієрархією кастомних винятків?
`catch (MyChildException | MySiblingException e)`
⭐️⭐️

> #### **💬 Відповідь:**
>
> `multi-catch` працює з кастомними винятками за тими ж правилами, що і зі стандартними.
>
> 1. Ви можете перераховувати кілька своїх кастомних винятків, якщо вони не є в ієрархії один одного.
>
> 2. **Тип змінної `e`** буде їхнім **найближчим спільним супертипом**.
>
> **Розглянемо ієрархію:**
> `ValidationException` ← `EmailException`, `PasswordException`.
>
> * **`catch (EmailException | PasswordException e)`:**
>   * Це валідно.
>   * Типом `e` буде їхній спільний батько, `ValidationException`.
>
> * **`catch (ValidationException | EmailException e)`:**
>   * Це **не валідно** і призведе до помилки компіляції, оскільки `EmailException` є нащадком `ValidationException`.
>
> Таким чином, `multi-catch` змушує вас працювати на рівні спільної абстракції для групи помилок, що може бути дуже зручно.

#### **📌 Що перевіряють:**

*Здатність застосувати знання про `multi-catch` до власних ієрархій винятків.*

* * *

### **13 ❓ Питання:**

Чи можна створити дженерік-клас винятку (`MyException<T>`)? Чому так чи ні? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, це неможливо.** Клас винятку **не може бути дженеріком**. Спроба написати `class MyException<T> extends Exception` призведе до **помилки компіляції**.
>
> **Причина:**
>
> Це пов'язано з **механізмом обробки винятків у JVM** та **стиранням типів (type erasure)** для дженериків.
>
> 1. Коли ви пишете `catch(MyException<String> e)`, компілятор, через стирання типів, на рівні байткоду перетворить це на `catch(MyException e)`.
>
> 2. JVM під час виконання **повинна точно знати**, який тип винятку перехоплювати, щоб порівняти його з типом кинутого винятку. Інформація про `<String>` вже буде відсутня.
>
> 3. Це створило б серйозні проблеми з типобезпечністю. Ви не могли б мати окремі `catch`-блоки для `MyException<String>` та `MyException<Integer>`.
>
> Щоб уникнути цієї складності та потенційних помилок, специфікація Java просто **забороняє** створювати дженерік-нащадків `Throwable`.
>
> Якщо вам потрібно передати типізовану інформацію з винятком, ви можете зробити це, додавши дженерік-поле та геттер у ваш кастомний виняток, але сам клас винятку не може бути параметризованим.

#### **📌 Що перевіряють:**

*Експертне знання про обмеження дженериків та їхню взаємодію з системою обробки винятків.*

* * *

### **14 ❓ Питання:**

Спроектуйте стратегію, як можна уникнути використання `checked` винятків у вашому API, якщо ваша бібліотека внутрішньо залежить від API, що їх кидає. ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> Це поширене архітектурне завдання. Стратегія полягає в **абстрагуванні та загортанні**.
>
> 1. **Створити власну ієрархію `unchecked` винятків:**
>     * Визначити базовий `RuntimeException` для вашого API, наприклад, `MyApiSystemException`.
>     * Створити більш специфічних нащадків за потреби (`ConfigException`, `ConnectionException`).
>
> 2. **Створити шар-адаптер (Facade або Wrapper):**
>     * Цей шар буде єдиним місцем у вашому коді, який безпосередньо взаємодіє зі сторонньою бібліотекою.
>     * Всередині методів цього адаптера ви обгортаєте виклики в `try-catch`.
>
> 3. **Загортати `checked` у `unchecked`:**
>     * У `catch` блоці ви ловите `checked` виняток з бібліотеки.
>     * Ви створюєте екземпляр вашого кастомного `unchecked` винятку, передаючи оригінальний як `cause`.
>     * Ви кидаєте цей новий `unchecked` виняток.
>
> **Приклад:**
>
> ```java
> // Наш кастомний unchecked виняток
> class MyApiException extends RuntimeException {
>     MyApiException(String msg, Throwable cause) { super(msg, cause); }
> }
>
> public class LegacyApiAdapter {
>     private LegacyApi legacyApi = new LegacyApi();
>
>     public void doSomething() {
>         try {
>             legacyApi.callThatThrowsCheckedException();
>         } catch (LegacyCheckedException e) {
>             // Загортаємо і кидаємо далі як unchecked
>             throw new MyApiException("Помилка при роботі з legacy API", e);
>         }
>     }
> }
> ```
>
> Тепер весь ваш додаток працює з `LegacyApiAdapter` і не бачить `LegacyCheckedException`, а обробляє (або не обробляє) лише ваш чистий `MyApiException`.
>
> Це дозволяє **створити "бар'єр"**, який захищає решту вашого коду від "забруднення" `checked` винятками.

#### **📌 Що перевіряють:**

*Здатність проектувати ізольовані архітектурні шари та застосовувати патерн "Адаптер" для обробки винятків.*

* * *

### **15 ❓ Питання:**

Як правило **"Fail-Fast"** пов'язане з вибором між створенням `checked` чи `unchecked` винятку? ⭐️⭐️⭐️

> #### **💬 Відповідь:**
>
> **Fail-Fast** — це принцип, згідно з яким система повинна негайно повідомляти про помилку при її виявленні, а не продовжувати роботу в потенційно некоректному стані.
>
> **`Unchecked` винятки (`RuntimeException`) є основним інструментом для реалізації Fail-Fast.**
>
> **Як це пов'язано:**
>
> * **`Unchecked` винятки:**
>   * Кидаються при **порушенні контракту або внутрішніх інваріантів** (наприклад, `IllegalArgumentException`, `IllegalStateException`).
>   * Вони не призначені для обробки та відновлення. Їхня мета — **негайно зупинити** поточну операцію, тому що продовжувати її небезпечно.
>   * Це і є реалізація Fail-Fast: ми "падаємо" одразу ж, як тільки виявили програмний баг, надаючи чіткий стек-трейс для налагодження.
>
> * **`Checked` винятки:**
>   * Вони представляють **очікувані** помилки і є частиною **нормального потоку обробки помилок**, а не негайного "падіння".
>   * Вони, по суті, протилежні Fail-Fast — вони заохочують до **відновлення (recovery)**, а не до зупинки.
>
> **Приклад:**
> Метод, що приймає `user_id`, повинен на самому початку перевірити `if (user_id <= 0) throw new IllegalArgumentException(...)`. Це Fail-Fast. Він не намагається працювати з невалідними даними, а одразу повідомляє про помилку виклику. Для такої ситуації `checked` виняток був би недоречним.

#### **📌 Що перевіряють:**

*Глибоке розуміння філософії обробки помилок. Кандидат повинен бачити `unchecked` винятки не як "ті, що можна не ловити", а як "ті, що сигналізують про необхідність негайної зупинки".*
