---
layout: default
title: "Ледачість потоків (Lazy Evaluation)"
parent: "Stream API"
grand_parent: "Java 8"
nav_order: 3
---

# Ледачість потоків (Lazy Evaluation)

* короткий опис: `Lazy evaluation` – це стратегія виконання, за якої обчислення проміжних операцій у Stream API відкладається до моменту, коли їхній результат дійсно потрібен (тобто при виклику кінцевої операції).

* поняття: Lazy Evaluation, `short-circuiting` (коротке замикання).

* приклади: `filter(...).findFirst()` (обробка зупиняється після знаходження першого елемента), `Stream.iterate(...).limit(...)` (для нескінченних стрімів).

* ключові моменти: Оптимізує виконання, дозволяє обробляти нескінченні стріми, мінімізує непотрібні обчислення.

* що важливо знати на співбесіді: Принцип, як впливає на продуктивність.

### **✅ Офіційне визначення:**

**Lazy evaluation** — це стратегія виконання, за якої обчислення виразів відкладається до моменту, коли їх результат дійсно потрібен. У Java Stream API це означає, що **проміжні операції** не виконуються відразу, а лише при виклику **кінцевої операції**.

### **🧠 Простими словами:**

Проміжні дії в стрімі — це як список справ на потім. Java запам’ятовує, *що* ти хочеш зробити, але *неробить*, поки ти не скажеш: «Окей, виконай» — тобто не викличеш термінальну операцію (**`collect(), findFirst(), forEach()`** і т.д.)

---

## 📊 **Lazy vs Eager в контексті Stream API:**

|      Категорія       |        Lazy (ледача)         |            Eager (жадібна)            |
|:--------------------:|:----------------------------:|:-------------------------------------:|
|   **Тип операцій**   | Проміжні (**`filter, map`**) |  Кінцеві (**`collect, findFirst`**)   |
| **Коли виконується** |  Лише при запуску кінцевої   |          Одразу при виклику           |
|     **Повертає**     |         Новий Stream         | Конкретний результат (List, Optional) |
|     **Обробка**      |   Поелементна, вертикальна   |        По всьому стріму одразу        |
|   **Оптимізація**    |           Можлива            |             Зазвичай — ні             |

---

## **Пояснення на пальцях (💡)**

Уяви, що ти складаєш план на день:

* Піти в магазин
* Купити каву
* Купити хліб  
  
  Але ти не йдеш одразу — чекаєш, поки буде потреба. Це і є **ледачість**: ти *плануєш*, але не *виконуєш*, поки не настане момент (кінцева операція).

У стрімах так само — поки не буде фінального “execute”, Java нічого не робить, тільки збирає “маршрут”.

---

## **Корисні приклади (🧪)**

### **🔹 Без кінцевої операції — нічого не відбувається:**

```java
Stream.of("a", "b", "c")
    .map(s -> {
        System.out.println("Mapping: " + s);
        return s.toUpperCase();
    });
// нічого не виводиться
```

### **🔹 З `findFirst()` — ледача оптимізація:**

```java
Stream.of("beta", "alpha", "gamma")
    .filter(s -> {
        System.out.println("Filtering: " + s);
        return s.startsWith("a");
    })
    .findFirst();
```

🖨️ Вивід:

```java
Filtering: beta
Filtering: alpha
```

`gamma` навіть не обробляється — обчислення зупиняється, щойно знайдено перший елемент.

---

### **🔹 Нескінченний стрім \+ limit:**

```java
Stream.iterate(1, n -> n + 1)
    .filter(n -> n % 5 == 0)
    .limit(3)
    .forEach(System.out::println);
```

Результат: 5, 10, 15  
Навіть з нескінченним стрімом Java не зависає — обробка йде рівно до **`limit(3)`**, завдяки ледачості.

---

## **Порівняння (⚖️)**

|         Особливість         |     Проміжні операції (lazy)     |             Кінцеві операції (eager)              |
|:---------------------------:|:--------------------------------:|:-------------------------------------------------:|
|         **Приклад**         |      **`map(), filter()`**       |       **`collect(), count(), findFirst()`**       |
|   **Виконуються одразу?
   |                ❌                 |                         ✅                         |
|       **Повертають**        |              Stream              | Значення (**`List`**, **`long`**, **`Optional`**) |
|  **Використовуються для**   |          Трансформацій           |               Отримання результату                |
| **Можуть бути безкінечні?
 | ✅ (з **`limit()`** або подібним) |             ❌ (потребують завершення)             |

---

## **🧠 Мнемоніка для запам’ятовування:**

**План без дії — просто список. Потік без кінця — просто маршрут\!**

або

**Lazy river: пливе лише тоді, коли відкрив дамбу (термінальну операцію)**

---

## **🟩 Підсумок:**

* **Lazy evaluation** — це механізм, що дозволяє **відкласти обчислення** до потреби.
* **Проміжні операції** (**`filter`**, **`map`**) самі по собі нічого не роблять.
* Все виконується лише після **кінцевої операції** (**`collect`**, **`count`**, **`findFirst`**, **`forEach`**).
* Завдяки цьому потік може:
  * обробляти нескінченні послідовності
  * **оптимізувати обчислення**
  * мінімізувати витрати часу й пам’яті

---

### **🔗 Додаткові джерела:**

* [**Офіційна документація Stream API (Oracle)**](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html)

* * *

# **FAQ — Часті запитання (❓)**

### **1 ❓ Питання:**

Що таке ледача оцінка (Lazy Evaluation) в Java Stream API?

> #### **💬 Відповідь:**
>
> **Ледача оцінка (Lazy Evaluation)** — це стратегія виконання, при якій обчислення відкладаються до моменту, коли їхній результат справді стає необхідним.
>
> У контексті `Stream API` це означає, що **проміжні операції** (`filter`, `map`, `sorted` тощо) **не виконуються негайно**. Вони лише будують "рецепт" або план обчислень (так званий pipeline), але не обробляють жодного елемента.
>
> Фактична обробка даних починається лише тоді, коли викликається **термінальна операція** (`collect`, `forEach`, `findFirst` тощо). Тільки в цей момент елементи починають проходити через весь ланцюжок проміжних операцій.
>
> Цей підхід є ключовою оптимізацією в Stream API.

#### **📝 Аналогія:**

Уявіть, що ви даєте своєму GPS-навігатору команду побудувати маршрут з Києва до Львова.

* **Проміжні операції:** Ви додаєте умови: "уникати платних доріг" (`filter`), "показати час у дорозі для кожної ділянки" (`map`). Навігатор ще не їде, він лише будує план.
* **Термінальна операція:** Ви натискаєте кнопку "Поїхали!" (`collect`). Тільки в цей момент починається реальний рух по побудованому маршруту.

#### **📌 Що перевіряють:**

*Фундаментальне розуміння того, як працює Stream API "під капотом". Це ключова концепція, що відрізняє стріми від звичайних циклів.*

* * *

### **2 ❓ Питання:**

Які операції в Stream API є ледачими, а які — ні?

> #### **💬 Відповідь:**
>
> * **Ледачі (Lazy) операції — це всі проміжні операції (Intermediate Operations).**
>     Вони приймають потік і повертають новий потік, але не ініціюють обробку.
>   * **Приклади:** `filter`, `map`, `flatMap`, `sorted`, `distinct`, `limit`, `skip`, `peek`.
>
> * **Не ледачі, або "гарячі" (Eager) операції — це всі термінальні операції (Terminal Operations).**
>     Вони запускають весь конвеєр обчислень і повертають кінцевий результат (або `void`).
>   * **Приклади:** `collect`, `forEach`, `reduce`, `count`, `findFirst`, `anyMatch`.

#### **📌 Що перевіряють:**

*Здатність класифікувати операції та розуміння, яка з них є тригером для виконання всього ланцюжка.*

* * *

### **3 ❓ Питання:**

Наведіть приклад коду, який демонструє, що проміжні операції не виконуються без термінальної.

> #### **💬 Відповідь:**
>
> Найкращий спосіб це продемонструвати — додати вивід у консоль всередині проміжної операції, як-от `map`, і не викликати термінальну операцію.
>
> В цьому прикладі, оскільки ланцюжок не має термінальної операції, жоден з викликів `map` або `filter` не буде виконано, і в консоль не буде виведено нічого.

#### **📝 Приклад:**

```java
import java.util.stream.Stream;

public class LazyDemo {
    public static void main(String[] args) {
        System.out.println("Створюємо потік...");

        Stream.of("a", "b", "c")
              .filter(s -> {
                  System.out.println("Фільтруємо: " + s); // Цей код НЕ виконається
                  return true;
              })
              .map(s -> {
                  System.out.println("Перетворюємо: " + s); // І цей код НЕ виконається
                  return s.toUpperCase();
              });

        System.out.println("Ланцюжок побудовано, але нічого не виконано.");
    }
}
```

#### **📌 Що перевіряють:**

*Практичне розуміння лінивості. Кандидат повинен вміти передбачити, що цей код не дасть жодного виводу від стріму.*

* * *

### **4 ❓ Питання:**

Які основні переваги ледачої оцінки?

> #### **💬 Відповідь:**
>
> Ледача оцінка надає кілька значних переваг, в основному пов'язаних з **продуктивністю та оптимізацією**:
>
> 1. **Уникнення зайвих обчислень:**
>     Якщо кінцевий результат можна отримати, не обробляючи всі елементи, стрім не буде робити зайвої роботи. Це особливо помітно з операціями "короткого замикання" (`short-circuiting`), як-от `findFirst` або `anyMatch`.
>
> 2. **Об'єднання операцій (Operation Fusion):**
>     Замість того, щоб проходити по колекції кілька разів для кожної проміжної операції (спочатку `filter`, потім `map`), стрім обробляє елементи "вертикально". Кожен елемент проходить через весь конвеєр операцій за один раз. Це значно зменшує кількість ітерацій.
>
> 3. **Можливість роботи з нескінченними потоками:**
>     Оскільки обчислення відбуваються лише за потребою, ми можемо створювати нескінченні потоки даних (напр., `Stream.iterate(0, n -> n + 1)`). Якщо такий потік обмежується операцією `limit(10)`, буде оброблено лише перші 10 елементів, і програма не увійде в нескінченний цикл.

#### **📌 Що перевіряють:**

*Здатність пояснити, яку конкретну користь приносить ледачість. Кандидат повинен розуміти, що це не просто "відкладання", а потужний механізм оптимізації.*

* * *

### **5 ❓ Питання:**

Що таке операції "короткого замикання" (short-circuiting) і як вони пов'язані з ледачістю?

> #### **💬 Відповідь:**
>
> **Short-circuiting операції** — це операції, які можуть завершити обробку потоку, **не перебираючи всі його елементи**, якщо кінцевий результат вже відомий.
>
> Ледача оцінка робить ці операції можливими та надзвичайно ефективними.
>
> **Приклади:**
>
> * **Проміжна операція `limit(n)`:** Як тільки потік "назбирав" `n` елементів, він припиняє запитувати нові елементи з джерела.
> * **Термінальна операція `findFirst()`:** Як тільки знайдено перший елемент, що пройшов через усі фільтри, потік негайно завершує роботу.
> * **Термінальна операція `anyMatch(predicate)`:** Як тільки знайдено перший елемент, що відповідає предикату, потік завершується, повертаючи `true`.
>
> Завдяки `short-circuiting` можна ефективно працювати з дуже великими або навіть нескінченними потоками.

#### **📝 Приклад:**

```java
List<String> list = List.of("apple", "banana", "apricot");
Optional<String> result = list.stream()
                              .filter(s -> s.startsWith("a"))
                              .findFirst(); // Знайде "apple" і одразу зупиниться
```

У цьому прикладі слово "banana" навіть не буде передано у `filter`.

#### **📌 Що перевіряють:**

*Розуміння механізмів оптимізації у Stream API. `Short-circuiting` — це один з найважливіших з них.*

* * *

### **6 ❓ Питання:**

Як ледача оцінка впливає на обробку `parallelStream()`?

> #### **💬 Відповідь:**
>
> Ледача оцінка є **ключовою** для ефективної роботи паралельних потоків.
>
> 1. **Побудова плану:** Коли ви створюєте ланцюжок операцій на `parallelStream()`, нічого не відбувається. Як і в послідовному стрімі, будується лише план обчислень.
>
> 2. **Розбиття на етапі термінальної операції:** Лише при виклику термінальної операції, фреймворк `ForkJoinPool` розбиває джерело даних на частини (`Spliterator`).
>
> 3. **Ефективна обробка:** Кожен потік паралельно обробляє свою частину даних, пропускаючи елементи через весь конвеєр. Якби оцінка не була ледачою, неможливо було б ефективно розпаралелити роботу — довелося б чекати завершення кожної проміжної операції на всіх даних, що звело б нанівець переваги паралелізму.
>
> Ледачість дозволяє розпаралелити весь **конвеєр**, а не окремі операції.

#### **📌 Що перевіряють:**

*Розуміння синергії між двома основними фічами Stream API: ледачістю та паралелізмом.*

* * *

### **7 ❓ Питання:**

Які операції в Stream API є "гарячими" (eager) і що це означає?

> #### **💬 Відповідь:**
>
> "Гарячими" (eager) називають **термінальні операції**.
>
> Це означає, що їх виклик **негайно запускає** процес обробки всіх попередніх проміжних операцій. Вони "витягують" дані з потоку і перетворюють їх на кінцевий результат.
>
> На відміну від "ледачих" проміжних операцій, які просто повертають новий `Stream`, "гарячі" термінальні операції повертають конкретне значення (`long`, `Optional`, `boolean`) або колекцію (`List`, `Set`), або нічого не повертають (`void`).
>
> Будь-яка "гаряча" операція **завершує життєвий цикл** потоку.

#### **📌 Що перевіряють:**

*Знання альтернативної термінології (lazy vs eager) для опису операцій стрімів.*

* * *

### **8 ❓ Питання:**

Чому `sorted()` та `distinct()` є `stateful`-операціями і як це пов'язано з ледачістю? ⭐️

> #### **💬 Відповідь:**
>
> `sorted()` та `distinct()` є `stateful`-операціями, оскільки для своєї роботи їм потрібно **накопичувати стан** — інформацію про елементи, які вони вже бачили.
>
> * **`sorted()`**: Щоб відсортувати потік, потрібно **побачити всі його елементи**. Не можна відсортувати елементи, поки ви не отримали їх усі. Тому `sorted()` змушена буферизувати всі елементи, і лише після цього може віддати їх у відсортованому порядку далі по конвеєру.
> * **`distinct()`**: Щоб визначити, чи є елемент унікальним, потрібно пам'ятати **всі унікальні елементи**, які вже зустрічалися. Тому `distinct()` підтримує внутрішню колекцію (напр., `HashSet`) для відстеження унікальних значень.
>
> **Зв'язок з ледачістю:**
> Хоча ці операції є `stateful`, вони все ще є **проміжними і ледачими**. Це означає, що вони не почнуть накопичувати стан і обробляти елементи доти, доки не буде викликана термінальна операція. Однак, коли термінальна операція почне "тягнути" дані, ці `stateful`-операції можуть стати "пляшковим горлечком", оскільки вони не можуть віддавати елементи по одному, а змушені спочатку накопичити певну кількість (або всі) елементи.

#### **📌 Що перевіряють:**

*Розуміння того, що різні проміжні операції мають різну "вартість" і вплив на продуктивність. `stateful`-операції зазвичай є більш ресурсомісткими.*

* * *

### **9 ❓ Питання:**

Поясніть на прикладі, як ледачість та вертикальна обробка оптимізують цей ланцюжок: `stream.filter(...).map(...).limit(1)`. ⭐️

> #### **💬 Відповідь:**
>
> Це чудовий приклад, де переваги ледачості та short-circuiting стають очевидними. Припустимо, у нас є великий список чисел.
>
> `List.of(1, 2, 3, 4, 5, 6, 7, 8).stream()`
> `.filter(n -> n > 3)`
> `.map(n -> n * 10)`
> `.limit(1)`
> `.forEach(System.out::println);`
>
> **Процес виконання:**
>
> 1. Термінальна операція (`forEach`) запускає конвеєр. Операція `limit(1)` повідомляє, що після отримання одного елемента роботу можна завершити.
>
> 2. **Елемент 1:**
>     * `filter` перевіряє `1 > 3` -> `false`. Елемент відкидається.
>
> 3. **Елемент 2:**
>     * `filter` перевіряє `2 > 3` -> `false`. Елемент відкидається.
>
> 4. **Елемент 3:**
>     * `filter` перевіряє `3 > 3` -> `false`. Елемент відкидається.
>
> 5. **Елемент 4:**
>     * `filter` перевіряє `4 > 3` -> `true`. Елемент проходить далі.
>     * `map` приймає `4` і перетворює його на `40`.
>     * `limit(1)` отримує один елемент (`40`) і "говорить" потоку, що ліміт досягнуто.
>     * `forEach` отримує `40` і виводить його в консоль.
>
> 6. **Робота завершена.** Елементи 5, 6, 7, 8 навіть **не будуть оброблені** ні операцією `filter`, ні `map`. Завдяки ледачості, ми уникнули зайвих обчислень.

#### **📌 Що перевіряють:**

*Здатність "прокрутити" виконання стріму в голові, розуміючи, як елементи рухаються по конвеєру.*

* * *

### **10 ❓ Питання:**

Як `Optional.orElseGet(Supplier)` використовує принцип ледачої оцінки? ⭐️⭐️

> #### **💬 Відповідь:**
>
> Методи `Optional.orElse()` та `Optional.orElseGet()` є класичним прикладом різниці між "гарячою" (eager) та "ледачою" (lazy) оцінкою.
>
> * **`orElse(T value)` — "гаряча" оцінка:**
>   * Аргумент `value` **обчислюється завжди**, незалежно від того, чи є `Optional` порожнім.
>   * `optional.orElse(createDefaultValue())` — метод `createDefaultValue()` буде викликаний, навіть якщо `optional` містить значення.
>
> * **`orElseGet(Supplier<T> supplier)` — "ледача" оцінка:**
>   * Приймає `Supplier`, який містить логіку для створення значення за замовчуванням.
>   * Метод `get()` цього `Supplier`'а буде викликано **лише тоді**, коли `Optional` є **порожнім**.
>
> **Використання `Supplier`** є реалізацією ледачої оцінки: обчислення відкладається доти, доки його результат справді не знадобиться. Це дозволяє уникнути виконання "дорогих" операцій зі створення значень за замовчуванням, якщо вони не потрібні.

#### **📌 Що перевіряють:**

*Розуміння того, що принцип ледачості застосовується не тільки в Stream API, а й в інших сучасних API Java, як-от `Optional`.*

* * *

### **11 ❓ Питання:**

Чи може `peek` вплинути на результат роботи потоку, якщо в ньому змінювати стан об'єктів? Чи є це ледачою операцією? ⭐️⭐️

> #### **💬 Відповідь:**
>
> * **Чи є ледачою:** Так, **`peek()` є проміжною, ледачою операцією**. Вона не буде виконана доти, доки не буде викликана термінальна операція.
>
> * **Чи може вплинути на результат:** **Так, може**, і саме тому це вважається **дуже поганою практикою та антипатерном**.
>
> Якщо `peek` використовується для зміни стану мутабельного об'єкта, що проходить через потік, це створює **побічний ефект (side-effect)**.
>
> **Приклад (антипатерн):**
>
> ```java
> List<User> users = ...;
> List<User> result = users.stream()
>     .peek(user -> user.setActive(true)) // Змінюємо стан!
>     .collect(Collectors.toList());
> ```
>
> В цьому випадку `peek` не просто "підглядає", а й модифікує елементи. Це порушує принципи функціонального програмування (чистота, імутабельність), робить код непередбачуваним, а головне — повністю ламає логіку для паралельних потоків.
>
> Для зміни елементів слід використовувати проміжну операцію **`map()`**, яка створена саме для цього. `map` має створювати **новий** екземпляр з новими даними, а не змінювати старий.

#### **📌 Що перевіряють:**

*Розуміння ризиків, пов'язаних з побічними ефектами у функціональному коді. Кандидат повинен чітко знати, що `peek` — для налагодження, а `map` — для перетворення.*

* * *

### **12 ❓ Питання:**

Чи завжди `parallelStream` швидший за `stream` завдяки ледачості? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Ні, абсолютно не завжди.** Ледачість є передумовою для роботи паралелізму, але не гарантує прискорення.
>
> `parallelStream` може бути **значно повільнішим**, ніж послідовний `stream`, у таких випадках:
>
> 1. **Малий обсяг даних:** Накладні витрати на розбиття даних, керування потоками та об'єднання результатів значно перевищують вигоду від паралельних обчислень.
> 2. **"Дешеві" операції:** Якщо операції над елементами (в `map` або `filter`) є дуже швидкими, то "вузьким місцем" стає не сама робота, а керування потоками.
> 3. **Погано розщеплюване джерело:** `LinkedList`, наприклад, дуже погано розбивається на частини, тому паралельна обробка на ньому буде неефективною.
> 4. **Stateful-операції:** Операції як-от `sorted()` або `distinct()` можуть вимагати значної синхронізації в паралельному режимі.
>
> `parallelStream` дає значний приріст лише для **великих обсягів даних** з **добре розщеплюваним джерелом** (як `ArrayList`) та **"дорогими" обчисленнями** над кожним елементом.

#### **📌 Що перевіряють:**

*Зріле розуміння того, коли паралелізм є доцільним. Кандидат не повинен думати, що `.parallelStream()` — це "чарівна кнопка" для прискорення.*

* * *

### **13 ❓ Питання:**

Якби у стрімі не було ледачої оцінки, як би це змінило роботу з нескінченними потоками? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Робота з нескінченними потоками стала б неможливою.**
>
> **Що б сталося без ледачості ("гаряча" оцінка):**
>
> Якби кожна проміжна операція була "гарячою", вона б намагалася обробити **всі елементи** з вхідного потоку, щоб створити новий потік.
>
> Розглянемо приклад:
> `Stream.iterate(0, n -> n + 1).map(n -> n * n).limit(10).collect(Collectors.toList());`
>
> * Без ледачості, операція `map` спробувала б обробити **всі** елементи з нескінченного потоку, згенерованого `iterate`.
> * Це призвело б до **нескінченного циклу**, і програма б зависла, ніколи не дійшовши до операції `limit()`.
>
> Саме **ледачість** дозволяє `limit(10)` "сказати" попереднім операціям: "мені потрібно лише 10 елементів, можете не генерувати решту". Таким чином, `iterate` та `map` виконаються лише 10 разів.

#### **📌 Що перевіряють:**

*Глибоке розуміння того, що ледача оцінка — це не просто оптимізація, а фундаментальний механізм, який уможливлює роботу з певними типами даних, як-от нескінченні послідовності.*

* * *

### **14 ❓ Питання:**

Чому кажуть, що `Stream API` обробляє дані "вертикально", а не "горизонтально"? Поясніть на прикладі. ⭐️⭐️

> #### **💬 Відповідь:**
>
> Це порівняння описує спосіб, у який елементи проходять через конвеєр операцій.
>
> * **"Горизонтальна" обробка (як у звичайних циклах):**
>     Ви б спочатку пройшли по всій колекції для `filter`, створили б проміжну колекцію. Потім пройшли б по цій новій колекції для `map` і т.д.
>
>     ```
>     filter: elem1, elem2, elem3 ... -> new_list
>     map:    elem1_new, elem2_new, elem3_new ... -> final_list
>     ```
>
> * **"Вертикальна" обробка (як у `Stream API` завдяки ледачості):**
>     Кожен елемент проходить **весь конвеєр операцій за один раз**, від початку до кінця, перш ніж почнеться обробка наступного елемента.
>
>     ```
>     elem1 -> filter -> map -> ...
>     elem2 -> filter -> map -> ...
>     elem3 -> filter -> map -> ...
>     ```
>
> #### Приклад
>
> `stream.map(...).filter(...).forEach(...)`
>
> 1. Береться перший елемент. Він проходить через `map`.
> 2. Результат `map` передається у `filter`.
> 3. Результат `filter` (якщо він є) передається у `forEach`.
> 4. І **тільки після цього** береться другий елемент і повторює весь шлях.
>
> Ця "вертикальна" обробка є наслідком об'єднання операцій (operation fusion) і значно ефективніша, бо мінімізує кількість проходів по даних.

#### **📌 Що перевіряють:**

*Дуже деталізоване розуміння механізму виконання стрімів. Це ключова відмінність від імперативного підходу.*

* * *

### **15 ❓ Питання:**

Чи можна реалізувати "ледачу" колекцію без Stream API? Якщо так, то як? ⭐️⭐️

> #### **💬 Відповідь:**
>
> **Так, можна.** Концепція ледачості не є унікальною для Stream API. Її можна реалізувати вручну за допомогою ітераторів та функціональних інтерфейсів.
>
> **Ідея реалізації (спрощено):**
> Можна створити власний клас "ледачої колекції", який:
>
> 1. Внутрішньо не зберігає самі елементи, а лише **`Iterator`** початкового джерела та **ланцюжок функцій-перетворювачів** (`Function`, `Predicate`).
> 2. Кожен виклик методів `map` або `filter` не обробляє дані, а лише **додає нову функцію** до цього ланцюжка.
> 3. Коли ви починаєте ітерувати по цій ледачій колекції (напр., викликаючи її метод `.iterator().next()`), вона "тягне" один елемент з початкового ітератора і послідовно пропускає його через весь ланцюжок збережених функцій, доки не отримає кінцевий результат.
>
> Це, по суті, є спрощеною імітацією того, що робить `Stream API`. Багато сторонніх функціональних бібліотек (як Vavr) мають власні реалізації "ледачих" колекцій.
>
> **Чому це не роблять щодня:**
> `Stream API` вже надає оптимізовану, стандартизовану та потужну реалізацію цього, тому створювати власну "з нуля" зазвичай немає потреби.

#### **📌 Що перевіряють:**

*Дуже глибокі знання інформатики та здатність думати на рівні проектування власних структур даних. Це питання для перевірки фундаментальних знань та інженерної креативності.*

* * *
